<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | ScaleformBestPractices    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">ScaleformBestPractices  </b></div>
<div id="tooltext">
<a href="ScaleformBestPracticesJP.html" class="twikiLink">日本語訳</a><br><a href="ScaleformBestPracticesCH.html" class="twikiLink">中国翻译</a><br><a href="ScaleformBestPracticesKR.html" class="twikiLink">한국어</a><br>

<!-- Three/ScaleformBestPractices -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="UIAndHUDHome.html" class="twikiLink">User Interfaces &amp; HUDs</a></b> &gt; <b><a href="Scaleform.html" class="twikiLink">Scaleform GFx</a></b> &gt; Scaleform GFx Content Best Practices
</div>
<hr size="1" noshade="noshade">
<h1><a name="Scaleform GFx Content Best Practices"></a> Scaleform GFx Content Best Practices </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="ScaleformBestPractices.html#Scaleform GFx Content Best Practices"> Scaleform GFx Content Best Practices</a> <ul>
<li> <a href="ScaleformBestPractices.html#Overview"> Overview</a>
</li> <li> <a href="ScaleformBestPractices.html#Draw Primitives"> Draw Primitives</a>
</li> <li> <a href="ScaleformBestPractices.html#Movie Clips"> Movie Clips</a>
</li> <li> <a href="ScaleformBestPractices.html#Bitmaps vs. Vector graphics"> Bitmaps vs. Vector graphics</a> <ul>
<li> <a href="ScaleformBestPractices.html#Vector graphics"> Vector graphics</a>
</li> <li> <a href="ScaleformBestPractices.html#Bitmaps"> Bitmaps</a>
</li></ul>
</li> <li> <a href="ScaleformBestPractices.html#Animation"> Animation</a>
</li> <li> <a href="ScaleformBestPractices.html#Text and Fonts"> Text and Fonts</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
<p />
When developing Flash content for use with the Scaleform GFx integration in Unreal Engine 3, there are a number of considerations and optimizations that should be followed and implemented in order to get the best performance. This document details many of these best practices.
<p />
<h2><a name="Draw Primitives"></a> Draw Primitives </h2>
<hr size="1" noshade="noshade">
<p />
Draw primitives (DPs) are 3D mesh objects created by GFx to render 2D Flash elements, such as a group of shapes on the same layer. Each draw primitive is rendered independently, incurring a significant cost. In general, display performance will tend to decrease linearly as more DPs are introduced into the scene; therefore it is a good practice to keep the DP count as low as possible. The number of draw primitives can be determined via the GFxPlayer HUD by pressing the (F2) key, which brings up the AMP HUD summary screen. This screen displays triangle counts, DPs, memory use and other optimization information.
<p />
The following are a few facts to help keep draw primitive count low:
<p /> <ol>
<li> Gradient fills can increase the number of DPs if several of them are used in a shape at the same time.
</li> <li> Vector graphics with solid fills and no strokes on the same layer are very cheap. Only one DP is required to represent any amount of these types of shapes on a single layer, even if those shapes use different colors.
</li> <li> Each vector shape (or group of vector shapes) on its own layer requires one DP.
</li> <li> Strokes are more expensive than fills, unless all strokes are the same solid color.
</li> <li> Each dissimilar (different color) solid stroke on a layer adds one DP.
</li> <li> Empty movie clips do not require a DP; however, a movie clip with objects in it will require the amount of DPs dictated by those objects.
</li> <li> Alpha, Blends, and Transparency effects do not affect the number of DPs required; however, they will have an impact on rendering performance.
</li> <li> Each bitmap/texture on the Stage requires one DP.
</li> <li> Each text field requires at least one DP. Adding a border/background will add one more DP. Although in most cases all of text glyphs will be rendered from texture with one DP, large text may end up being rendered as vector shapes with each glyph using is a separate primitive. If clipping of vector glyphs is necessary then the text field will use a mask, which adds one more DP. Masks currently have a significant performance cost and clipped text fields will compound this penalty.
</li></ol>
<p />
<h2><a name="Movie Clips"></a> Movie Clips </h2>
<hr size="1" noshade="noshade">
<p /> <ol>
<li> Rather than hiding movie clips, it is best to delete them completely from the timeline when not in use, otherwise they may take up processing time during Advance.
</li> <li> Avoid excessive nesting of movie clips, as this will affect performance.
</li> <li> If it is necessary to hide a movie clip then use _visible=false rather than _alpha=0. Make sure you have stopped the animation in hidden movie clips by calling the "stop()" function. Otherwise, invisible animation will still take place and affect performance.
</li></ol>
<p />
<h2><a name="Bitmaps vs. Vector graphics"></a> Bitmaps vs. Vector graphics </h2>
<hr size="1" noshade="noshade">
<p />
Flash content can be created with vector art as well as images and GFx can seamlessly render both vector and bitmap graphics. However, each type has its advantages and disadvantages. The decision to use vector or bitmap graphics is not always clear, and often depends on several factors. This section discusses some of the differences between vector and bitmap graphics to help make content authoring decisions.
<p />
Vector graphics maintain their smooth shapes when scaled in size, unlike bitmaps images that can appear box-like, or pixelated, when scaled. But unlike bitmaps, vector graphics require more processing power to generate. Although simple solid-color shapes will usually be as fast as bitmaps, complex vector graphics with many triangles, shapes and fills can be expensive to render. Consequently, heavy use of vector shapes can sometimes reduce overall application performance. As a rule of thumb, any vector shape that generates more than 200 triangles is probably best converted to a bitmap.
<p />
Bitmap graphics can be a better choice for some applications because they don't require as much processing time to render as vectors, however, bitmap graphics significantly increase the amount of memory required, compared to vector graphics.
<p />
<h3><a name="Vector graphics"></a> Vector graphics </h3>
<hr size="1" noshade="noshade">
<p />
Vectors graphics are more compact than other image formats because vectors define the math (points, curves, and fills) required to render the image at runtime rather than the raw graphic (pixel) data of a bitmap. However, converting the vector data to the final image is time consuming and must be done whenever there is significant change in appearance or scale of a graphic. If the movie clip contains complex shape outlines that change every frame, animations may run slowly.
<p />
The following are several guidelines to help render vector graphics efficiently:
<p /> <ul>
<li> Experiment with converting complex vector graphics to bitmaps and test how this affects performance.
</li> <li> Keep the following in mind when using alpha blends. <ul>
<li> Solid-filled strokes are cheaper to compute than alpha-blended strokes, since they can use a much more efficient algorithm.
</li> <li> Avoid using transparency (alpha). Flash must check all pixels underneath a transparent shape, which slows rendering down considerably. To hide a clip, set its _visible property to false rather than setting the _alpha property to 0. Graphics render fastest when their _alpha is set to 100. Setting the movie clip's timeline to an empty keyframe (so that the movie clip has no content to show) is usually an even faster option. Sometimes Flash still tries to render invisible clips; move the clip off stage by setting its _x and _y properties to a position off the visible stage, in addition to setting the _visible property to false, so Flash doesn't try to draw it at all.    * Optimize vector shapes.
</li> <li> In using vector graphics try to simplify the shapes as much as possible eliminating redundant points. This will reduce the amount of calculations that the player has to compute for each vector shape.
</li> <li> Use primitive vectors including circles, squares, and lines.
</li> <li> Flash's drawing performance is tied to how many points are drawn per frame. Optimize shapes with the Modify -&gt; Shape submenu, then select either Smooth, Straighten or Optimize (depending on the graphic in question) to reduce the number of points required to draw it. This helps reduce the mesh data that is created by the GFx vector tessellation code.
</li></ul>
</li> <li> Corners are cheaper than curves. <ul>
<li> Avoid complex vectors with too many curves and points.
</li> <li> Corners can be mathematically simpler to render than curves. When possible, stick with flat edges, especially with very small vector shapes. Curves can be simulated in this way.
</li></ul>
</li> <li> Use gradient fills and gradient strokes sparingly.
</li> <li> Avoid shape outlines (strokes). <ul>
<li> Whenever possible, do not use strokes with vector shapes, because doing so increases the number of rendered lines.
</li> <li> Outlines around vector images have a performance hit.
</li> <li> Whereas a fill has only an outside shape to render, outlines have an inside and an outside to render. This requires twice as much work to draw a line over a fill.
</li></ul>
</li> <li> Minimize the use of Flash’s Drawing API. It may cause significant performance overhead if used unnecessarily. If needed, use the Drawing API to draw on a movie clip once. There are no performance penalties for rendering such a custom movie clip.
</li> <li> Limit the use of masks. The masked pixels will still use up rendering time and have a negative impact on performance even though they are not drawn. Multiple masks compound the impact relative to the number of masks used. Note that in many cases the visual effect that artists use masks for does not require a mask. In particular, it is common to use a mask to cut a shape out of a bitmap. The same thing can be achieved much more efficiently by applying a bitmap fill to a shape directly in Flash Studio. This also provides the added benefit of Scaleform’s patent-pending EdgeAA anti-aliasing.
</li> <li> Convert multiple objects into one shape whenever possible to avoid generating extra draw primitives.
</li> <li> After a shape is created, it can be translated, rotated and blended with no additional memory use. However, bringing in new large shapes or doing significant scaling will consume more memory from tessellation.
</li> <li> With EdgeAA enabled, shapes built out of multiple solid colors will render faster than those built out of multiple gradients/bitmaps. Caution is advised when connecting gradients/bitmaps within one shape, as this will cause the number of draw primitives to increase quickly.
</li></ul>
<p />
<h3><a name="Bitmaps"></a> Bitmaps </h3>
<hr size="1" noshade="noshade">
<p />
The first step in creating optimized and streamlined animations or graphics is to outline and plan your project before its creation. Specify a target for the file size, memory usage and length of the animations that you want to create, and test throughout the development process to ensure that you are on track.
<p />
In addition to draw primitives described earlier, a significant factor that affects rendering performance is the total surface area drawn. Every time a visible shape or bitmap is placed on the Stage, it needs to be rendered even if it is hidden by other overlapping shapes, consuming video card fill-rate. Although today’s video cards are an order of magnitude faster than software Flash, large overlapping alpha-blended objects on screen can still greatly reduce performance, especially on lower-end and older hardware. For this reason it is important to flatten overlapping shapes and bitmaps, and explicitly hide obscured or clipped-off objects.
<p />
When hiding objects, it is best to set the _visible property of a movie clip instance to false instead of changing the _alpha level to 0 in a SWF file. Although GFx will not draw objects with _alpha value of 0, their children may still incur CPU processing cost due to animation and ActionScript. If the instance visibility is set to false, then there is potential for CPU cycles and memory savings, which can give your SWF files smoother animations and provide better overall performance for your application. Instead of unloading and possibly reloading assets, set the _visible property to false, which is much less processor-intensive.
<p />
The following are several guidelines to help render bitmap graphics efficiently:
<p /> <ul>
<li> Consider loading and unloading large bitmaps through ActionScript as needed.
</li> <li> It is important to keep track of the number and size of image files being used in your UI. Use the 'stat gfx' command in UE3 to see how much memory is being used by GFx.
</li> <li> Avoid overlapping big bitmaps since this affects fill-rate performance. Overlapping large areas of transparent bitmaps can also lead to bad performance.
</li> <li> Import bitmap graphics at the size that they will be used in the application; don't import large graphics and scale them down in Flash, as this wastes file size and runtime memory.
</li></ul>
<p />
<h2><a name="Animation"></a> Animation </h2>
<hr size="1" noshade="noshade">
<p />
When adding animation to an application, consider the frame rate of the FLA file. It can affect the performance of the final SWF file. Setting a frame rate too high can lead to performance problems, especially when many assets are used or AS is used to create animations that are ticked with the document’s frame rate.
<p />
However, the frame rate setting also affects how smoothly the animation plays. For example, an animation set to 12 frames per second (FPS) plays 12 frames of the timeline each second. If the document's frame rate is set to 24 FPS, the animation appears to animate more smoothly than if it is set to 12 FPS. However, an animation at 24 FPS also plays twice as fast as it would at 12 FPS, so the total duration (in seconds) would be half the duration. Therefore, in order to make a 5-second animation using a higher frame rate, additional frames are required to fill those five seconds than at a lower frame rate, which raises the total file size.
<p />
<strong>Note:</strong> When using an onEnterFrame event handler to create scripted animations, the animation runs at the document's frame rate, similar to creating a motion tween on the timeline. An alternative to the onEnterFrame event handler is setInterval. Instead of depending on frame rate, functions are called at a specified interval of milliseconds. Like onEnterFrame, the more frequently setInterval is used to call a function, the more resource intensive the animation will be.
<p />
Use the lowest possible frame rate that renders a smooth animation at runtime. This will help reduce the performance hit on the processor. Try not to use a frame rate that's more than 30 to 40 FPS; high frame rates beyond this point increate CPU cost and do not greatly improve the animation smoothness. <strong>In most cases, Flash UI can be safely set to half the target frame rate of the underlying game.</strong>
<p />
The following are several guidelines to help design and create efficient animations:
<p /> <ul>
<li> The number of objects on the stage and how fast things move affect the overall performance.
</li> <li> If there are a large amount of movie clips on the stage and they are required to switch on/off quickly, then _visible = true/false should be used to control their visibility instead of attaching/removing the movie clips.
</li> <li> Pay close attention to the use of tweens. <ul>
<li> Avoid tweening too many items simultaneously. Reduce the number of tweens and/or sequence animation so that one begins when another ends.
</li> <li> Use timeline motion tween instead of the standard Flash Tween class when possible because it has much less performance overhead.
</li> <li> Scaleform recommends the use of CLIK Tween class (gfx.motion.Tween) instead of the standard Flash Tween class since it is smaller, faster and cleaner.
</li></ul>
</li> <li> Keep the framerate low, as the difference between high and low framerates are often not noticable. The higher the framerate, the smoother the animation, but the performance impact increases. A game running at 60 frames per second does not require a Flash file set to 60 FPS. The Flash framerate should be the minimum required to produce the necessary visual effects.
</li> <li> Transparency and gradients are processor intensive tasks and should be used sparingly.
</li> <li> Make the area of focus well designed and animated, then reduce animation and effects in other areas of the screen.
</li> <li> Pause passive background animations (e.g., subtle background effects) during transitions.
</li> <li> Test adding/removing animated elements to weigh their impact on performance.
</li> <li> Use tween easing wisely. On slower hardware it can create an "appearance" of lag.
</li> <li> Avoid shape morphing animations, such as transforming a circle into a square, as they are very CPU intensive operations. Shape tweens (morphing) have a very significant CPU hit because the shape is recomputed every frame; the cost of the hit will depend on the complexity of the shape (number of edges, curves and intersections). It may still be useable for some scenarios, but profile it to verify that the cost is acceptable; the cost of a four-triangle tween may be acceptable. Essentially, there are performance/memory trade-offs to be aware of. Displaying the regular shape causes tessellation and caching of the shape so that it is displayed efficiently in future frames. With a morph, the trade-off is changed, since any change in the shape causes the old mesh to be released and a new one created.
</li> <li> The most efficient animations are translation and rotation. It is best to avoid scaling animations, as they may cause retessellation (which can have a noticeable performance hit) and the resulting mesh may consume more memory.
</li></ul>
<p />
<h2><a name="Text and Fonts"></a> Text and Fonts </h2>
<hr size="1" noshade="noshade">
<p /> <ul>
<li> Text glyph font sizes should be smaller than the font cache manager SlotHeight or the size planned to use with gfxexport (the default is 48 pixels). If a larger font is used, then vectors will be used and consequently be much slower because of many resulting DPs (each vector glyph generates a DP).
</li> <li> Turn off the border and background of a text field if possible, since this will save one draw primitive.
</li> <li> Updating a text field's content every frame is one of the biggest performance-sapping actions that can be easily avoided. Instead, change text field values only when their content truly changes or at the slowest rate possible. For example, when updating a timer that displays seconds, it is not necessary to update it at a frame rate of 30 FPS. Instead, record the old value and reassign the value of the text field only when the new value is different from the previous value.
</li> <li> Do not use variables linked to a text field ("TextField.variable" property), since the text field will retrieve and compare the variable every frame, thus affecting performance.
</li> <li> Minimize updating text by reassigning the “htmlText” property. Parsing HTML is a relatively expensive process.
</li> <li> Use gfxexport with options –fc, -fcl, -fcm to compact fonts in order to save memory on glyph shapes (especially, if Asian fonts are embedded). See the “Font Overview” document for more details.
</li> <li> Embed only the necessary symbols for fonts or use the fontlib mechanism if localization is necessary (again, please refer to the “Font Overview” document).
</li> <li> Use the smallest number of TextField objects necessary, combining multiple items into one whenever possible. A single text field can typically be rendered with one DP even if it uses different colors and font styles.
</li> <li> Avoid scaling text fields or using large font sizes; after a certain size the text field will switch to vector glyphs and each vector glyph becomes a draw primitive. If clipping is necessary (only part of a vector glyph is visible) then a mask will be used. Masks are slow and add an extra draw primitive. Clipping of rasterized glyphs does not require a mask.
</li> <li> Make sure the glyph cache size is large enough to hold all (or most) used glyphs. If the cache size is not enough then some glyphs might disappear, or there will be a serious performance hit due to frequent rerasterization of glyphs.
</li> <li> Using text effects such as blur, drop shadow or knockout filters require extra space in the font cache, and also affects performance. Minimize the use of text filters if possible.
</li> <li> Avoid using text field underlining since this adds an extra draw primitive.
</li></ul>
<!--  -->
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
