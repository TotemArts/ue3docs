<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | UT3Mods    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">UT3Mods  </b></div>
<div id="tooltext">
<a href="UT3ModsJP.html" class="twikiLink">日本語訳</a><br><a href="UT3ModsCH.html" class="twikiLink">中国翻译</a><br><a href="UT3ModsKR.html" class="twikiLink">한국어</a><br>

<!-- Three/UT3Mods -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="ModHome.html" class="twikiLink">Mod Home</a></b> &gt; <b><a href="UT3ModHome.html" class="twikiLink">Unreal Tournament 3 Mod Home</a></b> &gt; Mod Authoring for Unreal Tournament 3
</div>
<hr size="1" noshade="noshade">
<h1><a name="Mod Authoring for Unreal Tournament 3"></a> Mod Authoring for Unreal Tournament 3 </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="UT3Mods.html#Mod Authoring for Unreal Tournament 3"> Mod Authoring for Unreal Tournament 3</a> <ul>
<li> <a href="UT3Mods.html#Introduction"> Introduction </a>
</li> <li> <a href="UT3Mods.html#Some Advice to Start With"> Some Advice to Start With </a>
</li> <li> <a href="UT3Mods.html#Setting up a Mod Project"> Setting up a Mod Project</a> <ul>
<li> <a href="UT3Mods.html#Directory Structure"> Directory Structure</a>
</li> <li> <a href="UT3Mods.html#Running and Testing"> Running and Testing</a>
</li> <li> <a href="UT3Mods.html#Useful Console Commands"> Useful Console Commands</a>
</li> <li> <a href="UT3Mods.html#Packages"> Packages</a>
</li> <li> <a href="UT3Mods.html#Programming"> Programming</a> <ul>
<li> <a href="UT3Mods.html#UnrealScript"> UnrealScript</a>
</li> <li> <a href="UT3Mods.html#UnrealScript Source Files"> UnrealScript Source Files</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#Content Creation"> Content Creation</a> <ul>
<li> <a href="UT3Mods.html#Levels"> Levels</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#Publishing and Cooking"> Publishing and Cooking</a>
</li> <li> <a href="UT3Mods.html#Localization"> Localization</a>
</li> <li> <a href="UT3Mods.html#Distribution"> Distribution</a>
</li> <li> <a href="UT3Mods.html#Naming Conventions"> Naming Conventions</a>
</li> <li> <a href="UT3Mods.html#Consoles"> Consoles</a> <ul>
<li> <a href="UT3Mods.html#PlayStation 3 Mod Support"> PlayStation 3 Mod Support</a>
</li></ul>
</li></ul>
</li> <li> <a href="UT3Mods.html#The Four Mod Types"> The Four Mod Types </a> <ul>
<li> <a href="UT3Mods.html#Mutators"> Mutators </a>
</li> <li> <a href="UT3Mods.html#GameTypes"> GameTypes </a>
</li> <li> <a href="UT3Mods.html#Total Conversions"> Total Conversions </a>
</li> <li> <a href="UT3Mods.html#Custom Content"> Custom Content</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#How to Make a Mutator"> How to Make a Mutator </a> <ul>
<li> <a href="UT3Mods.html#Configuration"> Configuration</a>
</li> <li> <a href="UT3Mods.html#The Anatomy of Mutator - a First Look"> The Anatomy of Mutator - a First Look</a>
</li> <li> <a href="UT3Mods.html#Taking It Further: Game Rules"> Taking It Further: Game Rules</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#Introduction to _GameTypes"> Introduction to GameTypes </a> <ul>
<li> <a href="UT3Mods.html#Configuration"> Configuration</a>
</li> <li> <a href="UT3Mods.html#A first look at _GameInfo"> A first look at GameInfo </a>
</li> <li> <a href="UT3Mods.html#Game Rules"> Game Rules </a>
</li> <li> <a href="UT3Mods.html#Heads Up Display (HUD)"> Heads Up Display (HUD) </a>
</li> <li> <a href="UT3Mods.html#Scoreboard"> Scoreboard </a>
</li> <li> <a href="UT3Mods.html#AI"> AI</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#How to Make Custom Content"> How to Make Custom Content</a> <ul>
<li> <a href="UT3Mods.html#Characters"> Characters</a>
</li> <li> <a href="UT3Mods.html#Levels"> Levels</a>
</li> <li> <a href="UT3Mods.html#Pickups and Weapons"> Pickups and Weapons </a>
</li> <li> <a href="UT3Mods.html#Vehicles"> Vehicles</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#A Few Things to Watch Out For"> A Few Things to Watch Out For </a> <ul>
<li> <a href="UT3Mods.html#Accessed Nones"> Accessed Nones</a>
</li> <li> <a href="UT3Mods.html#Iterators"> Iterators </a>
</li> <li> <a href="UT3Mods.html#Tracing"> Tracing </a>
</li> <li> <a href="UT3Mods.html#Replication - Decryption and De-obfuscation"> Replication - Decryption and De-obfuscation</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#Examples"> Examples </a> <ul>
<li> <a href="UT3Mods.html#Mutator"> Mutator</a> <ul>
<li> <a href="UT3Mods.html#Game Rules"> Game Rules</a>
</li> <li> <a href="UT3Mods.html#Overlay"> Overlay</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#GameType"> GameType</a> <ul>
<li> <a href="UT3Mods.html#Game Rules"> Game Rules</a>
</li> <li> <a href="UT3Mods.html#HUD"> HUD</a>
</li> <li> <a href="UT3Mods.html#Scoreboard"> Scoreboard</a>
</li> <li> <a href="UT3Mods.html#AI"> AI</a>
</li></ul>
</li> <li> <a href="UT3Mods.html#Deathmatch Level"> Deathmatch Level</a>
</li> <li> <a href="UT3Mods.html#CTF Level"> CTF Level</a>
</li> <li> <a href="UT3Mods.html#Custom Characters"> Custom Characters</a>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Introduction"></a> Introduction </h2>
<p />
Developing mods for the Unreal engine can be an extremely rewarding task. In the current state of the games industry, there is little better a way for a skilled programmer or aspiring artist to show the world what he or she is capable of. This document is intended to give interested mod authors the information they need to successfully create modifications for Unreal Engine games. It will include technical information as well as pointers on mod development. If you work hard, you can get some fun stuff done through mod authoring.
<p />
<p />
<h2><a name="Some Advice to Start With"></a> Some Advice to Start With </h2>
<p />
When you begin developing a mod you should start small. Don't plan to write a Total Conversion (TC) from the very start. If you set goals that are too hard to reach, you'll get frustrated in the process of working towards them; and you may never be able to bring the vision to life. It is much better to set a series of small goals and work to each one in turn. Start with a simple idea that could be expanded into a larger game. Always work on small, managable chunks that could each be released in their own right. If you do undertake a large project, organize your features into a release schedule. If your game is going to have 5 new weapons, make a release with 2 or 3 while your work on the others. Pace yourself and think about the long term.
<p />
Everyone has ideas. Everybody thinks they have a revolutionary new game concept that no one else has ever thought of. Having cool ideas will rarely get you anywhere in the games industry. You have to be able to implement your ideas or provide some useful skill. This also applies to mod authoring. If you become a skilled or notable mod author, you will find people propositioning you to implement their ideas. Never join a project whose idea man or leader has no obvious development skills. Never join a project that only has a web designer. You have your own ideas. Focus on them carefully and in small chunks and you will be able to develop cool projects.
<p />
Remember that developing a mod doesn't mean much if you never release it. Scale your task list so that you can release something quickly, adding and improving features as your mod matures. If you hold back your mod until everything is perfect, you'll find yourself never releasing anything.
<p />
Once you have your idea, you need to choose what kind of mod type is right for you. After that you can set everything up and begin making your visions a reality.
<p />
<p />
<h2><a name="Setting up a Mod Project"></a> Setting up a Mod Project </h2>
<p />
It's time to get your hands dirty. First, you should understand how an Unreal Engine game is typically installed. After that, you should know where your mod fits in with game, and some of the ways the Unreal Engine treats content - both original and new. Then, depending on your approach, you can start to set up everything and begin creating your mod.
<p />
<h3><a name="Directory Structure"></a> Directory Structure </h3>
<p />
By default, Unreal Tournament 3 will be installed to the following directory:
<pre>
&#60;InstallDrive&#62;:\Program Files\Unreal Tournament 3
</pre>
<p />
Additionally, user settings will be stored for each user:
<pre>
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\
</pre>
<p />
<h3><a name="Running and Testing"></a> Running and Testing </h3>
<p />
The game can be run by clicking the desktop icon, from the Start Menu, or via the following command:
<pre>
UTGame
</pre>
<p />
The game editor can be run from the Start Menu, or via the following command:
<pre>
UTGame editor
</pre>
<p />
<h3><a name="Useful Console Commands"></a> Useful Console Commands </h3>
<p />
<strong>help</strong> - gives information about a given command. Useful parameters include <code><b>list</b></code>.
<p />
<pre>
UTGame help &#91;command]
</pre>
<p />
<strong>run</strong> - runs a commandlet. If you have a commandlet named TestCommandlet, you can use just <code><b>Test</b></code> and the command will append <code><b>Commandlet</b></code>.
<p />
<pre>
UTGame run &#91;commandlet name]
</pre>
<p />
<h3><a name="Packages"></a> Packages </h3>
<p />
Now its time to set up Unreal Tournament to build your project. First things first, you need to understand how UnrealScript uses packages.
<p />
Packages are collections of game resources. The resources can be any of several types of assets: textures, models, animations sounds, music, UI scenes. The package format is the same for all resources and multiple resource types can be mixed in a package. For the sake of sanity, Unreal Tournament splits up packages into resources. The textures directory contains packages with textures, the sounds directory contains packages with sounds and so forth. Even though these packages may contain different types of content, they have have the same file extention (.upk) and they are still the same kind of file.
<p />
Programmers will be working with UnrealScript and dealing with compiled game code package (.u) files. Code packages primarily contain compiled UnrealScript, but may also contain textures and sounds that the code depends on.
<p />
See the <a href="UnrealPackages.html" class="twikiLink">Unreal Packages</a> page for more information.
<p />
<h3><a name="Programming"></a> Programming </h3>
<p />
When getting started you'll need to do a lot of research on your own. You'll only become a solid UnrealScript programmer if you spend time to acquaint yourself with the framework and the code that is available to you. Learn creative ways to solve problems related to your mod design goals and empower yourself to maximize the tools that you have available.
<p />
<h4><a name="UnrealScript"></a><a name="_UnrealScript"></a> UnrealScript </h4>
<p />
UnrealScript is an object-oriented (OO) language. If you aren't familiar with OO, now is a good time to take a detour and read a guide to object oriented programming: <a href="http://www.orangesmoothie.org/tuts/GM-OOtutorial.html" target="_top">http://www.orangesmoothie.org/tuts/GM-OOtutorial.html</a>. This document is fairly old, but still a good resource.
<p />
Since UnrealScript is object-oriented, you won't be editing any of the original source. This may be different from other game engines. In Unreal, you will subclass the classes that shipped with Unreal Tournament, overriding and extending them to suit your needs.
<p />
For a complete reference on UnrealScript, see the <a href="UnrealScriptReference.html" class="twikiLink">UnrealScript Reference</a> page.
<p />
<h4><a name="UnrealScript Source Files"></a><a name="_UnrealScript Source Files"></a> UnrealScript Source Files </h4>
<p />
You can download the latest UnrealScript Source Files here: <a href="http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.5.rar" target="_top">http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.5.rar</a>
<p />
Previous versions: <ul>
<li> <a href="http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.4.rar" target="_top">http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.4.rar</a>
</li> <li> <a href="http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.3.rar" target="_top">http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.3.rar</a>
</li> <li> <a href="http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.2.rar" target="_top">http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.2.rar</a>
</li> <li> <a href="http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.1.rar" target="_top">http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.1.rar</a>
</li> <li> <a href="http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.0.rar" target="_top">http://udn.epicgames.com/Files/UT3/Mods/UT3ScriptSource_1.0.rar</a>
</li></ul>
<p />
Please be aware that as patches are released, script source updates will be made which will match any patch updates. These updates will be made available a few days after the patch is released. Previous versions will be archived.
<p />
UnrealScript source code for your mod project will be placed in the following location:
<pre>
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\Src\YourModName\Classes
</pre>
<p />
<strong>NOTE</strong>: The Src\YourModName\Classes directory structure may need to be created.
<p />
Before compiling UnrealScript source, you must first register your script mod name with the engine by opening UTEditor.ini and adding the following line under the <code>[ModPackages]</code> section:
<pre>
ModPackages&#61;YourModName
</pre>
<p />
The game's UnrealScript compiler can be run via the following command:
<pre>
UTGame make
</pre>
<p />
... or for a full rebuild:
<pre>
UTGame make -full
</pre>
<p />
<strong>NOTE</strong>: Never modify the core UT UnrealScript classes!
<p />
Compiled UnrealScript packages will be placed in the following location:
<pre>
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\Unpublished\CookedPC\Script\YourModName.u
</pre>
<p />
<strong>NOTE</strong>: The Script directory may need to be created.
<p />
A configuration file will be automatically created for the mod package and placed in the following location:
<pre>
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\Config\UTYourModName.ini
</pre>
<p />
Note that the configuration file autogeneration only detects subclasses of UT* classes as those are the only ones that have a bExportMenuData flag to control it. If your mod does not begin with <em>UT</em> prefixed, it will be done for you. If your mod does not have any subclasses of UT* classes, you will have to manually create a configuration file.
<p />
When you open the editor, any mod packages in the UTEditor.ini <code>ModPackages</code> list will automatically be loaded at editor startup, and so any <em>placeable</em> Actor classes will automatically appear in the <a href="ActorsBrowserReference.html" class="twikiLink">Actor Browser</a>. To suppress this behavior, run the editor with the =-nomodautoload flag.
<p />
Remember that you'll probably want to spend a lot of time just pooring over the massive amount of UnrealScript source code for the game. Trace execution paths and look at how the various classes override and interact with each other. It can be very intimidating at first, but with time you'll get more experienced with where things are and what things do. Don't be afraid to go online and ask questions in community mailing lists and forums, either. If you spend the time it takes to learn, you will be rewarded with the ability to take on larger, more difficult projects.
<p />
<h3><a name="Content Creation"></a> Content Creation </h3>
<p />
<h4><a name="Levels"></a> Levels </h4>
<p />
When using the game editor, levels will be saved to the following directory:
<pre>
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\Unpublished\CookedPC\CustomMaps
</pre>
<p />
For your level to be visible in the game menus, it needs to be saved in a subdirectory of CustomMaps. Anything saved directly in the CustomMaps directory itself will be ignored. So, you’ll want create a directory that is appropriate to your mod name.
<p />
Remember when saving a level to do so with the right gametype prefix (e.g. DM-<LevelName>, VCTF-<LevelName>, etc).
<p />
By default, the game looks for custom content in the <em>Published</em> directory. You have two options:
<p /> <ol>
<li> Tell the game to run out of the <em>Unpublished</em> directory by running with =UT3.exe –useunpublished.  This is best for fast turnaround time while developing.
</li> <li> Use the <em>Publish</em> button in the editor; this copies the contents of Unpublished to Published so the game will auto-detect it.
</li></ol>
<p />
The first time you run the game, it will detect the presence of new levels in subdirectories of the <em>CustomMaps</em> folder and automatically generate the per-level configuration (.ini) files for registering the level with the in-game UI. You can edit these to provide level description text, etc.
<p />
If you cook your mod via the Unreal Front End, make sure the ‘Cook Mod’ option is checked.
<p />
<h3><a name="Publishing and Cooking"></a> Publishing and Cooking </h3>
<p />
The <em>CookedPC</em> naming convention may seem confusing but it’s a relatively simple process once everything is set up properly. <em>Cooking</em> bakes out unnecessary content from the map file, creates the shader cache information needed to properly load and run your map, and improves performance and loading times. <em>Publishing</em> sets up the files for distribution and puts everything into the proper directory so that other people can play what you’ve created.
<p />
Regarding the <em>Published</em> and <em>Unpublished</em> behavior: content that is saved in the game editor is written to the <em>Unpublished</em> directory  by default. This is the working directory for mod authors, and can be found here:
<p />
<pre>
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\UnPublished\CookedPC\
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\UnPublished\CookedPC\Script\
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\UnPublished\CookedPC\CustomMaps\
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\UnPublished\CookedPC\CustomChars\
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\UnPublished\CookedPC\Localization\&#60;LANGUAGE&#62;\
</pre>
<p />
The <em>Published</em> directory is located here:
<p />
<pre>
…\Documents and Settings\&#60;UserID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\Published\CookedPC\
</pre>
<p />
Saving a game in the editor should create the <em>UnPublished</em> folder. Publishing a file should create the <em>Published</em> folder. If either of those directories don’t exist, you’ll need to create them manually. When you download a map and want to play it, put it in the Published folder and it will then be recognized by the game and appear in the in menus. Note that files that are not in the proper directory will not be recognized by the game and will not load properly or appear in the menus.
<p />
The game naturally runs content from the <em>Published</em> directory, unless the <code>-useunpublished</code> flag is specified when running up the game. The typical mod workflow will be to iterate development on script and maps and run the game with <code>-useunpublished</code>. When the mod is ready, a final <em>Publish</em> will write cooked content to the <em>Published</em> directory, and these loading-optimised files will be used for distribution. For Scripts and localized text files, they will have to be copied over manually.
<p />
Alternatively, mod authors can run their in-development content without the <code>-useunpublished</code> flag by issuing <em>Publish</em> when content changes are made. In this way, the mod content will be copied uncooked over to the <em>Unpublished</em> directory, where the game will automatically recognize it. As above, it is recommended that a final <em>Publish</em> is done before distributing a mod.
<p />
To summarize, the <code>-useunpublished</code> flag is a mod developer shortcut for not having to continually copy files while working.
<p />
<h3><a name="Localization"></a> Localization </h3>
<p />
A localized text file for your mod package should be created and placed in the following directory:
<pre>
&#60;InstallDrive&#62;:\Documents and Settings\&#60;userID&#62;\My Documents\My Games\Unreal Tournament 3\UTGame\UnPublished\CookedPC\Localization\&#60;LANGUAGE&#62;\YourModName.int
</pre>
<p />
<h3><a name="Distribution"></a> Distribution </h3>
<p />
Previously, mods were packaged up using the Unreal Engine's <code>master</code> commandlet to create mod installer files (.umod for UT and .ut2mod for UT2003 and UT2004). Now mods will simply packaged into a compressed archive using a utility such as <a href="http://www.rarlab.com" target="_top">WinRAR</a>.
<p />
<h3><a name="Naming Conventions"></a> Naming Conventions </h3>
<p />
For consistency and maintainability, it's very wise to establish some naming conventions and other best practices such as coding standards early on in the development of your project. This will keep you and any team members on the same page.
<p />
For programming, we recommend the following naming conventions: <ul>
<li> UTMutator_<MutatorName> - for UT3 Mutator classes
</li> <li> UTGame_<GameTypeName> - for UT3 GameType classes
</li> <li> UTGameRules_<GameTypeName> - for UT3 GameRules classes (used by your Mutator or GameType)
</li> <li> UTMod_<ModName> - for other UT3 mods; also good for the package and associated directory
</li></ul>
<p />
Total Conversions might deviate from this as the name of their project may have nothing to do wth UT, even though it is still considered a UT Mod.
<p />
When naming your package and the associated directory, consider a convention that is consistent with your vision; but not limited to the name of the class file. For example, if you are making a new GameType called <em>Jailbreak</em>, you can name the package and the associated directory UTMod_Jailbreak or just Jailbreak, rather than the name of the core gametype class (most likely UTGame_Jailbreak). If you are creating a collection of mutators, consider naming the package and associated directory UTMod_MyMutators or simply MyMutators.
<p />
<h3><a name="Consoles"></a> Consoles </h3>
<p />
<h4><a name="PlayStation 3 Mod Support"></a><a name="_PlayStation 3 Mod Support"></a> PlayStation 3 Mod Support </h4>
<p />
Please see the <a href="PS3Mods.html" class="twikiLink">PS3 Mods</a> page for more information on making user-created content for the PlayStation 3 console.
<p />
<p />
<h2><a name="The Four Mod Types"></a> The Four Mod Types </h2>
<p />
<h3><a name="Mutators"></a> Mutators </h3>
<p />
Mutators are mini-mods. They have limited functionality as defined by the Mutator class. Mutators should follow certain rules - rules that are established by the GameType. If these rules can't be followed or are too limiting, you should probably work on a GameType mod.
<p />
The first rule is that Mutators should be able to work with any other Mutator - especially the ones that come with the game. If you write a "Vampire" Mutator that allows the player to drain life from an enemy he shoots, the Mutator should work well if combined with one of the Arena mutators or the No Powerups Mutator. This is one of the beneficial features of the Mutator system. They slightly change (or <em>mutate</em>) gameplay, allowing for interesting combinations.
<p />
The second rule is that Mutators should only change gameplay in a slight fashion. Although that's a vague way of putting it, you need to try and restrict your Mutator behavior. Careful Mutator design will increase the chances of your Mutator working with other mods and will decrease your support effort.
<p />
The third rule is that Mutators should share resources with other Mutators. If your Mutator implements the <code>ModifyPlayer</code> function, you need to call <code>NextMutator.ModifyPlayer</code> somewhere inside your version of the function. This ensures that any Mutator on the Mutator list after your mod gets a chance to deal with the function call. Failing to do this is poor programming style and not community-friendly.
<p />
<h3><a name="GameTypes"></a> GameTypes </h3>
<p />
GameTypes are a much larger class of mod. They do everything the Mutator can't and allow you access to a much larger range of functionality. If your idea can't be implemented within a Mutator, you should work on a GameType.
<p />
The drawback of a GameType is that it cannot be mixed with other GameTypes. For example, Capture the Flag is a GameType in Unreal Tournament. It is a wholly different style of gameplay from Deathmatch (another GameType).
<p />
GameTypes are implemented as subclasses of the GameInfo class, specific to the game. There aren't any specific rules for GameTypes, other than some client-server issues that you should be aware of (and that we will discuss later).
<p />
<h3><a name="Total Conversions"></a> Total Conversions </h3>
<p />
Total Conversions (TC) completely bypass the established game classes and start at the engine core. Rather than use game-specific subclasses, TC's are implemented as subclasses of the base engine classes, such as the GameInfo class. If your mod doesn't exist in the realm of the game's universe, or if you want to try something completely different, then a TC is the way to go. Just be aware that you will be doing everything from scratch.
<p />
<h3><a name="Custom Content"></a> Custom Content </h3>
<p />
Depending on the GameType, some mods may require many new elements such as AI, or special Actors that are separate from the game rules themselves. It is possible also to create mods that don't change gameplay through the GameInfo or Mutator classes. These would include Player Plugin Models (PPM), new weapons, or new vehicles.
<p />
Of course, Levels are a great way to create new content without writing any code. You can simply carve out a new level and decorate it using existing content assets that came with the game; or you can create your own textures and models (static meshes), as well!
<p />
For more guidance on designing a multiplayer level, see the <a href="UT3MultiplayerMapTheory.html" class="twikiLink">Multiplayer Map Theory</a> (UT3) page.
<p />
<p />
<h2><a name="How to Make a Mutator"></a> How to Make a Mutator </h2>
<p />
Mutators are a great place to cut your teeth on UnrealScript because you are exposed to a limited, but powerful subset of the engine. As I previosly mentioned, Mutators should only modify the game code in a relatively slight way. This increases the chances your mutator will work well when mixed with other mutators. (For example, you can play FatBoy, InstaGib, No Powerups deathmatch. A mix of 3 mutators).
<p />
Lets look at a very simple Mutator mod:
<p />
<pre>
class ExampleMutator extends Mutator;

defaultproperties
{
}
</pre>
<p />
<h3><a name="Configuration"></a> Configuration </h3>
<p />
By default, a configuration file will be made for your package, with references to your mutator. The following information is relevant:
<p />
<pre>
FriendlyName&#61;Example Mutator
Description&#61;An Example Mutator
</pre>
<p />
Some configuration changes must be made in order to get the new mutator to properly show up in the menus.
<p />
The Instant Action and Multiplayer menus look in all configuration files for classes that are subclasses of UT classes. If you add these lines to your package's localized text file, you'll get an entry called "Example Mutator" in the list of mutators. You will need to provide text in your mod package localized text file, as follows:
<p />
<pre>
;///////////////
; Mutator Names
;///////////////
&#91;ExampleMutator UIDataProvider&#95;Mutator]
FriendlyName&#61;Example Mutator
Description&#61;An Example Mutator.

</pre>
<p />
Some mods can be configured in the game menus, as well. To do so, you have to create a UI Scene and save it in a package, and reference the package via the <code>UIConfig</code> member variable. This can be done in the <code>defaultproperties</code> of the Mutator class.
<p />
Here is an example:
<p />
<pre>
defaultproperties
{
   UIConfigScene&#61;UIScenes&#95;Example.Menus.ExampleMutatorConfig
}
</pre>
<p />
<p />
With a simple Mutator we can take a look at a few of the methods available in Mutator.
<p />
<h3><a name="The Anatomy of Mutator - a First Look"></a> The Anatomy of Mutator - a First Look </h3>
<p />
So now you've had your first exposure to writing a simple UT mod. Clearly this isn't enough to shake the world or get a job in the industry. It's worth taking a closer look at the methods inside the Mutator base class. This will give you a better idea of what you can do with them. It only scratches the surface, however, because you have the power to use a multitude of inherited functions as well as interact with other objects.
<p />
<code>Mutate</code> lets your mutator define new commands that player's can bind to keys. If a player binds <code><b>mutate givehealth</b></code> to a key and then uses that key, every mutator will get a mutate call with a <code>givehealth</code> parameter. Your mutator might look for this string and give the player who sent the message some extra health.
<p />
<code>ModifyLogin</code>
<p />
<code>ModifyPlayer</code> is called by the game whenever a Pawn is respawned. It gives you a chance to modify the Pawn's variables or perform some game logic on the Pawn. Remember to call <code>Super.ModifyPlayer()</code> if you override this function. That will call the parent class' version of the function.
<p />
<code>AlwaysKeep</code> allows you to interdict objects that the game wants to add to the world. You can replace objects on the fly with other objects as they appear. The Unreal Tournament Arena mutators are a great example of this. They take all the weapons in a game and replace them with one other weapon. If you are adding a new weapon to the game, you might want to add an Arena mutator for it.
<p />
<code>IsRelevant</code> is called when the game wants to add an object to the world. You can override it with special code and return true, to keep the object, or false, to reject it. If you say false, the object will be destroyed.
<p />
<code>CheckRelevance</code>
<p />
<code>CheckReplacement</code>
<p />
<h3><a name="Taking It Further: Game Rules"></a> Taking It Further: Game Rules </h3>
<p />
At the core, the Mutator class traps certain events that can be modified for tweaking. Of course, some limitations can be experienced right away, such as scoring kills or affecting damage. This is where Game Rules come in. Each GameInfo game subclass has a list of Game Rules called GameRulesModifiers. You can create a subclass of GameRules that can tweak the way certain game events are handled.
<p />
<code>FindPlayerStart</code>
<p />
<code>HandleRestartGame</code>
<p />
<code>CheckEndGame</code>
<p />
<code>OverridePickupQuery</code>
<p />
<code>PreventDeath</code>
<p />
<code>ScoreObjective</code>
<p />
<code>ScoreKill</code>
<p />
<code>NetDamage</code>
<p />
Looking even futher, your mutator could even draw information to the HUD. While there is more flexibility for doing this from a GameType, the limited functionality should be enough for a Mutator. Simply create a replicated Actor subclass that adds itself to the <code>PostRenderedActors</code> array in the UTHud class.
<p />
With this information, you should be able to make a lot of changes with very few classes. The best way to learn how to maximize the power of mutators is to read the code in the mutators that ship with UT.
<p />
<p />
<h2><a name="Introduction to _GameTypes"></a> Introduction to GameTypes </h2>
<p />
Mutators can do some cool stuff. They are pretty easy to understand and they can do a lot of things by interacting with certain game events and rules. They can be mixed and matched to get even cooler effects; but they are NOT very powerful. If you want to make a new type of game (such as a Jailbreak or Rocket Arena style mod), you can't do it with mutators. You need to have complete control over the game rules.  That's where the GameInfo series of classes come into play.
<p />
GameInfo is a class located in Engine. It is created by the game engine and is the core of the game play rules. Unreal Tournament makes use of a series of GameInfo subclasses located in the UTGame package. The UTGame class contains code that is universal to all of Unreal Tournament's game types. UTDeathmatch contains the code for running a normal deathmatch. UTTeamGame contains code for team deathmatch as well as general team management code. UTCTFGame, which is a subclass of UTTeamGame, implements that particular gametype.
<p />
The first step in writing your new game type is to determine which GameInfo class to subclass. If you are writing a team game, you'll want to subclass UTTeamGame. If you are writing a game without teams, use UTDeathmatch. If you are writing a game that departs significantly from any previously styled game type (but exist within the Unreal Tournament game), use UTGame. Subclassing is very beneficial: you immediately inherit all of the code in your parent classes which you can then extend or override to achieve your design goals.
<p />
Of course, if you are writing a Total Conversion (TC) - which will depart completely from the UT game - you will want to subclass GameInfo.
<p />
Lets look at a very simple Game Type mod:
<p />
<pre>
class ExampleGameType extends UTDeathMatch;
defaultproperties
{
   Acronym&#61;&#34;EX&#34;
   MapPrefixes&#91;0]&#61;&#34;EX&#34;
   Description&#61;&#34;Example GameType&#34;
}
</pre>
<p />
The above code, when saved in a file called ExampleGameType.uc is the shell of a new GameType. The only difference here is that we've changed the description to "Example GameType." This new name will be reflected in many places: the Practice Session selection window, the Scoreboard header, and so forth. If you play this game, it'll play just like any other Deathmatch Game, as no new behavior has been implemented.
<p />
<h3><a name="Configuration"></a> Configuration </h3>
<p />
Similar to Mutators, a configuration file will be made for your package, with references to your game type. The following information is relevant:
<p />
<pre>
FriendlyName&#61;Example GameType
Description&#61;An Example GameType
</pre>
<p />
Like Mutators, some configuration changes must be made in order to get the new game type to properly show up in the menus. You will need to provide text in your mod package localized text file, as follows:
<p />
<pre>
;///////////////
; Game Modes
;///////////////
&#91;ExampleGameType]
Description&#61;An Example GameType.
GameName&#61;ExampleGameType
EndOfMatchRulesTemplateStr&#95;Scoring&#61;First one wins!
EndOfMatchRulesTemplateStr&#95;Time&#61;Most wins!


;///////////////
; GameType Names
;///////////////
&#91;ExampleGameType UIDataProvider&#95;GameModeInfo]
FriendlyName&#61;Example GameType
Description&#61;An Example GameType.

</pre>
<p />
The Instant Action and start Multiplayer menus look in all localized text files for packages with section names that relate to the classes that have localized strings. If you add these lines to your package's localized text file, you'll get an entry called "Example GameType" in the list of games. The name is taken from the FriendlyName variable of your GameInfo class. The Description line gives your gametype a line of descriptive text on the menus. You probably don't need to worry about that right now.
<p />
With a simple GameType we can take a look at a few of the methods available in GameInfo.
<p />
<h3><a name="A first look at _GameInfo"></a> A first look at GameInfo </h3>
<p />
The Engine's GameInfo class is the definition of the basic game logic. At the top of the file you'll see a long list of variable declarations.  Many of these variables have comments that describe their purpose. Below the variable declarations come the functions (or methods) that do the work.
<p />
The first thing to look at is the <code>Timer</code> function. In GameInfo it's pretty short, but in UTDeathmatch its very long. <code>Timer</code> is a special UnrealScript event. If you call the function <code>SetTimer(int Time, bool bLoop)</code> you can set up a repeating timer on your Actor. The Time parameter describes when the Timer function should be called. The bLoop parameter describes whether or not Timer should be called in a loop after the first call. <strong>All UTGame classes use a Timer loop of one second.</strong> This means that the Timer function is called every second. You can use Timer for events that have to happen at certain times. By declaring watch variables that count up seconds, you can perform events at any time up to a second's resolution. UTDeathmatch uses this to check and see if the TimeLimit has been hit in a game.
<p />
Another important time function to get to know is <code>Tick</code>. Tick isn't used in GameInfo, but any Actor can use it. The declaration for <code>Tick</code> is: <code>Tick(float DeltaTime)</code>. <code>Tick</code> is called on every Actor in the game each frame. DeltaTime contains the amount of time that has passed since the last Tick. Using <code>Tick</code>, you can perform behavior that has to be done at less-than-a-second resolution. You must be careful not to perform CPU heavy behavior in <code>Tick</code>, because it is called so often.
<p />
Further down in GameInfo is the <code>Login</code> function. This function is called by the engine whenever a player logs in to the game. GameInfo's version of login does important setup stuff like assigning the player a name, a skin, a mesh and so forth. It also spawns the intial teleport effect and finds a spawn point to stick the player at. After <code>Login</code> is <code>Logout</code>. It is called whenever a player leaves the game.  You can use logout to clean up after a player exits.
<p />
Another interesting function in GameInfo is <code>AddDefaultInventory</code>. This function assigns a player his initial weapon and equipment. In UTDeathmatch, the player is given an ImpactHammer and an Enforcer. You can use AddDefaultInventory to add custom inventory to players that join your mod (for example, you might want to give them a grenade and some money).
<p />
The <code>FindPlayerStart</code> method searches the actors in a level for NavigationPoints suitable for spawning. The PlayerStart Actor that a Level Designer adds to their level is one such location. In UTTeamGame, <code>FindPlayerStart</code> spawns players and bots depending on their Team. It checks the Team of each PlayerStart and the Team of the Pawn to be spawned. You can use <code>FindPlayerStart</code> to write custom spawn code (for example, you might want to spawn Opposing Forces in one location and Friendlies in another).
<p />
The <code>RestartPlayer</code> method is called whenever a player respawns. The basic GameInfo version calls <code>FindPlayerStart</code> to find a starting spot, moves the player to that spot and spawns a teleport effect. It also restores the players health, sets the player's collision, and gives the player his default inventory.
<p />
The <code>Killed</code> method is very useful. It is called whenever a player kills another player. It looks at the cirumstances of the death (whether a player suicided or killed successfully) and the type of damage and prints a message. Finally, it calls <code>ScoreKill</code>.
<p />
<code>ScoreKill</code> awards points for a kill. UTDeathmatch assigns a frag for a successful kill and subtracts one for a suicide. UTTeamGame also adds a point to the TeamInfo of the Killer's team, or subtracts one in the case of a suicide.
<p />
<code>DiscardInventory</code> is called whenever a player dies or is removed from the game. <code>DiscardInventory</code> goes through a Pawn's inventory, tossing out weapons and destroying others as appropriate. You might override this function if you wanted to toss out a backpack or a trap.
<p />
Finally, the <code>EndGame</code> function is called with a reason whenever the game ends. You might want to perform special logging or clean up here.
<p />
So that's a quick look at the more important GameInfo functions. The advanced GameInfo classes like UTDeathmatch add important new behavior for controlling bots and single player games, as well as refining the GameInfo methods into specific rules.
<p />
Again, the best way to learn how to make the most of your GameType is to read the code in the gametypes that ship with UT.
<p />
<p />
<h3><a name="Game Rules"></a> Game Rules </h3>
<p />
<h3><a name="Heads Up Display (HUD)"></a> Heads Up Display (HUD) </h3>
<p />
<h3><a name="Scoreboard"></a> Scoreboard </h3>
<p />
<h3><a name="AI"></a> AI </h3>
<p />
<p />
<h2><a name="How to Make Custom Content"></a> How to Make Custom Content </h2>
<p />
<h3><a name="Characters"></a> Characters </h3>
<p />
See the <a href="UT3CustomCharacters.html" class="twikiLink">Creating Custom Characters for UT3</a> page for more information.
<p />
<h3><a name="Levels"></a> Levels </h3>
<p />
Again, some configuration changes must be made in order to get the new level to properly show up in the menus. You will need to provide text in your level's localized text file, as follows:
<p />
<pre>
&#91;DM-Example UIDataProvider&#95;MapInfo]
FriendlyName&#61;&#60;Strings:UTGameUI.FriendlyMapNames.DM-Example&#62;
NumPlayers&#61;4 to 8 players

</pre>
<p />
<h3><a name="Pickups and Weapons"></a> Pickups and Weapons </h3>
<p />
Coming soon.
<p />
<h3><a name="Vehicles"></a> Vehicles </h3>
<p />
Coming soon.
<p />
<p />
<h2><a name="A Few Things to Watch Out For"></a> A Few Things to Watch Out For </h2>
<p />
Here is some information on some major "gotchas" that mod developers have run into when writing mods for Unreal Tournament. A lot of this information may not be relevant to you until you have more experience with the engine. Learning a new game technology can be a very cool experience, but also a very frustrating one. Here are some pointers to ease your exploration.
<p />
As a rule, always think about the performance implications of code you write.
<p />
<h3><a name="Accessed Nones"></a> Accessed Nones </h3>
<p />
Sooner or later these will start showing up in your log files. UnrealScript treats Accessed Nones as warnings but you should treat them as errors. Accessed Nones are easy to fix and always signal that something is wrong with your code. If you are familiar with C++ or Java, it's easy to figure out what an Accessed None is. For those who aren't so familiar, here is a brief explanation...
<p />
UnrealScript is an object oriented-programming language. When you write a program in UnrealScript, you define a set of behavior for these objects to obey and how they will interact in the game. An object has a set of properties: member variables and member functions. In order to access an object property, you need a reference to that object.
<p />
Here is some sample code:
<p />
<pre>
class ExampleInfo extends Info;

var PlayerReplicationInfo PlayerInfo;

function PlayerReplicationInfo GetPlayerInfo()
{
   return PlayerInfo;
}
</pre>
<p />
Here we have a simple object called ExampleInfo that is a subclass of Info. It has two properties: a variable called PlayerInfo and a function called GetPlayerInfo(). You might want to interact with this object from inside your mod. Let's say you have a reference to a ExampleInfo object inside your mod and you want to get some information from inside the PlayerInfo property. You might write code that looks like this:
class MyMod expands TournamentGameInfo;
<p />
<pre>
function string GetPlayerName()
{
   local ExampleInfo TheInfo;
   local string PlayerName;

   TheInfo &#61; GetMyObject();
   PlayerName &#61; TheInfo.PlayerInfo.PlayerName;
   Log(&#34;The player&#39;s name is&#34; &#64;PlayerName);
}
</pre>
<p />
In this example we call a function called GetMyObject() to get a reference to an ExampleInfo. We then access that reference to resolve PlayerInfo (TheInfo.PlayerInfo) and then access the PlayerInfo reference to resolve PlayerName (PlayerInfo.PlayerName). But what if there isn't a TheInfo available, or a bug in GetMyObject() causes it to fail to return an ExampleInfo? In that case, the function would return <code><b>None</b></code>. None is an empty reference - a lot like a NULL pointer in C++.
<p />
If, in our example, GetMyObject() returns <code>None</code>, then the variable TheInfo is assigned None. In the next line, we try and access TheInfo to resolve the PlayerInfo reference. But TheInfo is None - it doesn't refer to anything. It cannot be accessed, so the Unreal engine logs a warning saying the code broke:
<p />
<pre>
Accessed None in ExampleMod.GetPlayerName!
</pre>
<p />
Its very easy to avoid buggy code like this. Just add some checks to your code and define special behavior in the case of a mistake:
<p />
<pre>
class ExampleGameType extends UTGame;

function string GetPlayerName()
{
   local ExampleInfo TheInfo;
   local string PlayerName;

   TheInfo &#61; GetMyObject();
   if ((TheInfo !&#61; None) &#38;&#38; (TheInfo.PlayerInfo !&#61; None))
   {
      PlayerName &#61; TheInfo.PlayerInfo.PlayerName;
   }
   else
   {
      PlayerName &#61; &#34;Unknown&#34;;
   }

   Log(&#34;The player&#39;s name is&#34; &#64;PlayerName);
}
</pre>
<p />
Now we are checking to see if TheInfo is <code>None</code> and then checking to see if the PlayerInfo reference is <code>None</code>. <code>if</code> statements in UnrealScript use short circuit logic. That is, <code>if</code> statements are evaluated from left to right. As soon as the code encounters a statement that negates the <code>If</code>, it stops evaluating. That means that if TheInfo is <code>None</code>, the code will never evaluate the following statement:
<p />
<pre>
(TheInfo.PlayerInfo !&#61; None)
</pre>
<p />
It knows that it doesn't matter what the rest of the statement says, the first part is false so the entire statement is false.
<p />
Accessed Nones can be especially dangerous in time critical functions like <code>Timer()</code> and <code>Tick()</code>. It takes a lot of time to write out an error message to the log and if your code is dumping 3000 error messages a second it can really kill performance (not to mention disk space).
<p />
<h3><a name="Iterators"></a> Iterators </h3>
<p />
UnrealScript implements a very useful language feature called Iterators. An iterator is a datatype that encapsulates a list. (UnrealScript only supports list iterators, future language versions may support user-defined iterators). You can get an iterator and loop on it, performing an operation on every object inside the iterator. Here is an example:
<p />
<pre>
local Ammo A;

foreach AllActors(class&#39;Ammo&#39;, A)
{
   A.AmmoAmount &#61; 999;
}
</pre>
<p />
In this example we are using the <code>AllActors()</code> function to get an Actor List iterator. We then use the <code>foreach</code> iterator loop to perform some behavior on every object the AllActors function returns. <code>AllActors()</code> takes the class of the type of Actor you want and a variable to put it in. <code>AllActors()</code> will search through every Actor in the current game for the objects you want. Here we are saying <em>set the AmmoAmount of every Actor in the game to 999</em>.
<p />
This sounds great, but consider the side effects: we are searching through a list of hundreds of Actors for a small few. This isn't exactly a fast operation.
<p />
Iterators can be extremely useful if used carefully. Because they tend to be slow, you'll want to avoid performing iterations faster than a couple times a second. There is almost never a reason to perform an <code>AllActors()</code> iteration inside of <code>Tick()</code> or inside of other loops. Use your best judgement.
<p />
The most common type of <code>AllActors()</code> search you'll work with will probably be a search for all of the PlayerReplicationInfo Actors. PlayerReplicationInfo contains important information about Players that the server sends to each client. It allows each client to have an idea of the status of other playes without sending too much information. Its used to show the scores on the scoreboard and other common things.
<p />
Usually, there will only be a handful of PlayerReplicationInfo Actors in the global Actor List. It doesn't really make sense to do a time consuming search for so few results. In order to simplify this common iteration, there is a PRI array defined in the GameReplicationInfo class. Every tenth of a second, the PRIArray is updated to contain the current set of PlayerReplicationInfos. You can then do your operation of the PRIArray without having to do an <code>AllActors()</code> call.
<p />
Other iterators are also available. Look in the Actor class definition for information. They do exactly what they sound like: <code>TouchingActors()</code> returns touching actors, <code>RadiusActors()</code> returns all the actors in the given radius, etc. Intelligent use of these iterators will help you keep your code fast.
<p />
<h3><a name="Tracing"></a> Tracing </h3>
<p />
Because the Unreal engine does not use a potentially visible set, if you want to find something in the world in a spacial sense, you'll need to perform a trace. Most of the time you'll have a good idea of where you are tracing, you just want to know whats on the other end of the line. Other times, you'll use a series of traces to get an idea of what surrounds the object in question.
<p />
First advice is to avoid traces wherever possible. Think very hard about what you are using the trace for and try to come up with an alternate way of doing it. Traces are expensive operations that can introduce subtle slowdowns into your mod. You might have a player doing a couple traces every tick and during your testing everything is fine. What you don't realize, is that as soon as you are playing online with 15 or more people online, those traces start to add up.
<p />
If you have to perform traces, limit their size. Shorter traces are faster than long traces. If you are designing a new Shotgun weapon for UT, for example, you might want to perform 12 traces when the weapon is fired to figure out the scatter of the gun. 12 traces is perfectly reasonable; it's not like the player is going to be firing his shotgun 30 times a second. However, those 12 traces could get expensive if your mod uses large open levels. Its highly unlikely your shotgun is going to be very useful as a long-range weapon, so you might as well cut off its range at a certain point. It saves the engine from having to trace from one end of the map to the other in the worst case.
<p />
Using traces is ultimately a judgment call. It really only becomes a big problem when you perform a lot of traces in a single frame. Nonetheless, it's definitely something to keep your eyes on.
<p />
<h3><a name="Replication - Decryption and De-obfuscation"></a> Replication - Decryption and De-obfuscation </h3>
<p />
Understanding replication is one of the most difficult aspects of writing a successful Unreal Engine game mod, but its utterly necessary if you plan on having any multipler gameplay at all. Most documentation is very highly technical in nature, can can be difficult to digest. Some of the basics will be covered here; and over time you will gain a deeper understanding and appreciation of replication.
<p />
<code>simulated</code> functions are called on both the client and the server; but only if called from a simulated function. As soon as a function call breaks the simulation chain, the simulation stops. Be very aware of what you are simulating and what you are doing in simulated functions. Never add a function modifier like <code>simulated</code> just because you saw it in the Unreal source code somewhere else. Understand why you are adding it, know what it does. You can't possibly expect to write quality mods if you don't know what your code is doing.
<p />
Because a simulated function is called on both the client and the server you have to be particularly aware of what data you are accessing. Some object references that are available on the server might not be available on the client. For example, every Actor has a reference to the current level as well as the current world that it belongs to. Inside the world reference is a reference to the current game. You might write code that looks like this:
<p />
<pre>
simulated function bool CheckTeamGame()
{
   return World.Game.bTeamGame
}
</pre>
<p />
This is a simple simulated function that returns true or false depending on whether or not the current game is a Team Game. It does this by checking the bTeamGame property of the current level's GameInfo reference. But there is something wrong...
<p />
The Game property of the Level reference is only valid on the server. The client doesn't know anything about the server's game object so the client will log an Accessed None.
<p />
If you open up the script for LevelInfo, you can find a section that looks like this:
<p />
<pre>
//-----------------------------------------------------------------------------
// Network replication.

replication
{
   reliable if( Role&#61;&#61;ROLE&#95;Authority )
      Pauser, TimeDilation, bNoCheating, bAllowFOV;
}
</pre>
<p />
The replication block is a special statement that tells the Unreal engine how to deal with the properties of this object. Take a closer look.
<p />
First, we have a replication condition: <code>reliable if( Role =</code> ROLE_Authority)=. The first part of the condition will either be reliable or unreliable. If it says reliable, that means the engine will make sure the replicated information gets to each client safely. Because of the way the UDP protocol works, its possible for packets to get lost in transmission. Unreliable replication won't check to see if the packet arrived safely. Reliable replication has a slightly higher network overhead than unreliable replication.
<p />
The second part of the condition <code>(Role =</code> ROLE_Authority)= tells the engine when to send the data. In this situation we are going to send the data whenever the current LevelInfo object is an Authority. To really decypher what this means you have to understand the specific role of the object in question. With a LevelInfo, the server is going to maintain the authoritative version of the object. The server tells the clients how the level is behaving, not the other way around. For our example replication block, this means that the data will be sent from the server to each client.
<p />
The other common type of condition is <code>(Role &lt; ROLE_Authority)</code>. This means that the engine should send the data when the current object is not an authority. Or rather, that the client should tell the server the correct information.
<p />
Finally, we see four variables listed beneath the condition. These are the variables that the statement applies to. In this situation, we have a statement saying, "If we are the server and the client has an outdated copy of these variables, then send to the client new information about Pauser, TimeDilation, bNoCheating, and bAllowFOV. Always make sure the data arrives safely."
<p />
The replication statement doesn't cover the rest of the variables in the LevelInfo. This can mean two things. Either the information is filled in by the client in C++ (in the case of TimeSeconds) or the information is never updated on the client and is completely unreliable (in the case of Game).
<p />
You don't have access to the C++ source code, but you can make a couple inferences about an object's properties to help you determine whether or not a class has non-replicated properties that are filled in natively. Look at the class declaration for LevelInfo:
<p />
<pre>
class LevelInfo extends ZoneInfo
  native;
</pre>
<p />
<code>native</code> means <em>This object is declared in C++ and in UnrealScript</em>. Native classes probably have behavior in C++ that you can't see. Only a few special classes are native - typically for performance reasons.
<p />
Finally, watch out for classes that say <code>nativereplication</code> in the class declaration. This means that the <code>replication</code> block inside UnrealScript doesn't do anything and that replication is entirely defined in C++. Some network heavy objects use native replication to help with network performance.
<p />
So now you have an idea of how to avoid problems with replicated variables and simulated functions. Now lets look at replicated functions.
<p />
A replicated function is a function that is called from the client or the server but executed on the other side. An example of a replicated function is the <code>Say</code> function. When you hit the T key to talk to everyone in a game, you are actually executing the Say function along with whatever you said. The client takes the function and its parameters and sends it to the server for execution. The server then broadcasts your message to all the other clients.
<p />
Replicated functions are very easy to use if you remember one thing: they can't return a value. A replicated function is transmitted over the network to the other side...that takes time (approximately equal to your ping). If replicated functions were blocking (i.e.: they waited for a return value) network communication would halt.
<p />
This is obvious for anyone who thinks about it, but when you are working on your mod you might not think about it. Replicated functions return immediately. Use them to trigger behavior on the client (like special effects) or send a message (a weapon fire message to the server).
<p />
Finally, replicated functions are restricted to only a few classes. A function call on an Actor can only be replicated to the player who owns that Actor. A function call can only be replicated to one actor (the player who owns it); they cannot be multicast. You might use them with weapons or inventory items you make (where the function is replicated to the player who owns the item).
<p />
That should help you with the basics of replication.
<p />
<p />
<h2><a name="Examples"></a> Examples </h2>
<p />
<h3><a name="Mutator"></a> Mutator </h3>
<p />
<h4><a name="Game Rules"></a> Game Rules </h4>
<p />
<h4><a name="Overlay"></a> Overlay </h4>
<p />
<h3><a name="GameType"></a> GameType </h3>
<p />
<h4><a name="Game Rules"></a> Game Rules </h4>
<p />
<h4><a name="HUD"></a> HUD </h4>
<p />
<h4><a name="Scoreboard"></a> Scoreboard </h4>
<p />
<h4><a name="AI"></a> AI </h4>
<p />
<h3><a name="Deathmatch Level"></a> Deathmatch Level </h3>
<p />
<h3><a name="CTF Level"></a> CTF Level </h3>
<p />
<h3><a name="Custom Characters"></a> Custom Characters </h3>
<p />
To assist in getting started with creating custom characters for Unreal Tournament 3, the following character skeletons are available for reference: <ul>
<li> <a href="rsrc/Three/UT3Mods/UT3_Male.max" target="_top">UT3_Male.max</a> (3D Studio Max 9)
</li> <li> <a href="rsrc/Three/UT3Mods/UT3_Female.max" target="_top">UT3_Female.max</a> (3D Studio Max 9)
</li> <li> <a href="rsrc/Three/UT3Mods/UT3_Krall.max" target="_top">UT3_Krall.max</a> (3D Studio Max 9)
</li> <li> <a href="rsrc/Three/UT3Mods/UT3_Corrupt.max" target="_top">UT3_Corrupt.max</a> (3D Studio Max 2009)
</li></ul>
<p />
Additionally, the following first person skeleton is available for reference: <ul>
<li> <a href="rsrc/Three/UT3Mods/SK_WP_1P_Arm_Bones.max" target="_top">SK_WP_1P_Arm_Bones.max</a>
</li></ul>
<p />
<strong>NOTE</strong>: <em>A Biped rig is included with some of the skeletons. The Biped rig is just an additional skeleton that's easier to animate. When an animation is done, we bake the animation onto the original skeleton, delete the biped, and export the animation.</em>
<p />
Please see the <a href="UT3CustomCharacters.html" class="twikiLink">Custom Characters</a> page for more information.
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
