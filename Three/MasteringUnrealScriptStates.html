<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | MasteringUnrealScriptStates    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">MasteringUnrealScriptStates  </b></div>
<div id="tooltext">
<a href="MasteringUnrealScriptStatesJP.html" class="twikiLink">日本語訳</a><br><a href="MasteringUnrealScriptStatesCH.html" class="twikiLink">中国翻译</a><br><a href="MasteringUnrealScriptStatesKR.html" class="twikiLink">한국어</a><br>

<!-- Three/MasteringUnrealScriptStates -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div class="twikiToc"> <ul>
<li> <a href="MasteringUnrealScriptStates.html#CHAPTER 11 – STATES">CHAPTER 11 – STATES</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#11.1 WHAT IS STATE PROGRAMMING">11.1 WHAT IS STATE PROGRAMMING</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#11.2 STATES IN UNREAL ENGINE 3">11.2 STATES IN UNREAL ENGINE 3</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#THE AUTO KEYWORD">THE AUTO KEYWORD</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#THE IGNORES KEYWORD">THE IGNORES KEYWORD</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#THE SUPER  GLOBAL KEYWORDS">THE SUPER &amp; GLOBAL KEYWORDS</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#11.3 - BASIC STATE TRANSITIONS">11.3 - BASIC STATE TRANSITIONS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#GOTOSTATE">GOTOSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#GOTO">GOTO</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#STATE EVENTS">STATE EVENTS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#BEGINSTATE">BEGINSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#ENDSTATE">ENDSTATE</a>
</li></ul>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.1 – STATE TRIGGER, PART I: FUNCTION OVERRIDING">TUTORIAL 11.1 – STATE TRIGGER, PART I: FUNCTION OVERRIDING</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#11.4 - STATE INHERITANCE">11.4 - STATE INHERITANCE</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#EXTENDING STATES">EXTENDING STATES</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.2 – STATE TRIGGER, PART II: STATE INHERITANCE">TUTORIAL 11.2 – STATE TRIGGER, PART II: STATE INHERITANCE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.3 – STATE TRIGGER, PART III: AUTO STATE">TUTORIAL 11.3 – STATE TRIGGER, PART III: AUTO STATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#11.5 - STATE CODE">11.5 - STATE CODE</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#LABELS">LABELS</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#LATENT FUNCTIONS">LATENT FUNCTIONS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#ACTOR LATENT FUNCTIONS">ACTOR LATENT FUNCTIONS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#Sleep">Sleep</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#FinishAnim">FinishAnim</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#CONTROLLER LATENT FUNCTIONS">CONTROLLER LATENT FUNCTIONS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#MoveTo">MoveTo</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#MoveToward">MoveToward</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#FinishRotation">FinishRotation</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#WaitForLanding">WaitForLanding</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#UTBOT LATENT FUNCTIONS">UTBOT LATENT FUNCTIONS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#WaitToSeeEnemy">WaitToSeeEnemy</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#LatentWhatToDoNext">LatentWhatToDoNext</a>
</li></ul>
</li></ul>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#11.6 - STATE STACKING">11.6 - STATE STACKING</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#PUSHSTATE  POPSTATE">PUSHSTATE &amp; POPSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#STATE STACKING EVENTS">STATE STACKING EVENTS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#PUSHEDSTATE">PUSHEDSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#POPPEDSTATE">POPPEDSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#PAUSEDSTATE">PAUSEDSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#CONTINUEDSTATE">CONTINUEDSTATE</a>
</li></ul>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#11.7 - STATE-RELATED FUNCTIONS">11.7 - STATE-RELATED FUNCTIONS</a> <ul>
<li> <a href="MasteringUnrealScriptStates.html#ISINSTATE">ISINSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#GETSTATENAME">GETSTATENAME</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#ISCHILDSTATE">ISCHILDSTATE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#DUMPSTATESTACK">DUMPSTATESTACK</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.4 – STATE TRIGGER, PART IV: STATE STACKING">TUTORIAL 11.4 – STATE TRIGGER, PART IV: STATE STACKING</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.5 – TURRET, PART I: MU_AUTOTURRET CLASS AND STRUCT DECLARATION">TUTORIAL 11.5 – TURRET, PART I: MU_AUTOTURRET CLASS AND STRUCT DECLARATION</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.6 – TURRET, PART II: CLASS VARIABLE DECLARATIONS">TUTORIAL 11.6 – TURRET, PART II: CLASS VARIABLE DECLARATIONS</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.7 – TURRET, PART III: EDITABLE VARIABLE DECLARATIONS">TUTORIAL 11.7 – TURRET, PART III: EDITABLE VARIABLE DECLARATIONS</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.8 – TURRET, PART IV: DEFAULT PROPERTIES">TUTORIAL 11.8 – TURRET, PART IV: DEFAULT PROPERTIES</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.9 – TURRET, PART V: POSTBEGINPLAY() EVENT">TUTORIAL 11.9 – TURRET, PART V: POSTBEGINPLAY() EVENT</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.10 – TURRET, PART VI: ROTATION FUNCTIONS">TUTORIAL 11.10 – TURRET, PART VI: ROTATION FUNCTIONS</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.11 – TURRET, PART VII: STATE DECLARATIONS">TUTORIAL 11.11 – TURRET, PART VII: STATE DECLARATIONS</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.12 – TURRET, PART VIII: GLOBAL TAKEDAMAGE() FUNCTION">TUTORIAL 11.12 – TURRET, PART VIII: GLOBAL TAKEDAMAGE() FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.13 – TURRET, PART IX: GLOBAL TICK() FUNCTION">TUTORIAL 11.13 – TURRET, PART IX: GLOBAL TICK() FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.14 – TURRET, PART X: IDLE STATE BODY">TUTORIAL 11.14 – TURRET, PART X: IDLE STATE BODY</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.15 – TURRET, PART XI: ALERT STATE BODY PART I">TUTORIAL 11.15 – TURRET, PART XI: ALERT STATE BODY PART I</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.16 – TURRET, PART XII: ALERT STATE BODY PART II">TUTORIAL 11.16 – TURRET, PART XII: ALERT STATE BODY PART II</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.17 – TURRET, PART XIII: DEFEND STATE BODY PART I">TUTORIAL 11.17 – TURRET, PART XIII: DEFEND STATE BODY PART I</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.18 – TURRET, PART XIV: DEFEND STATE BODY PART II">TUTORIAL 11.18 – TURRET, PART XIV: DEFEND STATE BODY PART II</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.19 – TURRET, PART XV: DEFEND STATE BODY PART III">TUTORIAL 11.19 – TURRET, PART XV: DEFEND STATE BODY PART III</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.20 – TURRET, PART XVI: DEAD STATE BODY">TUTORIAL 11.20 – TURRET, PART XVI: DEAD STATE BODY</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.21 TURRET, PART XVII – COMPILING AND TESTING">TUTORIAL 11.21 TURRET, PART XVII – COMPILING AND TESTING</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.22 – UTBOT_PELLET CLASS SETUP">TUTORIAL 11.22 – UTBOT_PELLET CLASS SETUP</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.23 – PELLETCOLLECTING STATE, PART I: FINDNEWGOAL() FUNCTION">TUTORIAL 11.23 – PELLETCOLLECTING STATE, PART I: FINDNEWGOAL() FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.24 – PELLETCOLLECTING STATE, PART II: HASREACHEDGOAL() FUNCTION">TUTORIAL 11.24 – PELLETCOLLECTING STATE, PART II: HASREACHEDGOAL() FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.25 – PELLETCOLLECTING STATE CODE">TUTORIAL 11.25 – PELLETCOLLECTING STATE CODE</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.26 – PELLETHUNTING STATE, PART I: FINDNEWGOAL() FUNCTION">TUTORIAL 11.26 – PELLETHUNTING STATE, PART I: FINDNEWGOAL() FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.27 – PELLETHUNTING STATE, PART II: HASREACHEDGAOL() FUNCTION">TUTORIAL 11.27 – PELLETHUNTING STATE, PART II: HASREACHEDGAOL() FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.28 – EXECUTEWHATTODONEXT() AND WANDERORCAMP() FUNCTION OVERRIDES">TUTORIAL 11.28 – EXECUTEWHATTODONEXT() AND WANDERORCAMP() FUNCTION OVERRIDES</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.29 – PELLET CLASSES BOT SETUP">TUTORIAL 11.29 – PELLET CLASSES BOT SETUP</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#TUTORIAL 11.30 – PELLET BOT COMPILING AND TESTING">TUTORIAL 11.30 – PELLET BOT COMPILING AND TESTING</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#11.8 - SUMMARY">11.8 - SUMMARY</a>
</li> <li> <a href="MasteringUnrealScriptStates.html#SUPPLEMENTAL FILES">SUPPLEMENTAL FILES</a>
</li></ul>
</li></ul>
</div>
<p />
<h1><a name="CHAPTER 11 – STATES"></a> CHAPTER 11 – STATES </h1>
<p />
When programmers set about programming large and complex systems they usually tend to create and model their programs into states. States allow the programmer to focus on the functionality within that state and keep related functionality together. Unlike many other languages, UnrealScript has a mechanism for partitioning your code instead states built right in. This makes it really easy to program functionality like having our character look around randomly if he is in an idle state and not have to worry about that code getting run if he’s in another.
<p />
<h2><a name="11.1 WHAT IS STATE PROGRAMMING"></a> 11.1 WHAT IS STATE PROGRAMMING </h2>
<p />
State programming, also referred to as state machine programming, is a way to logically break out the functionality of a program into more manageable pieces. The idea is that by separating out the complex functionality of an entity in to what is referred to as a state, it will make programming the entity easier.
<p />
A state can be defined in any way you want to; it’s all about making your life easier as the programmer. For example, if we were creating a pong game, we might create the following states to make programming the game easier:
<p /> <ul>
<li> Title Screen
</li> <li> High Scores Screen
</li> <li> Game Playing Screen
</li> <li> Game Paused Screen
</li> <li> Game Over Screen
</li></ul>
<p />
With the states defined above, we can be sure the input we are getting from the user is handled properly and it makes it much more difficult to handle the input incorrectly. For example, it would be much more difficult to start moving the paddle when the game is paused if we have a separate state to handle the user’s input.
<p />
Another vital part of state programming is the transitions. This is how you get from one state to another. Again, this can be done in multiple different ways, but it is important to understand the relationships between states and how you can get from one to the other.
<p />
Continuing our example above, a possible transition from the Game Playing Screen to the Game Paused Screen would be the user pressing the Start button on a controller.
<p />
A well-designed state machine will have well defined states and transitions. When we are thinking about states, it might be helpful to create a diagram. Typically a state machine diagram looks something like the following:
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_001.jpg"/><br/> <strong><font color=blue>Figure 11.1 – State machine diagram for the example pong game.</font></strong>
<p />
Looking at the diagram, the circle areas are the states and the arrows represent the transitions between the states. In our example above we have a single transition from Title Screen to Game Playing Screen but there is no transition from the Game Playing Screen to the Title Screen as the arrow only travels one direction.
<p />
In the example above we used states to represent different states in a game, but we can also use states to describe the status of a player or of an AI opponent. An example of some of the states that an AI enemy might could be:
<p /> <ul>
<li> Searching
</li> <li> Attacking
</li> <li> Fleeing
</li></ul>
<p />
<h2><a name="11.2 STATES IN UNREAL ENGINE 3"></a> 11.2 STATES IN UNREAL ENGINE 3 </h2>
<p />
Unlike many programming languages, UnrealScript provides a built-in way of defining states inside of classes. This makes it possible for each class to have multiple different modes of behavior efficiently and easily.  States are declared in a very similar fashion to functions only the State keyword is used in place of the Function keyword.  First the State keyword is used followed by the name of the state. Curly braces are then used to contain the code belonging to the new state. Let’s take a look at what a state might look like:
<p />
<font face=consolas>
<pre>
state() GamePlaying
{
      function UpdatePaddle()
   {
      // Handle the user’s input for moving the paddle.
   }
}

state() GamePaused
{
       function UpdatePaddle()
   {
      // This should do nothing.
       }
}
</pre>
</font>
<p />
In the code sample we defined two states: GamePlaying and GamePaused. Inside that state you can see that we have two functions with the same name: UpdatePaddle. Normally it is not allowed to have two functions both with the same name and same argument list. However, this is the beauty of state programming in UnrealScript.
<p />
When functions are defined in UnrealScript within state blocks, the Unreal engine determines the state the current object is and only executes the code for that state. This can make our lives a little easier as we don’t need to handle the states within the actual function itself. For example, if we wanted to do this without using UnrealScript’s built-in state mechanism, we’d have to do something like this:
<p />
<font face=consolas>
<pre>
function UpdatePaddle()
{
       if (GameState &#61;&#61; GamePlaying)
   {
      // Handle the game playing code.
       }
   else if (GameState &#61;&#61; GamePaused)
   {
           // Handle the game paused code.
       }
}
</pre>
</font>
<p />
Now that doesn’t look that bad, but of course I didn’t actually provide any of the implementation details and this example is only using two states. Imagine if you had five states that you could be in and each required some fairly sophisticated implementation details. It then becomes fairly obvious that handling states in the manner above can get pretty confusing, at best.
<p />
<h3><a name="THE AUTO KEYWORD"></a> THE AUTO KEYWORD </h3>
<p />
The auto state is the state that is initial state of the object. Another way to think about it is that this is the state that the object automatically starts in. The engine automatically calls the SetInitialState() event of all Actors within the world and this event contains the functionality for setting the Actor’s state to whichever state is declared as the auto state. To mark a state as auto, you prefix the state declaration with the auto keyword, like this:
<p />
<font face=consolas>
<pre>
auto state MyState
{
   // You state code goes here.
}
</pre>
</font>
<p />
<h3><a name="THE IGNORES KEYWORD"></a> THE IGNORES KEYWORD </h3>
<p />
Sometimes you want to ignore some of the state functions in a state. For example, if an actor is fleeing you might not want to handle and code any of the code to look for a target. We could override the function and leave the function body empty, but that is tedious. Fortunately UnrealScript provides us an easy solution to the problem: the ignores keyword. By simply using an ignore statement beginning with the ignores keyword followed by a list of function to be ignored separated by commas, the actor can be told not to bother executing those functions while in the current state.
<p />
An example of this can be seen below.
<p />
<font face=consolas>
<pre>
state Fleeing
{
   ignores SearchForTarget, SomeOtherFunction;
}
</pre>
</font>
<p />
<h3><a name="THE SUPER  GLOBAL KEYWORDS"></a> THE SUPER &amp; GLOBAL KEYWORDS </h3>
<p />
You’ve seen and made use of the Super keyword many times up to this point in order to call a version of an overridden function in the parent class or some specific class up the hierarchy.  This keyword works very much the same when used within a function inside of a stat. it will execute the version of that function contained within the same state in the parent class or any class up the hierarchy if specified. If no version of that function can be found in that state in the parent class, the global version of the function in the parent class will be executed instead. If no version of the function exists in the state or globally in the parent class, obviously an error will occur when compiling the scripts.
<p />
The Global keyword works in a similar fashion, only it allows the version of a function overridden in a state to have its version not within any state called. In other words, the version of a function belonging to the class can be called from within a state which also overrides that function. This can be very useful in promoting code reuse in cases where a general version of a function can be defined in the class and more specific version of that function can be redefined within states belonging to that class, while still making use of the code within the generalized function without having to include that code within the function defined in the state.
<p />
Take a look at an example of the Global keyword being used:
<p />
<font face=consolas>
<pre>
class StateClass extends Actor;

event Touch()
{
   `log(“Someone is near.”);
}

state Damaging
{
   event Touch()
   {
      Global.Touch();
      `log(“Let’s damage them!”);
   }
}

state Healing
{
   event Touch()
   {
      Global.Touch();
      `log(“Let’s heal them!”);
   }
}
</pre>
</font>
<p />
In the example above, when the actor is not within any state, the global Touch() event gets called resulting in the phrase “Someone is near.” being output to the log file. What happens when the actor is in the Damaging state, though? In this case, the phrase “Someone is near.” is still output because of the use of the Global keyword to call the Touch() event defined in the class. Then the phrase “Let’s damage them!” is output as well. In a similar fashion, when in the Healing state, the phrase “Someone is near.” is output by the global Touch() event and then the phrase “Let’s heal them!” is output by the state’s Touch() event.
<p />
Obviously in this particular example, there wasn’t much saved since the entire global Touch() event is only a single line, but it should be evident that the use of the Global keyword could be extremely useful when the global version of a function contains many lines of code that are to be used within one or more states in addition to code specific to each of those states.
<p />
Note: The use of the Global keyword results in the most derived version of the global function being executed. This means if the function is not overridden in the current class, the engine looks up the hierarchy until the last time the function was defined within one of the parent classes.
<p />
<h2><a name="11.3 - BASIC STATE TRANSITIONS"></a> 11.3 - BASIC STATE TRANSITIONS </h2>
<p />
In order for states to be of any real use, there must be a way to transition, or change, from one state to the next. In some cases, transitions also occur within the same state from one label to another. These basic transitions are performed with one of the following functions.
<p />
<h3><a name="GOTOSTATE"></a> GOTOSTATE </h3>
<p />
<font face=consolas>
<pre>
GotoState( optional name NewState, optional name Label, optional bool bForceEvents, optional bool bKeepStack )
</pre>
</font>
<p />
This function changes the state the object is in to the given state and starts executing code at the given LabelName; if no LabelName is given, the Begin label is assumed. If this function is called from the object’s state code, then the state switch happens immediately. If it is called from one of the objects other functions, the switch won’t happen until the execution switches back to the state code. When calling this function causes the actor to transition to a different state than the one the actor is currently in, the BeginState() event of the new state and EndState() event of the current state are always executed. These events are covered in the State Events section below.
<p />
The bForceEvents parameter specifies whether the BeginState() and EndState() events should be executed even when transitioning to the same state the Actor is already in.
<p />
The bKeepStack parameter specifies whether the current state stack should be prevented from being cleared or flushed. The state stack will be discussed in greater detail later in the chapter.
<p />
<h3><a name="GOTO"></a> GOTO </h3>
<p />
<font face=consolas>
<pre>
Goto(‘LabelName’)
</pre>
</font>
<p />
This function is used to jump to a new label within the state and continue with the state code execution from that point.
<p />
<font face=consolas>
<pre>
Goto()
</pre>
</font>
<p />
When called with no LabelName parameter, Goto() stops the state code execution. Execution of code is resumed when the state changes or a new label is transitioned to.
<p />
<h3><a name="STATE EVENTS"></a> STATE EVENTS </h3>
<p />
State events are events, or functions, that get executed automatically by the engine when transitioning from one state to another, or within the same state in certain circumstances.
<p />
<h4><a name="BEGINSTATE"></a> BEGINSTATE </h4>
<p />
This event is executed from within the GotoState() function when the NewState parameter of the function is a state other than the current state of the actor or the bForceEvents parameter is True. This event is executed immediately upon transitioning to the new state before any state code is executed.
<p />
<font face=consolas>
<pre>
BeginState( Name PreviousStateName )
</pre>
</font>
<p />
The PreviousStateName parameter holds the name of the state the actor was in previously before the current transition took place. This allows specific actions to be performed based on which state the actor is transitioning from.
<p />
<h4><a name="ENDSTATE"></a> ENDSTATE </h4>
<p />
This event is executed from within the GotoState() function when the NewState parameter of the function is a state other than the current state of the actor or the bForceEvents parameter is True. This event is executed before transitioning to the new state.
<p />
<font face=consolas>
<pre>
EndState( Name NewStateName )
</pre>
</font>
<p />
The NewStateName parameter holds the name of the state the actor is transitioning to after the transition takes place. This allows specific actions to be performed depending on which state the actor is transitioning to.
<p />
<h2><a name="TUTORIAL 11.1 – STATE TRIGGER, PART I: FUNCTION OVERRIDING"></a> TUTORIAL 11.1 – STATE TRIGGER, PART I: FUNCTION OVERRIDING </h2>
<p />
This series of tutorials walks through the creation of a very simple actor that behaves as a trigger. Through the use of states, the behavior of the actor when triggered is changed. This example is meant as a way to demonstrate the purpose and use of states on a very basic level. To begin with, the class is declared and a single state is implemented.
<p />
<strong>1.</strong>	Open ConTEXt and create a new file using the UnrealScript highlighter.
<p />
<strong>2.</strong>	Declare the new class name MU_StateTrigger extending from the base Actor class. Make this class placeable as well so it can be placed within a map in UnrealEd.
<p />
<font face=consolas>
<pre>
class MU&#95;StateTrigger extends Actor
   placeable;
</pre>
</font>
<p />
<strong>3.</strong>	This class does not have any variable declarations, but the defaultproperties block is used to give the actor a mesh and collision geometry. There is a lot to add in this block, but we won’t spend much time on it as we are borrowing from the Healer actor created in tutorials found earlier in this book. Create the defaultproperties lock now.
<p />
<font face=consolas>
<pre>
defaultproperties
{
}
</pre>
</font>
<p />
For the most part, the defaultproperties block consists of the creation of StaticMeshComponent sub-objects for the visual aspect of the actor and a CylinderComponent sub-object for the collision of the actor. The section below can be copied and pasted from the Healer.uc script.
<p />
<font face=consolas>
<pre>
Begin Object Class&#61;StaticMeshComponent Name&#61;StaticMeshComponent0
          StaticMesh&#61;StaticMesh&#39;LT&#95;Deco.SM.Mesh.S&#95;LT&#95;Deco&#95;SM&#95;PodiumScorpion&#39;
          Translation&#61;(X&#61;0.000000,Y&#61;0.000000,Z&#61;-40.000000)
          Scale3D&#61;(X&#61;0.250000,Y&#61;0.250000,Z&#61;0.125000)
          CollideActors&#61;false
          bAllowApproximateOcclusion&#61;True
          bForceDirectLightMap&#61;True
          bCastDynamicShadow&#61;False
          LightingChannels&#61;(Dynamic&#61;False,Static&#61;True)
End Object
Components.Add(StaticMeshComponent0)

Begin Object Class&#61;StaticMeshComponent Name&#61;StaticMeshComponent1
          StaticMesh&#61;StaticMesh&#39;LT&#95;Deco.SM.Mesh.S&#95;LT&#95;Walls&#95;SM&#95;FlexRing&#39;
          Translation&#61;(X&#61;0.000000,Y&#61;0.000000,Z&#61;-40.000000)
          Scale3D&#61;(X&#61;0.500000,Y&#61;0.500000,Z&#61;0.500000)
          CollideActors&#61;false
          bAllowApproximateOcclusion&#61;True
          bForceDirectLightMap&#61;True
          bCastDynamicShadow&#61;False
          LightingChannels&#61;(Dynamic&#61;False,Static&#61;True)
End Object
Components.Add(StaticMeshComponent1)

Begin Object Class&#61;StaticMeshComponent Name&#61;StaticMeshComponent2
          StaticMesh&#61;StaticMesh&#39;LT&#95;Light.SM.Mesh.S&#95;LT&#95;Light&#95;SM&#95;LightCone01&#39;
          Translation&#61;(X&#61;0.000000,Y&#61;0.000000,Z&#61;-40.000000)
          Scale3D&#61;(X&#61;2.000000,Y&#61;2.000000,Z&#61;-1.000000)
          CollideActors&#61;false
          bAllowApproximateOcclusion&#61;True
          bAcceptsLights&#61;False
          CastShadow&#61;False
End Object
Components.Add(StaticMeshComponent2)

Begin Object Class&#61;CylinderComponent NAME&#61;CollisionCylinder
   CollideActors&#61;true
   CollisionRadius&#61;+0040.000000
   CollisionHeight&#61;+0040.000000
End Object
CollisionComponent&#61;CollisionCylinder
Components.Add(CollisionCylinder)

bCollideActors&#61;true
bStatic&#61;true
bMovable&#61;False
bEdShouldSnap&#61;True
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_002.jpg"/><br/> <strong><font color=blue>Figure 11.2 – The subobjects create the state trigger’s visual appearance.</font></strong>
<p />
<strong>4.</strong>	The Touch() event is overridden in this class. Initially, the actor will not be within any state and this Touch() event will be called whenever another actor collides with this actor. Declare the Touch() event.
<p />
<font face=consolas>
<pre>
event Touch(Actor Other, PrimitiveComponent OtherComp, vector HitLocation, vector HitNormal)
{
}
</pre>
</font>
<p />
The Broadcast() function of the Gameinfo class is used within this event to output a message to the screen when a collision is detected.
<p />
<font face=consolas>
<pre>
WorldInfo.Game.Broadcast(self,&#34;This is the StateTigger class.&#34;);
</pre>
</font>
<p />
In addition, the actor is sent to a new state, the Dialog state which is declared in the next step.
<p />
<font face=consolas>
<pre>
GotoState(&#39;Dialog&#39;);
</pre>
</font>
<p />
<strong>5.</strong>	The Dialog state is the first state declared within the MU_StateTrigger class.
<p />
<font face=consolas>
<pre>
state Dialog
{
}
</pre>
</font>
<p />
<strong>6.</strong>	The Touch() event is overridden inside the body of the Dialog state. This will cause this specific version of the Touch() event to be executed when the actor is within the Dialog state and a collision is detected with another actor.
<p />
<font face=consolas>
<pre>
event Touch(Actor Other, PrimitiveComponent OtherComp, vector HitLocation, vector HitNormal)
{
}
</pre>
</font>
<p />
As in the earlier declaration of the Touch() event, this version will use the Broadcast() function to output a message to the screen, only this time the message will be different.
<p />
<font face=consolas>
<pre>
WorldInfo.Game.Broadcast(self,&#34;This is the base dialog state&#39;s output&#34;);
</pre>
</font>
<p />
<strong>7.</strong>	Save the script in the MasteringUnrealScript\Classes directory with the name MU_StateTrigger.uc and compile the scripts. Fix any syntax errors which may be present.
<p />
<strong>8.</strong>	Open UnrealEd and the DM-CH_11_Trigger.ut3 map. This is a simple two-room map that you have seen several times throughout the book.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_003.jpg"/><br/> <strong><font color=blue>Figure 11.3 The DM-CH_11_Trigger map</font></strong>
<p />
<strong>9.</strong>	Open the Actor Browser and select the MU_StateTrigger class. Right-click in the viewport and choose Add MU_StateTrigger Here to place an instance of the new actor.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_004.jpg"/><br/> <strong><font color=blue>Figure 11.4 – The MU_StateTrigger actor is added to the map.</font></strong>
<p />
<strong>10.</strong>	Right-click on the floor of one of the rooms and choose Play From Here to test the map. Run over the trigger actor to initiate the Touch() event and observe the message displayed to the screen. It should be the message from the original Touch() event.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_005.jpg"/><br/> <strong><font color=blue>Figure 11.5 – The Touch() event message appears.</font></strong>
<p />
Now run over the trigger actor again. This time the message from the Dialog state’s Touch() event should be displayed instead.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_006.jpg"/><br/> <strong><font color=blue>Figure 11.6 – The Dialog state’s Touch() event message is now displayed.</font></strong>
<p />
This is because the actor is now in the Dialog state and its version of the Touch() event is taking precedence over any other versions present within the class.
<p />
<strong>11.</strong>	Save this map with a new name so it can be used in subsequent tutorials.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="11.4 - STATE INHERITANCE"></a> 11.4 - STATE INHERITANCE </h2>
<p />
Inheritance works just like you’d expect it to for states. When you derive from a class that has a state, you get all of its states, state functions, and labels in your class so you can override them if you’d like or keep the base class’s implementation.
<p />
Let’s take a look at an example:
<p />
<font face=consolas>
<pre>
class Fish extends Actor;

state Eating
{
       function Swim()
   {
           Log(“Swimming in place while I eat.”);
       }
Begin:
       Log(“Just a fish in my Eating state.”;
}

class Shark extends Fish;

state Eating
{
       function Swim()
   {
           Log(“Swimming fast to catch up with my food.”);
       }
}

class Dolphin extends Fish;

state Eating
{
Begin:
       Log(“Just a dolphin in my Eating state.”);
}
</pre>
</font>
<p />
In our example above we have a Fish, Shark, and Dolphin class defined. Both the Shark and the Dolphin derive from the Fish class and each override a different portion of the base implementation; the Shark class overrides the Eat function and the Dolphin class overrides the Begin label.
<p />
<h3><a name="EXTENDING STATES"></a> EXTENDING STATES </h3>
<p />
It is also possible to extend states in the current class, as long as the state is not overriding a state in the derived class. This can be really useful when you have a set of states that all have common functionality. For example, you might have some common state code that happens while an actor is moving but then you want certain functionality to be specific to when the actor is walking versus when the actor is running. Let’s look at an example:
<p />
<font face=consolas>
<pre>
state Moving
{
       // Code common to all types of movement.
}

state Running extends Moving
{
       // Running specific code.
}

state Walking extends Moving
{
       // Walking specific code.
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 11.2 – STATE TRIGGER, PART II: STATE INHERITANCE"></a> TUTORIAL 11.2 – STATE TRIGGER, PART II: STATE INHERITANCE </h2>
<p />
This tutorial sees the addition of the BeginState() and EndState() events to the Dialog state as well as the creation of the Greeting state which extends the base Dialog state in order to show how state inheritance works.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_StateTrigger.uc script.
<p />
<strong>2.</strong>	After the Touch() event in the Dialog state’s body, declare the BeginState() event with its one Name parameter called PreviousStateName.
<p />
<font face=consolas>
<pre>
event BeginState(Name PreviousStateName)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Inside the BeginState() event, use the Broadcast() function once again to display a message to the screen. This message will display the last state the actor was in before it was placed into the current state.
<p />
<font face=consolas>
<pre>
WorldInfo.Game.Broadcast(self,&#34;Exiting the&#34;&#64;PreviousStateName&#64;&#34;State&#34;);
</pre>
</font>
<p />
<strong>4.</strong>	Next, declare the EndState() event with its Name parameter NextStateName.
<p />
<font face=consolas>
<pre>
event EndState(Name NextStateName)
{
}
</pre>
</font>
<p />
<strong>5.</strong>	A similar call to the Broacast() function is made within this event.
<p />
<font face=consolas>
<pre>
WorldInfo.Game.Broadcast(self,&#34;Entering the&#34;&#64;NextStateName&#64;&#34;State&#34;);
</pre>
</font>
<p />
<strong>6.</strong>	Below the Dialog state, declare a new state named Greeting and extend this new state from the Dialog state.
<p />
<font face=consolas>
<pre>
state Greeting extends Dialog
{
}
</pre>
</font>
<p />
This state, without declaring any functions or events in its body, already contains the Touch(), BeginState(), and EndState() events identical to those declared within the Dialog state.
<p />
<strong>7.</strong>	The Touch() event is overridden within the Greeting state to output and entirely new message to the screen when a collision is detected while the actor is within this state.
<p />
<font face=consolas>
<pre>
event Touch(Actor Other, PrimitiveComponent OtherComp, vector HitLocation, vector HitNormal)
{
   WorldInfo.Game.Broadcast(self,&#34;Hello and welcome to the states example&#34;);
}
</pre>
</font>
<p />
<strong>8.</strong>	Back in the Touch() event of the Dialog state, add a call to the GotoState() function to place the actor into the Greeting state when that event is executed.
<p />
<font face=consolas>
<pre>
GotoState(&#39;Greeting&#39;);
</pre>
</font>
<p />
<strong>9.</strong>	Save the script and compile the scripts, fixing any errors which are present.
<p />
<strong>10.</strong>	Open UnrealEd and the map containing the MU_StateTrigger actor created in the previous tutorial.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_007.jpg"/><br/> <strong><font color=blue>Figure 11.7 – The map containing the MU_StateTrigger actor.</font></strong>
<p />
<strong>11.</strong>	Right-click on the floor of one of the rooms and choose Play From Here to test the map. Run over the trigger actor to see the original message of the class’s main Touch() event. Notice that the message from the BeginState() event of the Dialog state is displayed as well.
<p />
Note: Because the actor was not in any state to initially, the sate name referenced by the PreviousStateName parameter of the BeginState() event is None.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_008.jpg"/><br/> <strong><font color=blue>Figure 11.8 – Two separate messages are now displayed.</font></strong>
<p />
<strong>12.</strong>	Run over the trigger actor once more to cause the Dialog state’s Touch() event to be executed displaying the new message to the screen. You should also notice that the messages from the EndState() event of the Dialog state as well as the BeginState() event of the Greeting state.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_009.jpg"/><br/> <strong><font color=blue>Figure 11.9 – All three messages are displayed this time.</font></strong>
<p />
<strong>13.</strong>	Finally, run over the trigger actor once more. The message from the Touch() event of the Greeting state should now be displayed on the screen.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_010.jpg"/><br/> <strong><font color=blue>Figure 11.10 – The Greeting state’s Touch() event message is displayed.</font></strong>
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.3 – STATE TRIGGER, PART III: AUTO STATE"></a> TUTORIAL 11.3 – STATE TRIGGER, PART III: AUTO STATE </h2>
<p />
The use of the Auto keyword when declaring a state causes the actor to be placed in that state initially when the match begins. The Dialog state will be set as the MU_StateTrigger’s default state in this tutorial. Also, Two additional states will be added to further drive home the concept of state inheritance,
<p />
<strong>1.</strong>	Open ConTEXT and the MU_StateTrigger.uc script.
<p />
<strong>2.</strong>	Add the Auto keyword to the declaration of the Dialog state to force the actor into this state when the game begins.
<p />
<font face=consolas>
<pre>
auto state Dialog
{
   …
   //code removed for brevity
   …
}
</pre>
</font>
<p />
<strong>3.</strong>	Declare a new state named Inquisitor which extends from Greeting this time.
<p />
<font face=consolas>
<pre>
state Inquisitor extends Greeting
{
}
</pre>
</font>
<p />
<strong>4.</strong>	Next declare another new state named Goodbye which extends from the Inquisitor state just declared.
<p />
<font face=consolas>
<pre>
state GoodBye extends Inquisitor
{
}
</pre>
</font>
<p />
<strong>5.</strong>	Now, add a call to the GotoState() function in the Touch() event of the Greeting state to place the actor into the Inquisitor state.
<p />
<font face=consolas>
<pre>
GotoState(&#39;Inquisitor&#39;);
</pre>
</font>
<p />
<strong>6.</strong>	Copy the Touch() ebent from the Greeting state and paste it into the Inquisitor state, changing the message in the Broadcast() function call and the state name in the GotoState() function call as shown below.
<p />
<font face=consolas>
<pre>
event Touch(Actor Other, PrimitiveComponent OtherComp, vector HitLocation, vector HitNormal)
{
   WorldInfo.Game.Broadcast(self,&#34;Are you learning a great deal about UnrealScript?&#34;);
   GotoState(&#39;Goodbye&#39;);
}
</pre>
</font>
<p />
<strong>7.</strong>	Paste the Touch() event into the Goodbye state as well and make the changes to the message and state name for this state’s version of the function like so.
<p />
<font face=consolas>
<pre>
event Touch(Actor Other, PrimitiveComponent OtherComp, vector HitLocation, vector HitNormal)
{
   WorldInfo.Game.Broadcast(self,&#34;Thanks and have a nice day!&#34;);
   GotoState(&#39;Greeting&#39;);
}
</pre>
</font>
<p />
<strong>8.</strong>	Save the script and compile the scripts, fixing any errors which are present.
<p />
<strong>9.</strong>	Open UnrealEd and the map containing the MU_StateTrigger actor used in the previous tutorial. Right-click on the floor of one of the rooms and choose Play From Here to test the map.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_011.jpg"/><br/> <strong><font color=blue>Figure 11.11 – Test the map using the Play From Here functionality.</font></strong>
<p />
<strong>10.</strong>	Run over the trigger actor. A message should appear, but this time it should be the message from the Dialog state’s Touch() event instead of the main Touch() event of the class since the actor was placed into the Dialog state by default because of the use of the Auto keyword when declaring that state. Of course, the BeginState() and EndState() messages will also be displayed for the Greeting state and Dialog state, respectively.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_012.jpg"/><br/> <strong><font color=blue>Figure 11.12 – The Dialog state’s Touch() event message is displayed initially.</font></strong>
<p />
<strong>11.</strong>	Continue running over the trigger to see the rest of the messages. The actor should loop between the Greeting, Inquisitor, and Goodbye states continuously now, showing the messages of each state.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="11.5 - STATE CODE"></a> 11.5 - STATE CODE </h2>
<p />
States are essentially made up of two parts: functions and state code. State code is code that gets executed upon a transition of some kind, usually from one state to another, but also within the same state in some cases. This code is not located within any function, but simply within the state itself and following a label of some sort.
<p />
<h3><a name="LABELS"></a> LABELS </h3>
<p />
Labels are used to designate a specific location within state code at which to begin executing that code. Labels can have any valid name, usually consisting solely of characters, but when using state code one label is special and that is the “Begin” label. This particular label is the default label used to start the execution of the state code. Take a look at the example below.
<p />
<font face=consolas>
<pre>
auto state MyState
{
       function MyFunc()
   {
           // Does something...
       }
Begin:
    Log(“MyState’s Begin label is being executed.”);
    Sleep(5.0);
    goto(‘MyLabel’);
MyLabel:
    Log(“MyState’s MyLabel label is being executed.”);
    Sleep(5.0);
    goto(‘Begin’);
}
</pre>
</font>
<p />
<h3><a name="LATENT FUNCTIONS"></a> LATENT FUNCTIONS </h3>
<p />
In the above example, as soon as the object gets into MyState, it will start executing the code in the Begin label which will log a message, sleep for five seconds, go to the MyLabel label, log a message, sleep for five seconds, and then start the process all over. This will continue to happen as long as the object is in the MyState state.
<p />
You might be wondering what is happening while the state is sleeping. That’s a good question because normally the code that is executing is blocking, that is, it must complete all of its execution before any other code can run. Well, there are certain functions in UnrealScript that are called latent functions. Simply put, these functions allow other code to be executed (i.e. code in other states and the rest of the game) but stop the next code in its current execution path from being run.
<p />
When working with latent functions there are really only a few things you need to remember:
<p />
<strong>1.</strong>	The function will return after some amount of time and then your state code will continue to execute
<p />
<strong>2.</strong>	Latent functions can only be used within state code
<p />
<strong>3.</strong>	You cannot call latent functions from within the body of a function
<p />
<h4><a name="ACTOR LATENT FUNCTIONS"></a> ACTOR LATENT FUNCTIONS </h4>
<p />
The Actor class contains a couple very general latent functions that can be used in the state code of any class extending from the Actor class.
<p />
<h5><a name="Sleep"></a> Sleep </h5>
<p />
This function causes state code to pause execution for a specified amount of time. Once that period of time is up, the state code resumes execution directly after the Sleep() function call.
<p />
<font face=consolas>
<pre>
Sleep( float Seconds )
</pre>
</font>
<p />
Seconds is the number of seconds the state code should pause for.
<p />
<h5><a name="FinishAnim"></a> FinishAnim </h5>
<p />
This function will cause the execution of state code to pause until the current animation playing on the AnimNodeSequence passed to the function finishes.
<p />
<font face=consolas>
<pre>
FinishAnim( AnimNodeSequence SeqNode )
</pre>
</font>
<p />
The SeqNode parameter is the animation node within the AnimTree associated with the actor that the animation is playing on.
<p />
<h4><a name="CONTROLLER LATENT FUNCTIONS"></a> CONTROLLER LATENT FUNCTIONS </h4>
<p />
The Controller class contains several latent functions mostly pertaining to path finding and navigation.
<p />
<h5><a name="MoveTo"></a> MoveTo </h5>
<p />
This function causes the Pawn controlled by the Controller to move to a specific location in the world.
<p />
<font face=consolas>
<pre>
MoveTo(vector NewDestination, optional Actor ViewFocus, optional bool bShouldWalk &#61; (Pawn !&#61; None) ? Pawn.bIsWalking : false)
</pre>
</font>
<p />
NewDestination is the location within the world the Pawn should move to.
<p />
ViewFcous is an Actor which the Pawn should face. It’s rotation will be updated to ensure the Pawn always faces the ViewFocus.
<p />
The bShouldWalk parameter specifies whether the Pawn should walk or run to the new location.
<p />
<h5><a name="MoveToward"></a> MoveToward </h5>
<p />
This function is similar to the MoveTo function except this one causes the Pawn being controlled by the Controller to move toward a specific Actor instead of a location.
<p />
<font face=consolas>
<pre>
MoveToward(Actor NewTarget, optional Actor ViewFocus, optional float DestinationOffset, optional bool bUseStrafing, optional bool bShouldWalk &#61; (Pawn !&#61; None) ? Pawn.bIsWalking : false)
</pre>
</font>
<p />
NewTarget is the Actor the Pawn should move toward.
<p />
ViewFcous is an Actor which the Pawn should face. It’s rotation will be updated to ensure the Pawn always faces the ViewFocus.
<p />
DestinationOffset allows a relative offset to the location of the NewTarget to be specified causing the Pawn to move to a location near the Newtarget, but not the exact location.
<p />
The bUseStrafing parameter specifies whether the Pawn is allowed to strafe while moving to the new destination.
<p />
The bShouldWalk parameter specifies whether the Pawn should walk or run to the new location.
<p />
<h5><a name="FinishRotation"></a> FinishRotation </h5>
<p />
This function pauses the execution of state code until the rotation of the Pawn controlled by the Controller matches the rotation specified by the DesiredRotation property of the Pawn.
<p />
<font face=consolas>
<pre>
FinishRotation()
</pre>
</font>
<p />
<h5><a name="WaitForLanding"></a> WaitForLanding </h5>
<p />
This function pauses the execution of state code until the Pawn controlled by the Controller has landed when in the PHYS_Falling physics type.
<p />
<font face=consolas>
<pre>
WaitForLanding(optional float waitDuration)
</pre>
</font>
<p />
The waitDuration parameter is the number of maximum seconds to wait for the Pawn to land. If the Pawn does not land by the time this duration expires, the LongFall() event is executed.
<p />
<h4><a name="UTBOT LATENT FUNCTIONS"></a> UTBOT LATENT FUNCTIONS </h4>
<p />
The UTBot class has two latent function which are useful in the creation of new AI behaviors.
<p />
<h5><a name="WaitToSeeEnemy"></a> WaitToSeeEnemy </h5>
<p />
This function causes the execution of state code to pause until the Pawn being controlled is looking directly at its enemy, but only if the enemy is visible to the Pawn.
<p />
<font face=consolas>
<pre>
WaitToSeeEnemy()
</pre>
</font>
<p />
<h5><a name="LatentWhatToDoNext"></a> LatentWhatToDoNext </h5>
<p />
This function is used to call the WhatToDoNext() function which contains the decision making functionality of the AI entity. Using the latent version causes the call to be made when the appropriate time has passed, i.e. on the next tick. This keeps the possibility of a race condition from occurring and allows time for the actions of the AI entity to be carried out.
<p />
<font face=consolas>
<pre>
LatentWhatToDoNext()
</pre>
</font>
<p />
<h2><a name="11.6 - STATE STACKING"></a> 11.6 - STATE STACKING </h2>
<p />
We’ve already seen that we can use the GotoState function to transition between one state to another. When this happens, the state is changed and there is no way to get back to the previous state and for most circumstances, this is exactly what we want. For example, when changing from an EngagingEnemy to a RunningLikeACoward state, we don’t want to switch back to the previous state. For those times that we do want to be able to stop our current state and jump to another and then come back there are the PushState and the PopState functions.
<p />
<h3><a name="PUSHSTATE  POPSTATE"></a> PUSHSTATE &amp; POPSTATE </h3>
<p />
The PushState function is nearly identical to the GotoState function. When you call it you pass it the state you want to transition to and optionally the label you wish to start execution from. This function gets its name because it places the new state onto the top of the stack pushing the other states down the stack.
<p />
The PopState function takes no parameters and returns you back to the previously executing state.
<p />
Let’s take a look at a simple example:
<p />
<font face=consolas>
<pre>
state Looking
{
       function Look()
   {
           PushState(‘Peeking’);
           // Do something else interesting...
       }
Begin:
    PushState(‘Peeking’, ‘Begin’);
    // Do yet another interesting thing...
}

state Peeking
{
Begin:
    Log(“Nothing to see here.”);
    PopState();
}
</pre>
</font>
<p />
There are some interesting implementation details you need to be aware of when using PushState:
<p /> <ul>
<li> When PushState is called from within state code, the call is treated as a latent function. So in the example above, when PushState is called in the Begin label, the code after that call would not execute until the state was popped back to.
</li> <li> When PushState is called from within a function, the call is not treated as a latent function. So in the example above, when PushState is called from within the Look function, the code after that call would be executed immediately as PushState is only treated as a latent function from within state code.
</li> <li> You cannot push the same state on the stack multiple times; this will fail.
</li></ul>
<p />
<h3><a name="STATE STACKING EVENTS"></a> STATE STACKING EVENTS </h3>
<p />
These vents are similar to the BeginState() and EndState() events previously discussed, but replace the functionality of those events when using the PushState() and PopState() functions to transition between states. These events, unlike the BeginState() and EndState() events, have no parameters.
<p />
<h4><a name="PUSHEDSTATE"></a> PUSHEDSTATE </h4>
<p />
This event is executed immediately within the pushed state when transitioning to a new state by way of the PushState() function.
<p />
<h4><a name="POPPEDSTATE"></a> POPPEDSTATE </h4>
<p />
This event is executed immediately within the popped state when transitioning back to the previous state by way of the PopState() function.
<p />
<h4><a name="PAUSEDSTATE"></a> PAUSEDSTATE </h4>
<p />
This event is executed within the state being paused when transitioning to a new state by way of the PuchState() function.
<p />
<h4><a name="CONTINUEDSTATE"></a> CONTINUEDSTATE </h4>
<p />
This event is executed within the state being continued when transitioning back to the previous state by way of the PopState() function.
<p />
<h2><a name="11.7 - STATE-RELATED FUNCTIONS"></a> 11.7 - STATE-RELATED FUNCTIONS </h2>
<p />
In addition to the functions already detailed in this chapter, there are a few other functions that are related to states and are very useful when creating new actors that make use of states.
<p />
<h3><a name="ISINSTATE"></a> ISINSTATE </h3>
<p />
This function can be used to determine the currently active state of the actor or if the given state is on the stack.
<p />
<font face=consolas>
<pre>
IsInState( name TestState, optional bool bTestStateStack )
</pre>
</font>
<p />
TestState is the name of the state to check for. If the actor is currently in this state, the function will return a value of True.
<p />
The bTestStateStack parameter specifies whether or not to check for the given state in the state stack. If True and the state is located within the stack, the function returns a value of True.
<p />
Here is an example:
<p />
<font face=consolas>
<pre>
state Looking
{
       // Something useful...
}

state Staring extends Looking
{
       // Something useful...
}

function StartLooking()
{
       if (!IsInState(‘Looking’))
   {
      PushState(‘Looking’);
       }
}
</pre>
</font>
<p />
The IsInState() function call in the example would return true if the actor was in either the Looking state or the Staring state as the IsInState() function returns true for any state extending from the TestSate. This functionality does not work with inherited states within the stack.
<p />
Here is the same example using the stack lookup method:
<p />
<font face=consolas>
<pre>
state Looking
{
       // Something useful...
}

state Staring extends Looking
{
       // Something useful...
}

function StartLooking()
{
       if (!IsInState(‘Looking’, True))
   {
      PushState(‘Looking’);
       }
}
</pre>
</font>
<p />
In this example, the IsInState() function would only return true if the Looking state itself appears in the state stack. If only the Staring state appears, a value of False would be returned.
<p />
<h3><a name="GETSTATENAME"></a> GETSTATENAME </h3>
<p />
This function returns the name of the currently active state of the actor. This function has no parameters. This function is often used in similar situations to the IsInState() function, only this function does not work with inherited states in any way. Only the name of the actual state the actor is currently in is returned.
<p />
Here is an example:
<p />
<font face=consolas>
<pre>
state Looking
{
       // Something useful...
}

state Staring extends Looking
{
       // Something useful...
}

function StartLooking()
{
       if (GetStateName() &#61;&#61; ‘Looking’)
   {
      PushState(‘Staring);
       }
}
</pre>
</font>
<p />
The PushState() function call will only be executed when the actor is in the Looking state.
<p />
<h3><a name="ISCHILDSTATE"></a> ISCHILDSTATE </h3>
<p />
This function is used to determine if one state is extended from another. It returns True if so, and False if not.
<p />
<font face=consolas>
<pre>
IsChildState(Name TestState, Name TestParentState)
</pre>
</font>
<p />
TestState is the name of the child state to check.
<p />
TestParentState is the name of the parent state to check against.
<p />
<h3><a name="DUMPSTATESTACK"></a> DUMPSTATESTACK </h3>
<p />
This function will cause the current state stack to be output to the log for debugging purposes. It is very likely that when creating new classes that make heavy use of states and state stacking, some unwanted or undesirable behavior may occur. This function makes sorting out these kinks and bugs easier.
<p />
<h2><a name="TUTORIAL 11.4 – STATE TRIGGER, PART IV: STATE STACKING"></a> TUTORIAL 11.4 – STATE TRIGGER, PART IV: STATE STACKING </h2>
<p />
The ability of states to be stacked using the PushState() and PopState() functions is new in Unreal Engine 3 and UT3. In this tutorial, the state trigger actor uses these functions to navigate between the Greeting and Inquisitor states showing the difference between this method and the GotoState() function call.
<p />
<strong>1.</strong>	Open ConTEXT and the M_StateTrigger.uc script.
<p />
<strong>2.</strong>	In the Greeting state, comment out the GotoState() function call and replace it with a call to the PushState() function passig it the same Inquisitor state.
<p />
<font face=consolas>
<pre>
//GotoState(&#39;Inquisitor&#39;);
PushState(&#39;Inquisitor&#39;);
</pre>
</font>
<p />
<strong>3.</strong>	Then in the Inquisitor state, comment out the GotoState() function call and replace it with a simple PopState() function call.
<p />
<font face=consolas>
<pre>
//GotoState(‘Goodbye’);
PopState();
</pre>
</font>
<p />
<strong>4.</strong>	Save the script and compile the scripts, fixing any errors which are present.
<p />
<strong>5.</strong>	Open UnrealEd and the map containing the MU_StateTrigger actor used in the previous tutorial.
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Right-click on the floor of one of the rooms and choose Play From Here to test the map.
<p />
<strong>b.</strong>	Run over the trigger actor to display the Dialog state’s messages and send the actor into the Greeting state.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_013.jpg"/><br/> <strong><font color=blue>Figure 11.13 – The Dialog state’s Touch() and EndState() event messages and the Greeting state’s BeginState() event message are displayed.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>c.</strong>	Run back over the actor and notice that only the message from the Touch() event was displayed. The BeginState() and EndState() events of the Inquisitor and Greeting states, respectively, were ignored. Only the GotoState() function causes these events to be executed.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_014.jpg"/><br/> <strong><font color=blue>Figure 11.14 – Only the message from the Touch() event of the Greeting state is displayed.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>d.</strong>	Run over the actor again to display the Inquisitor state’s Touch() event message.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_015.jpg"/><br/> <strong><font color=blue>Figure 11.15 – The Touch() event message from the Inquisitor state is now displayed.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>e.</strong>	Finally, run over the actor one more time. Notice that the PopState() function call in the Touch() event of the Inquisitor state placed the actor back into the Greeting state causing the greeting message to be displayed once again.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_016.jpg"/><br/> <strong><font color=blue>Figure 11.16 – The message from the Greeting state is displayed once again.</font></strong>
<p />
<strong>6.</strong>	Obviously, the BeginState() and EndState() events won’t work now that the class is using stacking. In order to get events to specify which state is being pushed or pop in a similar fashion to before, the state stacking events are used instead. Begin by declaring the PushedState() event in the Dialog state.
<p />
<font face=consolas>
<pre>
event PushedState()
{
}
</pre>
</font>
<p />
Inside this function, place the same line of code used to output the message in the BeginState() event, only use the GetStateName() function to get the appropriate name of the state instead of the PreeviousStateParameter. Also, change the word “Exiting” to read “Pushing”.
<p />
<font face=consolas>
<pre>
WorldInfo.Game.Broadcast(self,&#34;Pushing the&#34;&#64;GetStateName()&#64;&#34;State&#34;);
</pre>
</font>
<p />
Copy and paste the entire event declaration 3 times changing the names of the new declarations to PoppedState, PausedState, and ContinuedState. Then change the word “Pushing” to read “Popping”, Pausing”, and “Continuing”, respectively.
<p />
<font face=consolas>
<pre>
event PoppedState()
{
   WorldInfo.Game.Broadcast(self,&#34;Popping the&#34;&#64;GetStateName()&#64;&#34;State&#34;);
}

event PausedState()
{
   WorldInfo.Game.Broadcast(self,&#34;Pausing the&#34;&#64;GetStateName()&#64;&#34;State&#34;);
}

event ContinuedState()
{
   WorldInfo.Game.Broadcast(self,&#34;Continuing the&#34;&#64;GetStateName()&#64;&#34;State&#34;);
}
</pre>
</font>
<p />
<strong>7.</strong>	Save the script and compile the scripts again, fixing any errors which may be present.
<p />
<strong>8.</strong>	Open UnrealEd and the map saved previously with the state trigger actor in it.
<p />
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Right-click on the floor of one of the rooms and choose Play From Here to test the map.
<p />
<strong>b.</strong>	Run over the trigger actor to display the Dialog state’s messages and send the actor into the Greeting state.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_017.jpg"/><br/> <strong><font color=blue>Figure 11.17 – The Dialog state’s Touch() and EndState() event messages and the Greeting state’s BeginState() event message are displayed.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>c.</strong>	Run back over the actor and notice that the messages from the PausedState() and PushedState() events are now displayed because of the use of the PushState() function.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_018.jpg"/><br/> <strong><font color=blue>Figure 11.18 – The PausedState() and PushedState() messages are displayed in addition to the Touch() message.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>d.</strong>	Run over the actor again to pop the Inquisitor state. The PoppedState() and ContinuedState() events should now be displayed because of the PopState() function call.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_019.jpg"/><br/> <strong><font color=blue>Figure 11.19 – The PoppedState() and ContinuedState() messages are now displayed with the Touch() message.</font></strong>
<p />
This short series of tutorials was simply meant to provide a basic understanding of what states are and how they work, including the various methods of transitioning between them. In subsequent tutorials, states will be used in more complex examples to give you a better feel for just how states can be used within UT3 to create interesting new items to be used in the game.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.5 – TURRET, PART I: MU_AUTOTURRET CLASS AND STRUCT DECLARATION"></a> TUTORIAL 11.5 – TURRET, PART I: MU_AUTOTURRET CLASS AND STRUCT DECLARATION </h2>
<p />
With the basics of using states out of the way, you will now embark on the creation of a new placeable sentry turret that auto-targets any visible enemies. This class is an extension of the Pawn class which will provide the visual aspect of the actor and use states to differentiate behavior based on factors in its environment. There is quite a bit of initial setup to be performed before we get into the states of the turret so we will get that out of the way first.
<p />
<strong>1.</strong>	Open ConTEXT and create a new file using the UnrealScript highlighter.
<p />
<strong>2.</strong>	To begin with, declare the new pawn class called MU_AutoTurret and extend it from the base Pawn class. Also, hide the AI, Camera, Debug, Pawn, and Physics categories so they do not show up in the Properties window inside of UnrealEd and make the class placeable.
<p />
<font face=consolas>
<pre>
class MU&#95;AutoTurret extends Pawn HideCategories(AI,Camera,Debug,Pawn,Physics)
   placeable;
</pre>
</font>
<p />
<strong>3.</strong>	This classes uses several structs that need to be defined before we move on to declaring variables. First, a new RotationRange struct is created which consists of two Rotators representing a minimum and maximum rotation around each of the axes: Pitch, Yaw, and Roll. Also, three Bool variables specifying whether to use the limits for each axis of rotation are declared.
<p />
<font face=consolas>
<pre>
//Min and Max Rotators Struct - limiting turret rotation
struct RotationRange
{
   var() Rotator RotLimitMin;
   var() Rotator RotLimitMax;
   var() Bool bLimitPitch;
   var() Bool bLimitYaw;
   var() Bool bLimitRoll;

   structdefaultproperties
   {
      RotLimitMin&#61;(Pitch&#61;-65536,Yaw&#61;-65536,Roll&#61;-65536)
      RotLimitMax&#61;(Pitch&#61;65536,Yaw&#61;65536,Roll&#61;65536)
   }
};
</pre>
</font>
<p />
Note: default values for each Rotator have been defined using a structdefaultproperties block.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_020.jpg"/><br/> <strong><font color=blue>Figure 11.20 – On the right, the rotation is not limited, on the left limits have been put into place.</font></strong>
<p />
<strong>4.</strong>	The next struct named TurretSoundGroup containing references to several SoundCues is defined. These SoundCue references are used to determine which sounds will play under certain circumstances.
<p />
<font face=consolas>
<pre>
// Sounds for turret behaviors
struct TurretSoundGroup
{
   var() SoundCue FireSound;
   var() SoundCue DamageSound;
   var() SoundCue SpinUpSound;
   var() SoundCue WakeSound;
   var() SoundCue SleepSound;
   var() SoundCue DeathSound;
};
</pre>
</font>
<p />
<strong>5.</strong>	The turret needs a few special effects such as a muzzle flash, damage effects and a destruction effect which require references to the ParticleSystems to use for these effects. A struct named TurretEmitterGroup holds these references. Some other properties are present in this struct as well: a Float determining the amount of time to show the muzzle flash effect for, the Name of the parameter within the damage effect’s particle system that allows control of the spawn rate of the particles, and a Bool to specify whether the damage effect continues after the destruction of the turret.
<p />
<font face=consolas>
<pre>
//PSystems for the turret
struct TurretEmitterGroup
{
   var() ParticleSystem DamageEmitter;
   var() ParticleSystem MuzzleFlashEmitter;
   var() ParticleSystem DestroyEmitter;
   var() Float MuzzleFlashDuration;
   var() Name DamageEmitterParamName;
   var() Bool bStopDamageEmitterOnDeath;

   structdefaultproperties
   {
      MuzzleFlashDuration&#61;0.33
   }
};
</pre>
</font>
<p />
Note the default value set to 0.33 for the MuzzleFlashDuration property. This should be a good starting value for most muzzle flashes.
<p />
<strong>6.</strong>	Another struct named TurretBoneGroup provides references to three socket names and the name of a skeletal controller. The socket names reference sockets to be used as locators for any particle effects and for the spawning of the projectiles the turret fires. The name of the skeletal controller is used to manipulate the SkelControlSingleBone in the AnimTree assigned to the turret to control the turrets rotation.
<p />
<font face=consolas>
<pre>
//Bone, Socket, Controller names
struct TurretBoneGroup
{
   var() Name DestroySocket;
   var() Name DamageSocket;
   var() Name FireSocket;
   var() Name PivotControllerName;
};
</pre>
</font>
<p />
<strong>7.</strong>	The final struct named TurretRotationGroup contains three Rotators to specify the pose the turret should be placed in when idle, alert, or destroyed. The rotation of the turret is interpolated from its current orientation to one of these three rotations depending on the situation. This struct also contains a Bool specifying whether to use a predefined pose when the turret is destroyed or a randomly calculated pose.
<p />
<font face=consolas>
<pre>
//Rotators defining turret poses
struct TurretRotationGroup
{
   var() Rotator IdleRotation;
   var() Rotator AlertRotation;
   var() Rotator DeathRotation;
   var() Bool bRandomDeath;

};
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_021.jpg"/><br/> <strong><font color=blue>Figure 11.21 – Rotations are used to create poses for the turret mesh.</font></strong>
<p />
<strong>8.</strong>	Save the script in the MasteringUnrealScript/Classes directory with the name MU_AutoTurret.uc to match the class name.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.6 – TURRET, PART II: CLASS VARIABLE DECLARATIONS"></a> TUTORIAL 11.6 – TURRET, PART II: CLASS VARIABLE DECLARATIONS </h2>
<p />
With the structs needed for the MU_AutoTurret class now declared, the class variables can be declared. These variables are separated into two groups. The first group is made up of variables which are solely used by the code within the class and not available to the designer in UnrealEd. The second group will be properties that the designer can use to customize the look and behavior of the turret within UnrealEd. This tutorial covers the declarations of the first group of non-editable variables.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	The turret needs to know what to shoot at in order to track it and fire. This target is a Pawn and two separate references will be kept to the turret’s target. One reference will be the current target the turret was tracking during the last tick and the other is a reference to the new target the turret should track during the current tick. The two references are necessary so that we can tell when the target has changed from one tick to the next.
<p />
<font face=consolas>
<pre>
var Pawn EnemyTarget;      //The new enemy the turret should target this tick
var Pawn LastEnemyTarget;   //The enemy the turret was targeting last tick
</pre>
</font>
<p />
<strong>3.</strong>	The turret must also keep track of the direction from the turret to the target in order to know when the player has moved. As with the target, two references will be kept to hold the direction vector during this tick as well as the direction vector from the previous tick.
<p />
<font face=consolas>
<pre>
var Vector EnemyDir;      //Vector from the turret&#39;s base to the enemy&#39;s location this tick
var Vector LastEnemyDir;   //Vector from the turret&#39;s base to the enemy&#39;s location last tick
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_022.jpg"/><br/> <strong><font color=blue>Figure 11.22 – As the target moves, the EnemyDir and LastEnemyDir update.</font></strong>
<p />
<strong>4.</strong>	In order to interpolate the rotation of the turret from its current orientation to face the target, several pieces of information are necessary. These are listed below.
<p /> <ul>
<li> The beginning rotation of the turret’s pivot bone
</li> <li> The desired rotation of the turret’s pivot bone
</li> <li> The total time necessary to perform the rotation (based on the rotation rate to be declared later)
</li> <li> The amount of time elapsed since the interpolation began
</li> <li> The alpha value (0.0 to 1.0) of the interpolation
</li></ul>
<p />
Declare these variables now as follows:
<p />
<font face=consolas>
<pre>
var float TotalInterpTime;   //Total time to interpolate rotation
var Float ElapsedTime;      //Time spent in the current interpolation
var Float RotationAlpha;   //Curret alpha for interpolating to a new rotation
var Rotator StartRotation;   //Beginning rotation for interpolating
var Rotator TargetRotation;   //Desired rotations for interpolating
</pre>
</font>
<p />
<strong>5.</strong>	To cause the projectiles fired from the turret to spawn in the correct location and orientation, two variables are used to hold the location and rotation in world space of the socket located at the tip of the barrel of the turret.
<p />
<font face=consolas>
<pre>
var Vector FireLocation;   //World position of the firing socket
var Rotator FireRotation;   //World orientation of the firing socket
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_023.jpg"/><br/> <strong><font color=blue>Figure 11.23 – An example FireLocation and FireRotation.</font></strong>
<p />
<strong>6.</strong>	The rotation of the turret is based on a pivot bone, but the rotation of this bone is not controlled directly. Instead, a SkelControlSingleBone is linked to the pivot bone in the AnimTree assigned to the turret and the skeletal controller is manipulated to control the rotation of the turret. Of course, this means a reference to this skeletal controller is needed.
<p />
<font face=consolas>
<pre>
var SkelControlSingleBone PivotController;      //The  skelcontrol in the AnimTree
</pre>
</font>
<p />
<strong>7.</strong>	Two Bool variables hold the current status of the turret. The first named bCanFire determines whether the turret is in a state where it can fire projectiles at the target. The other named bDestroyed determines whether the turret has been destroyed and should no longer target enemies.
<p />
<font face=consolas>
<pre>
var Bool bCanFire;      //Is the turret in a firing state?
var Bool bDestroyed;      //Has the turret been destroyed?
</pre>
</font>
<p />
<strong>8.</strong>	As you will see in the next tutorial, the health of the turret is configurable within UnrealEd by the designer. A separate variable will hold the beginning value of that property in order to have a reference to the maximum health the turret can have.
<p />
<font face=consolas>
<pre>
var Int MaxTurretHealth;      //Max health for this turret
</pre>
</font>
<p />
<strong>9.</strong>	A float variable named FullRevTime holds the amount of seconds necessary for the turret to make a full revolution while rotating at its minimum rotation rate as specified by a property that will show up in the next tutorial, MinTurretRotRate.
<p />
<font face=consolas>
<pre>
var Float FullRevTime;   //Seconds to make full rev at min rot rate
</pre>
</font>
<p />
<strong>10.</strong>	A Float variable named GElapsedTime holds the amount of time that has passed since the last enemy locating update performed in the classes global Tick() function. The G prefix is simply to indicate this is to be used in the global Tick() function instead of any state Tick() functions.
<p />
<font face=consolas>
<pre>
var Float GElapsedTime;   //Elapsed time since last global tick
</pre>
</font>
<p />
<strong>11.</strong>	An Int named OrigMinRotRate holds a reference to the initial value when the match begins of one of the editable variables, MinTurretRotRate, that is declared in the following tutorial.
<p />
<font face=consolas>
<pre>
var Int OrigMinRotRate;   //Beginning value of MinTurretRotRate
</pre>
</font>
<p />
<strong>12.</strong>	The last few variables in this group are references to the ParticleSystemComponents that display the damage, muzzle flash, and destruction effects.
<p />
<font face=consolas>
<pre>
var ParticleSystemComponent DamageEffect;      //PSys component for damage effects
var ParticleSystemComponent MuzzleFlashEffect;   //PSys component for muzzle flashes
var ParticleSystemComponent DestroyEffect;      //PSys component for destruction effects
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_024.jpg"/><br/> <strong><font color=blue>Figure 11.24 – Examples of a muzzle flash, damage, and destruction effect.</font></strong>
<p />
<strong>13.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.7 – TURRET, PART III: EDITABLE VARIABLE DECLARATIONS"></a> TUTORIAL 11.7 – TURRET, PART III: EDITABLE VARIABLE DECLARATIONS </h2>
<p />
The second group of variables belonging to the MU_AutoTuret class consists of the properties that are configurable by the designer inside of the Unreal Editor. This section contains variables making use of the structs declared previously and enables the turret class to be very flexible by allowing the designer to customize the look and behavior of the turret without the need to alter the code in any way. All of the variables declared in this tutorial will be declared as editable and placed within the Turret category.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	 You may have noticed the references to sockets and skeletal controllers in previous tutorials which may have led you to the conclusion that the turret uses a skeletal mesh as its display component. Pawns do already have a SkeletalMeshComponent reference, but the turret class declares its own to be displayed within the Turret category. In addition to a SkeletalMeshComponent for display purposes, a DynamicLightEnvironmentComponent is used for lighting the mesh more efficiently. A secondary skeletal mesh is also specified to be swapped with the default mesh when the turret is destroyed.
<p />
<font face=consolas>
<pre>
var(Turret) SkeletalMeshComponent TurretMesh;         //SkelMeshComp for the turret
var(Turret) DynamicLightEnvironmentComponent LightEnvironment;   //For efficient lighting
var(Turret) SkeletalMesh DestroyedMesh;            //destroyed SkelMesh
</pre>
</font>
<p />
<strong>3.</strong>	A single instance of the TurretBoneGroup struct defined earlier is needed to provide the names of the sockets and skeletal controller needed to control the turret’s rotation and attach effects to.
<p />
<font face=consolas>
<pre>
var(Turret) TurretBoneGroup TurretBones;   // Socket, Controller names
</pre>
</font>
<p />
<strong>4.</strong>	In addition to an instance of the TurretRotationGroup struct to set poses for the turret, an instance of the RotationRange is used to set limits for rotations round each axis as well as two Int variables to set the minimum and maximum rotation rate the turret can achieve are necessary.
<p />
<font face=consolas>
<pre>
var(Turret) TurretRotationGroup TurretRotations;   //Rotations defining turret poses
var(Turret) RotationRange RotLimit;         //Rotation limits for turret
var(Turret) Int MinTurretRotRate;         //Min Rotation speed Rot/Second
var(Turret) Int MaxTurretRotRate;         //Max Rotation speed Rot/Second
</pre>
</font>
<p />
<strong>5.</strong>	The turret shoots projectiles and needs to know which class of projectile to shoot. Also, the speed at which to shoot the projectiles is specified as the number of rounds to shoot each second. In order to give a more realistic representation of an actual turret, some variation in the aim of the turret is introduced.
<p />
<font face=consolas>
<pre>
var(Turret) class&#60;Projectile&#62; ProjClass;      //Type of projectile the turret fires
var(Turret) Int RoundsPerSec;            //Number of rounds to fire per second
var(Turret) Int AimRotError;            //Maximum units of error in turret aiming
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_025.jpg"/><br/> <strong><font color=blue>Figure 11.25 – The same turret with varying RoundsPerSecond values.</font></strong>
<p />
<strong>6.</strong>	An instance of the TurretEmitterGroup struct provides references to particle systems to use for the damage, destruction, and muzzle flash effects.
<p />
<font face=consolas>
<pre>
var(Turret) TurretEmitterGroup TurretEmitters;   //PSystems used by the turret
</pre>
</font>
<p />
<strong>7.</strong>	Sounds for the turret are referenced within an instance of the TurretSoundGroup struct.
<p />
<font face=consolas>
<pre>
var(Turret) TurretSoundGroup TurretSounds;      //Sounds used for turret behaviors
</pre>
</font>
<p />
<strong>8.</strong>	While Pawns have a Health property, the turret uses its own TurretHealth property to keep all properties contained within the Turret group.
<p />
<font face=consolas>
<pre>
var(Turret) Int TurretHealth;      //Initial amount of health for the turret
</pre>
</font>
<p />
<strong>9.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.8 – TURRET, PART IV: DEFAULT PROPERTIES"></a> TUTORIAL 11.8 – TURRET, PART IV: DEFAULT PROPERTIES </h2>
<p />
For the final part of the MU_AutoTurret class setup, sub-objects need to be created for the components used by the turret. Also in the default properties block, default values must be set for the properties of the struct instances and various other individual properties declared in the previous tutorial.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	Create the defaultproperties block
<p />
<font face=consolas>
<pre>
defaultproperties
{
}
</pre>
</font>
<p />
<strong>3.</strong>	The DynamicLightEnvirnmentComponent is fairly simple to create since it has no properties which need be set. All the defaults will suffice. It is assigned to the LightEnvironment variable and added to the Components array.
<p />
<font face=consolas>
<pre>
Begin Object Class&#61;DynamicLightEnvironmentComponent Name&#61;MyLightEnvironment
End Object
LightEnvironment&#61;MyLightEnvironment
Components.Add(MyLightEnvironment)
</pre>
</font>
<p />
<strong>4.</strong>	The SkeletalMeshComponent needs to be created, added to the Components array and assigned to the TurretMesh variable of this class as well as the Mesh variable inherited from the Pawn class. In addition, the SkeletalMesh, AnimTreeTemplate, PhysicsAsset, and LightEnvirnment properties of the component are set.
<p />
<font face=consolas>
<pre>
Begin Object class&#61;SkeletalMeshComponent name&#61;SkelMeshComp0
   SkeletalMesh&#61;SkeletalMesh&#39;TurretContent.TurretMesh&#39;
   AnimTreeTemplate&#61;AnimTree&#39;TurretContent.TurretAnimTree&#39;
   PhysicsAsset&#61;PhysicsAsset&#39;TurretContent.TurretMesh&#95;Physics&#39;
   LightEnvironment&#61;MyLightEnvironment
End Object
Components.Add(SkelMeshComp0)
TurretMesh&#61;SkelMeshComp0
Mesh&#61;SkelMeshComp0
</pre>
</font>
<p />
The assets assigned to the Skeletalmesh, AnimTreeTemplate, and PhysicsAsset are located in the TurretContent package provided with the files for this chapter on the DVD. These are only the defaults and can be replaced with your own assets when placing a turret actor inside of the Unreal Editor to customize the turret.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_026.jpg"/><br/> <strong><font color=blue>Figure 11.26 – The TurretMesh skeletal mesh from the TurretContent package.</font></strong>
<p />
<strong>5.</strong>	The ParticleSystemComponent subobjects for the MuzzleFlashEffect, DestroyEffect, and DamageEffect are all very similar and can be done all at once. The only deviation is with the DamageEffect’s component where the SecondsBeforeInactive property will be set to a fairly high value of 10000.0, instead of a value of 1.0 like the other two componenets, to ensure the ParticleSystem continues playing at all times.
<p />
<font face=consolas>
<pre>
Begin Object Class&#61;ParticleSystemComponent Name&#61;ParticleSystemComponent0
   SecondsBeforeInactive&#61;1
End Object
MuzzleFlashEffect&#61;ParticleSystemComponent0
Components.Add(ParticleSystemComponent0)

Begin Object Class&#61;ParticleSystemComponent Name&#61;ParticleSystemComponent1
   SecondsBeforeInactive&#61;1
End Object
DestroyedEffect&#61;ParticleSystemComponent1
Components.Add(ParticleSystemComponent1)

Begin Object Class&#61;ParticleSystemComponent Name&#61;ParticleSystemComponent2
   SecondsBeforeInactive&#61;10000.0
End Object
DamageEffect&#61;ParticleSystemComponent2
Components.Add(ParticleSystemComponent2)
</pre>
</font>
<p />
<strong>6.</strong>	The values of properties located within the TurretBones struct are set based on the default SkeletalMesh and Animtree. These can be overridden within the editor when using a different mesh or AnimTree.
<p />
<font face=consolas>
<pre>
TurretBones&#61;{(
   DestroySocket&#61;DamageLocation,
   DamageSocket&#61;DamageLocation,
   FireSocket&#61;FireLocation,
   PivotControllerName&#61;PivotController
   )}
</pre>
</font>
<p />
<strong>7.</strong>	Again with the TurretSounds struct, default sounds from the UT3 assets are assigned to each of the properties in the struct.
<p />
<font face=consolas>
<pre>
TurretSounds&#61;{(
   FireSound&#61;SoundCue&#39;A&#95;Weapon&#95;Link.Cue.A&#95;Weapon&#95;Link&#95;FireCue&#39;,
   DamageSound&#61;SoundCue&#39;A&#95;Weapon&#95;Stinger.Weapons.A&#95;Weapon&#95;Stinger&#95;FireImpactCue&#39;,
   SpinUpSound&#61;SoundCue&#39;A&#95;Vehicle&#95;Turret.Cue.AxonTurret&#95;PowerUpCue&#39;,
   WakeSound&#61;SoundCue&#39;A&#95;Vehicle&#95;Turret.Cue.A&#95;Turret&#95;TrackStart01Cue&#39;,
   SleepSound&#61;SoundCue&#39;A&#95;Vehicle&#95;Turret.Cue.A&#95;Turret&#95;TrackStop01Cue&#39;,
   DeathSound&#61;SoundCue&#39;A&#95;Vehicle&#95;Turret.Cue.AxonTurret&#95;PowerDownCue&#39;
   )}
</pre>
</font>
<p />
<strong>8.</strong>	One custom and two stock ParticleSystems along with the name of the parameter controlling the spawn rate within the damage emitter are assigned to the properties of the TurretEmitter struct.
<p />
<font face=consolas>
<pre>
TurretEmitters&#61;{(
   DamageEmitter&#61;ParticleSystem&#39;TurretContent.P&#95;TurretDamage&#39;,
      MuzzleFlashEmitter&#61;ParticleSystem&#39;WP&#95;Stinger.Particles.P&#95;Stinger&#95;3P&#95;MF&#95;Alt&#95;Fire&#39;,
   DestroyEmitter&#61;ParticleSystem&#39;FX&#95;VehicleExplosions.Effects.P&#95;FX&#95;VehicleDeathExplosion&#39;,
   DamageEmitterParamName&#61;DamageParticles
   )}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_027.jpg"/><br/> <strong><font color=blue>Figure 11.27 – The damage, muzzle flash, and destruction effect particle systems.</font></strong>
<p />
<strong>9.</strong>	Each of the rotations contained within the TurretRotations struct can be set with default values for posing the default mesh.
<p />
<font face=consolas>
<pre>
TurretRotations&#61;{(
   IdleRotation&#61;(Pitch&#61;-8192,Yaw&#61;0,Roll&#61;0),
   AlertRotation&#61;(Pitch&#61;0,Yaw&#61;0,Roll&#61;0),
   DeathRotation&#61;(Pitch&#61;8192,Yaw&#61;4551,Roll&#61;10922)
   )}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_028.jpg"/><br/> <strong><font color=blue>Figure 11.28 – The TurretMesh assuming the Idle, Alert, and Death poses.</font></strong>
<p />
<strong>10.</strong>	Finally, the various other properties such as the rotation rate, firing rate, health, projectile class, aim error are all given default values. In addition one inherited property is set here as well: bEdShouldSnap. This variable is given a value of True to make the turret snap to the grid when placing instances of it inside of UnrealEd.
<p />
<font face=consolas>
<pre>
TurretRotRate&#61;128000
TurretHealth&#61;500
AimRotError&#61;128
ProjClass&#61;class&#39;UTGame.UTProj&#95;LinkPowerPlasma&#39;
RoundsPerSec&#61;3
bEdShouldSnap&#61;true
</pre>
</font>
<p />
<strong>11.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.9 – TURRET, PART V: POSTBEGINPLAY() EVENT"></a> TUTORIAL 11.9 – TURRET, PART V: POSTBEGINPLAY() EVENT </h2>
<p />
Back in the MU_AutoTurret class, the PostBeginPlay() event will be overridden and used to create the controller and initialize the turret.
<p />
<strong>1.</strong>	OpenConTEXT and the MU_AutoTurret.uc scrpt.
<p />
<strong>2.</strong>	Declare the PostBeingPlay() event so it can be overridden in the turret class.
<p />
<font face=consolas>
<pre>
event PostBeginPlay()
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Call the AIController class’s PostBeginPlay() to make sure any basic initialization present in the parent classes is performed.
<p />
<font face=consolas>
<pre>
Super.PostBeginPlay();
</pre>
</font>
<p />
<strong>4.</strong>	The MaxTurretHealth property is set to the beginning value of the TurretHealth property. This is used later to determine the percentage of damage done to the turret at any given time. Also, the value of OrigMinRotRate is initialized to the value of MinTurretRotRate and the FullRevTime is calculated by dividing one full revolution of rotator units by the MinTurretRotaRate..
<p />
<font face=consolas>
<pre>
MaxTurretHealth &#61; TurretHealth;
OrigMinRotRate &#61; MinTurretRotRate;
FullRevTime &#61; 65536.0 / Float(MinTurretRotRate);
</pre>
</font>
<p />
<strong>5.</strong>	To initialize the PivotController variable, we need to find a reference to the SkelControlSingleBone skeletal controller located within the AnimTree assigned to the SkeletalMeshComponent. Passing the TurretBones.PivotControllerName value to the component’s FindSkelControl() function and casting the result to a SkelControlSingleBone accomplishes this.
<p />
<font face=consolas>
<pre>
PivotController&#61;SkelControlSingleBone(Mesh.FindSkelControl(TurretBones.PivotControllerName));
</pre>
</font>
<p />
Note: The code is using the Mesh variable to reference the SkeletalMeshComponenet even though we declared the TurretMesh variable in this class. If you’ll remember, the SkeletalMeshComponent was assigned to both of these variables in the default properties so they both reference the same component. The Mesh variable was chosen to be used in the code as it is shorter and means less typing.
<p />
<strong>6.</strong>	Next, the FireLocation and FireRotation variables are initialized by passing them along with the TurretBones.FireSocket value to the SkeletalMeshComponent’s GetSocketWorldLocationAndRotation() function.
<p />
<font face=consolas>
<pre>
Mesh.GetSocketWorldLocationAndRotation(TurretBones.FireSocket,FireLocation,FireRotation);
</pre>
</font>
<p />
The second and third parameters of this function are declared using the Out specifier, which as you know means that the function sets the values of these variables that are passed into the function.
<p />
<strong>7.</strong>	The ParticleSystems specified in the TurretEmitters struct are assigned as the templates for the three ParticleSystemComponents for the damage, destroy, and muzzle flash effects.
<p />
<font face=consolas>
<pre>
DamageEffect.SetTemplate(TurretEmitters.DamageEmitter);
MuzzleFlashEffect.SetTemplate(TurretEmitters.MuzzleFlashEmitter);
DestroyEffect.SetTemplate(TurretEmitters.DestroyEmitter);
</pre>
</font>
<p />
<strong>8.</strong>	The three ParticleSystemComponents are attached to the appropriate sockets of the SkeletalMeshComponent using the AttachComponentToSocket() function of the SkeletalMeshComponent
<p />
<font face=consolas>
<pre>
Mesh.AttachComponentToSocket(DamageEffect, TurretBones.DamageSocket);
Mesh.AttachComponentToSocket(MuzzleFlashEffect, TurretBones.FireSocket);
Mesh.AttachComponentToSocket(DestroyEffect, TurretBones.DestroySocket);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_029.jpg"/><br/> <strong><font color=blue>Figure 11.29 – The particle systems attached to the locations of the sockets in the skeletal mesh.</font></strong>
<p />
<strong>9.</strong>	Finally, the Physics of the turret is set to PHYS_None so no physics is applied to the turret.
<p />
<font face=consolas>
<pre>
SetPhysics(PHYS&#95;None);
</pre>
</font>
<p />
<strong>10.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.10 – TURRET, PART VI: ROTATION FUNCTIONS"></a> TUTORIAL 11.10 – TURRET, PART VI: ROTATION FUNCTIONS </h2>
<p />
At various spoints in the turret script, the turret needs to be able to rotate to a given rotation in order to assume the poses set in the Idle, Alert, and Death rotations. To make this rotation look smooth and realistic, an interpolation is used instead of directly setting the rotation causing a snapping effect. Two functions are involved in this process. One function sets up all the necessary properties and set a looping timer, while the other calculates the interpolated rotation and adjusts the skeletal controller accordingly.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	The first function to be added is named DoRotation() and has a single Rotator parameter named NewRotation.
<p />
<font face=consolas>
<pre>
function DoRotation(Rotator NewRotation, Float InterpTime)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	The second function, a timer function, is named RotateTimer() and has no parameters.
<p />
<font face=consolas>
<pre>
function RotateTimer()
{
}
</pre>
</font>
<p />
<strong>4.</strong>	First the DoRotation() function initializes the StartRotation, TargetRotation, and RotationAlpha properties of the turret class.
<p />
<font face=consolas>
<pre>
StartRotation &#61; PivotController.BoneRotation;
TargetRotation &#61; NewRotation;
RotationAlpha &#61; 0.0;
TotalInterpTime &#61; InterpTime;
</pre>
</font>
<p />
As you can see, the StartRotation is set to the current rotation of the turret specified by the BoneRotation property of the skeletal controller in the AnimTree. The TargetRotation is set to the NewwRotation passed to the function. Then, the RotationAlpha is reset to 0.0 to begin the new interpolation and the TotalInterpTime is set to the duration passed into the function.
<p />
<strong>5.</strong>	Once the values have been initialized, a looping timer is set to call the RotateTimer() function every 0.033 seconds, or 30 times a second.
<p />
<font face=consolas>
<pre>
SetTimer(0.033,true,&#39;RotateTimer&#39;);
</pre>
</font>
<p />
<strong>6.</strong>	Inside the RotateTimer() function, the RotationAlpha is incremented by the same value as the rate of the timer, 0.033.
<p />
<font face=consolas>
<pre>
RotationAlpha +&#61; 0.033;
</pre>
</font>
<p />
<strong>7.</strong>	If the RotationAlpha is less than or equal to TotalInterpTime, the interpolation is calculated and the BoneRotation property is set with the new rotation.
<p />
<font face=consolas>
<pre>
if(RotationAlpha &#60;&#61; TotalInterpTime)
   PivotController.BoneRotation &#61; RLerp(StartRotation,TargetRotation,RotationAlpha,true);
</pre>
</font>
<p />
The RLerp() function defined in the Object class performs the interpolation calculation based on the beginning rotation, ending rotation, and current alpha values passed to the function. The final parameter, a Bool, specifies whether to use the shortest distance to interpolate from the beginning rotation to the ending rotation.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_030.jpg"/><br/> <strong><font color=blue>Figure 11.30 – Updating the BoneRotation of the skeletal controller rotates the turret.</font></strong>
<p />
<strong>8.</strong>	Otherwise, if the RotationAlpha value is greater than 1.0, signifying the interpolation has finished, the timer is cleared.
<p />
<font face=consolas>
<pre>
else
   ClearTimer(&#39;RotateTimer&#39;);
</pre>
</font>
<p />
<strong>9.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.11 – TURRET, PART VII: STATE DECLARATIONS"></a> TUTORIAL 11.11 – TURRET, PART VII: STATE DECLARATIONS </h2>
<p />
The turret class consists of four states defining the four different behaviors the turret can assume. At this point, the states are declared as skeleton states, or placeholders, simply to give you an idea of what exists. The bodies of these states will be filled out in subsequent tutorials.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	The first state declared is the Idle state. This is the default initial state of the turret. Its function is fairly self-explanatory: it causes the turret to idle or stand by waiting for some outside event to occur which forces the turret into some other state to take the appropriate action.
<p />
<font face=consolas>
<pre>
auto state Idle
{
}
</pre>
</font>
<p />
Notice the use of the Auto specifier in the state’s declaration forcing the turret into this state when the game begins.
<p />
<strong>3.</strong>	The next state declared in the turret class is the Alert state. This state represents an increase in alertness over the idle state, where the turret is actively searching for any visible enemy to target and attack.
<p />
<font face=consolas>
<pre>
state Alert
{
}
</pre>
</font>
<p />
<strong>4.</strong>	The next state declared in the class is the Defend state. Once an enemy has been found, the Defend state is entered. This state handles targeting the enemy and firing projectiles.
<p />
<font face=consolas>
<pre>
state Defend
{
}
</pre>
</font>
<p />
<strong>5.</strong>	The final state declared in the turret class is the Dead state. This is also the final state for the turret which it only enters after its health has reached 0. This state handles all the destruction effects and ceases all other functionality such as searching for, targeting, or firing at enemies.
<p />
<font face=consolas>
<pre>
state Dead
{
}
</pre>
</font>
<p />
<strong>6.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.12 – TURRET, PART VIII: GLOBAL TAKEDAMAGE() FUNCTION"></a> TUTORIAL 11.12 – TURRET, PART VIII: GLOBAL TAKEDAMAGE() FUNCTION </h2>
<p />
The turret we are creating is able to be damaged and even destroyed by the players in the game. In order to handle this damaging ability, the TakeDamage() function inherited from the parent class will be overridden. This tutorial will cover the setup of this TakeDamage() function.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	The TakeDamage() event is inherited and is overridden in the turret class to enable the turret to handle playing its damage effects and sounds as well as making use of its TurretHealth variable in place of the inherited Health variable. Declare this event to allow it to be overridden.
<p />
<font face=consolas>
<pre>
event TakeDamage(int Damage,
       Controller InstigatedBy,
       vector HitLocation,
       vector Momentum,
       class&#60;DamageType&#62; DamageType,
       optional TraceHitInfo HitInfo,
       optional Actor DamageCauser   )
{
}
</pre>
</font>
<p />
<strong>3.</strong>	First, the TurretHealth property is adjusted by subtracting the value passed in as the Damage parameter.
<p />
<font face=consolas>
<pre>
TurretHealth -&#61; Damage;
</pre>
</font>
<p />
<strong>4.</strong>	Next, a check is performed to determine if the DamageEmitter exists and then sets the value of the spawn rate parameter of the DamageEffect accordingly using the SetFloatParam() function  of the ParticleSystemComponent.
<p />
<font face=consolas>
<pre>
if(TurretEmitters.DamageEmitter !&#61; None)
{
   DamageEffect.SetFloatParameter(TurretEmitters.DamageEmitterParamName,FClamp(1-Float(TurretHealth)/Float(MaxTurretHealth)),0.0,1.0));
}
</pre>
</font>
<p />
The majority of the code above should be fairly self-explanatory. The parameter name is passed to the SetFloatParameter() function as the first parameter and the value to be assigned to that parameter is passed as the second parameter. The parameter in the particle system is expecting a value between 0.0 and 1.0 representing the relative amount of damage done to the turret. This value is mapped to a new range which determines the amount of particles to spawn each second.
<p />
<font face=consolas>
<pre>
FClamp(1-Float(TurretHealth)/Float(MaxTurretHealth)),0.0,1.0)
</pre>
</font>
<p />
This value is calculated by dividing the current health value by the initial maximum health value to get a percentage of the turret’s health remaining. That result is then subtracted from 1.0 to get the inverse percentage, or the percentage of damage done. This is then clamped between 0.0 and 1.0 for good measure.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_031.jpg"/><br/> <strong><font color=blue>Figure 11.31 – As the turret is damaged, the damage emitter spawns more particles.</font></strong>
<p />
<strong>5.</strong>	Any sound meant to be played when the turret is damaged is played using the PlaySound() function after the damage effect is adjusted.
<p />
<font face=consolas>
<pre>
if(TurretSounds.DamageSound !&#61; None)
   PlaySound(TurretSounds.DamageSound);
</pre>
</font>
<p />
<strong>6.</strong>	As a defense mechanism, any Pawn who shoots at and damages the turret becomes the turret’s enemy and is targeted. The InstigatedBy parameter is a controller so its Pawn, if one exists, will become the new EnemyTarget of the turret.
<p />
<font face=consolas>
<pre>
if(InstigatedBy.Pawn !&#61; None)
   EnemyTarget &#61; InstigatedBy.Pawn;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_032.jpg"/><br/> <strong><font color=blue>Figure 11.32 – The Pawn which damages the turret becomes the new EnemyTarget.</font></strong>
<p />
<strong>7.</strong>	Finally, the turret is sent to the Dead state if its health has been exhausted.
<p />
<font face=consolas>
<pre>
if(TurretHealth &#60;&#61; 0)
{
   GotoState(&#39;Dead&#39;);
}
</pre>
</font>
<p />
<strong>8.</strong>	Save the script to preserve your work. We will return briefly to this function in a subsequent tutorial.
<p />
<h2><a name="TUTORIAL 11.13 – TURRET, PART IX: GLOBAL TICK() FUNCTION"></a> TUTORIAL 11.13 – TURRET, PART IX: GLOBAL TICK() FUNCTION </h2>
<p />
The turret class’s global Tick() function is responsible for finding visible enemies for the turret to target and attack. This function exists outside of any state and is used when the turret is in the Alert or Defend states.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	Declare the Tick() function following the states declared in the previous chapter, making sure it is not inside the bodies of any of those states.
<p />
<font face=consolas>
<pre>
function Tick(Float Delta)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	The Tick() function’s main responsibility is to pick a new enemy for the turret by finding the player that is closest to the current aim of the turret. This will require calculating the dot product of the direction the turret is aiming and the direction to the player in question and comparing the result to that of each subsequent player. Two local Float variables ware used to store the current dot product and the current closest dot product.
<p />
<font face=consolas>
<pre>
local Float currDot;
local Float thisDot;
</pre>
</font>
<p />
An iterator is used to loop through all the players in the match. This requires a UTPawn local variable to hold a reference to each player in the iterator.
<p />
<font face=consolas>
<pre>
local UTPawn P;
</pre>
</font>
<p />
Finally, a local Bool is used to specify whether a new enemy was found and set as the target enabling the code to choose which state to place the turret into.
<p />
<font face=consolas>
<pre>
local Bool bHasTarget;
</pre>
</font>
<p />
The result of each dot product operation is between -1 and 1. -1 being in the exact opposite direction to where the turret is aiming and 1 being directly in the turret’s aim. The currDot is initialized to a value of -1.01 so that the result of the dot product for any player found will be higher than the initial value.
<p />
<font face=consolas>
<pre>
currDot &#61; -1.01;
</pre>
</font>
<p />
<strong>4.</strong>	An If/Else-statement is used to cause the targeting to only be performed once every 0.5 seconds and only if the turret has not been destroyed.
<p />
<font face=consolas>
<pre>
if(GElapsedTime &#62; 0.5 &#38;&#38; !bDestroyed)
{
}
else
{
}
</pre>
</font>
<p />
Inside the If block, the values of GElapsedTime and bHasTarget are reset.
<p />
<font face=consolas>
<pre>
GElapsedTime &#61; 0.0;
bHasTarget &#61; false;
</pre>
</font>
<p />
In the Else block, the value of GElapsedTime is incremented by the time passed since the last Tick() function call.
<p />
<font face=consolas>
<pre>
GElapsedTime +&#61; Delta;
</pre>
</font>
<p />
The If/Else-statement now looks like so:
<p />
<font face=consolas>
<pre>
if(GElapsedTime &#62; 0.5 &#38;&#38; !bDestroyed)
{
   GElapsedTime &#61; 0.0;
   bHasTarget &#61; false;
}
else
{
   GElapsedTime +&#61; Delta;
}
</pre>
</font>
<p />
<strong>5.</strong>	Back in the If Block, the AllPawns iterator function is used to loop through all the UTPawns within the match currently.
<p />
<font face=consolas>
<pre>
foreach WorldInfo.AllPawns(class&#39;UTGame.UTPawn&#39;,P)
{
}
</pre>
</font>
<p />
<strong>6.</strong>	As the condition to an If-statement within the iterator, a simple trace is performed to determine if the turret has line of sight to the current pawn using the FastTrace() function available to all Actors. This function returns True is no world geometry was encountered when tracing to the end location from the start location.
<p />
<font face=consolas>
<pre>
if(FastTrace(P.Location,FireLocation))
{
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_033.jpg"/><br/> <strong><font color=blue>Figure 11.33 – Only the visible Pawns pass the FastTrace() check.</font></strong>
<p />
<strong>7.</strong>	If the trace is successful, the dot product between the direction the turret is aiming and the direction from the turret’s muzzle to the current pawn is calculated.
<p />
<font face=consolas>
<pre>
thisDot &#61; Normal(Vector(PivotController.BoneRotation)) Dot
Normal(((P.Location - FireLocation) &#60;&#60; Rotation));
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_034.jpg"/><br/> <strong><font color=blue>Figure 11.34 – The dot product calculates the amount to which the turret is facing the prospective target.</font></strong>
<p />
<strong>8.</strong>	Assuming the pawn is alive, or has a Health value greater than 0, and the dot product we just calculated is greater than or equal to the currDot value, the current pawn is set as the turret’s EnemyTarget, the currDot is set to this dot product, and bHasTarget is set to True as at least one target has been located.
<p />
<font face=consolas>
<pre>
if(P.Health &#62; 0 &#38;&#38; thisDot &#62;&#61; currDot)
{
   EnemyTarget &#61; P;
   currDot &#61; thisDot;
   bHasTarget &#61; true;
}
</pre>
</font>
<p />
<strong>9.</strong>	After the iterator, the turret is directed into the appropriate state based on the outcome of the targeting routine. If a target was found and the turret is not currently in the Defend state, it is placed into that state. Otherwise, if no target was found and the turret is currently in the Defend state, it is sent to the Alert state instead. All other conditions are ignored as the turret is already in the appropriate state.
<p />
<font face=consolas>
<pre>
if(bHasTarget &#38;&#38; !IsInState(&#39;Defend&#39;))
{
   GotoState(&#39;Defend&#39;);
}
else if(!bHasTarget &#38;&#38; IsInState(&#39;Defend&#39;))
{
   GotoState(&#39;Alert&#39;);
}
</pre>
</font>
<p />
<strong>10.</strong>	Save the script to preserve your work. The final Tick() function should now be:
<p />
<font face=consolas>
<pre>
function Tick(Float Delta)
{
   local Float currDot;
   local Float thisDot;
   local UTPawn P;
   local Bool bHasTarget;

   currDot &#61; -1.01;

   if(GElapsedTime &#62; 0.5 &#38;&#38; !bDestroyed)
   {
      GElapsedTime &#61; 0.0;
      bHasTarget &#61; false;

      foreach WorldInfo.AllPawns(class&#39;UTGame.UTPawn&#39;,P)
      {
         if(FastTrace(P.Location,FireLocation))
         {
            thisDot &#61; Normal(Vector(PivotController.BoneRotation)) Dot
               Normal(((P.Location - FireLocation) &#60;&#60; Rotation));
            if(P.Health &#62; 0 &#38;&#38; thisDot &#62;&#61; currDot)
            {
               EnemyTarget &#61; P;
               currDot &#61; thisDot;
               bHasTarget &#61; true;
            }
         }
      }

      if(bHasTarget &#38;&#38; !IsInState(&#39;Defend&#39;))
      {
         GotoState(&#39;Defend&#39;);
      }
      else if(!bHasTarget &#38;&#38; IsInState(&#39;Defend&#39;))
      {
         GotoState(&#39;Alert&#39;);
      }
   }
   else
   {
      GElapsedTime +&#61; Delta;
   }
}
</pre>
</font>
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.14 – TURRET, PART X: IDLE STATE BODY"></a> TUTORIAL 11.14 – TURRET, PART X: IDLE STATE BODY </h2>
<p />
As mentioned in a previous tutorial, the Idle state is the default state for the turret. Its only real concerns are rotating the turret to the sleeping position, locating moving enemies within its peripheral vision, and placing the turret into the Alert state should it be damaged.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	Inside the Idle state, the TakeDamage() event is overridden, but we want to still include all of the functionality of the global version. Essentially, we want to append a small piece of code to the existing TakeDamage() event of the turret class that applies only when the turret is in the Idle state. Obviously, we could simply copy the entire event into the state and add what is needed, but UnrealScript provides the ability to call the global version of the function or event from within the state which will save us from having to duplicate code uselessly. Declare the TakeDamage() event in the Idle state.
<p />
<font face=consolas>
<pre>
event TakeDamage(   int Damage,
       Controller InstigatedBy,
       vector HitLocation,
       vector Momentum,
       class&#60;DamageType&#62; DamageType,
       optional TraceHitInfo HitInfo,
       optional Actor DamageCauser   )
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Using the Global keyword, immediately call the global version of the TakeDamage() event passing all of the parameters straight through.
<p />
<font face=consolas>
<pre>
Global.TakeDamage(Damage,InstigatedBy,HitLocation,Momentum,DamageType,HitInfo,DamageCauser);
</pre>
</font>
<p />
<strong>4.</strong>	Now, add an If-statement that places the turret into the Alert state as long as the turret has not been destroyed by the current damage being applied. All this code really does is place the turret in the Alert state if it manages to get shot or damaged without having an enemy targeted, i.e. if a player was able to sneak up behind it and shoot it, the turret would awaken and start actively searching for any visible enemy instead of only in its current periphery.
<p />
<font face=consolas>
<pre>
if(TurretHealth &#62; 0)
{
   GotoState(&#39;Alert&#39;);
}
</pre>
</font>
<p />
<strong>5.</strong>	The Tick() event is overridden in the Idle state as well, but must actually alter the existing version instead of appending to code onto it. While the global version seeks out all visible enemies, the Idle state’s version will only seek out moving enemies within its peripheral vision, defined here as having a dot product greater than or equal to 0.0. This requires only a slight modification to the existing Tick() event’s code so copy the global Tick() event in to the Idle state’s body.
<p />
<font face=consolas>
<pre>
function Tick(Float Delta)
{
   local Float currDot,thisDot;
   local UTPawn P;
   local Bool bHasTarget;

   currDot &#61; -1.01;

   if(GElapsedTime &#62; 0.5 &#38;&#38; !bDestroyed)
   {
      GElapsedTime &#61; 0.0;
      bHasTarget &#61; false;

      foreach WorldInfo.AllPawns(class&#39;UTGame.UTPawn&#39;,P)
      {
         if(FastTrace(P.Location,FireLocation))
         {
            thisDot &#61; Normal(Vector(PivotController.BoneRotation)) Dot
               Normal(((P.Location - FireLocation) &#60;&#60; Rotation));
            if(P.Health &#62; 0 &#38;&#38; thisDot &#62;&#61; currDot)
            {
               EnemyTarget &#61; P;
               currDot &#61; thisDot;
               bHasTarget &#61; true;
            }
         }
      }

      if(bHasTarget &#38;&#38; !IsInState(&#39;Defend&#39;))
      {
         GotoState(&#39;Defend&#39;);
      }
      else if(!bHasTarget &#38;&#38; IsInState(&#39;Defend&#39;))
      {
         GotoState(&#39;Alert&#39;);
      }
   }
   else
   {
      GElapsedTime +&#61; Delta;
   }
}
</pre>
</font>
<p />
<strong>6.</strong>	Modify the innermost If-statement’s condition to require the speed of the pawn to be greater than 16.0 units per second and also require the dot product to be greater than or equal to 0.0.
<p />
<font face=consolas>
<pre>
if(P.Health &#62; 0 &#38;&#38; VSize(P.Velocity) &#62; 16.0 &#38;&#38; thisDot &#62;&#61; 0.0 &#38;&#38; thisDot &#62;&#61; currDot)
{
   EnemyTarget &#61; P;
   currDot &#61; thisDot;
   bHasTarget &#61; true;
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_035.jpg"/><br/> <strong><font color=blue>Figure 11.35 – Only Pawns in front of the turret are considered as potential targets.</font></strong>
<p />
<strong>7.</strong>	A new function is declared in the Idle state named BeginIdling(). This function must be able to be called as a timer so it has no parameters. Its job is to begin the interpolation to the idle pose and play the SleepSound SoundCue.
<p />
<font face=consolas>
<pre>
function BeginIdling()
{
}
</pre>
</font>
<p />
<strong>8.</strong>	The interpolation to the idle pose is performed by calling the DoRotation() function belonging to the turret class and passing it the IdleRotation property of the TurretRotations struct and a duration of 1.0 seconds.
<p />
<font face=consolas>
<pre>
DoRotation(TurretRotations.IdleRotation, 1.0);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_036.jpg"/><br/> <strong><font color=blue>Figure 11.36 – The turret rotates to the Idle position.</font></strong>
<p />
<strong>9.</strong>	If the SleepSound property of the TurretSounds struct references a SoundCue, it is played using the PlaySound() function.
<p />
<font face=consolas>
<pre>
if(TurretSounds.SleepSound !&#61; None)
   PlaySound(TurretSounds.SleepSound);
</pre>
</font>
<p />
<strong>10.</strong>	As you have learned already, the BeginState() event is executed when the state is made active. In the Idle state, this event starts the interpolation to the alert pose if necessary and calls the BeginIdling() function to place the turret in the idle pose and play the SleepSound SoundCue assuming one is specified. Declare the BeginState() event with its one parameter PreviousStateName.
<p />
<font face=consolas>
<pre>
event BeginState(Name PreviousStateName)
{
}
</pre>
</font>
<p />
<strong>11.</strong>	First, if the previous state was anything other than the Alert state, the turret should interpolate to the alert pose before beginning the interpolation to the idle pose. This is simply the chosen behavior as it seemed reasonable that the turret would always follow the same progression of idle-alert-firing-alert-idle. Since the interpolation takes 1.0 second, the BeginIdling() function is called as a non-looping timer with a rate of 1.0 seconds.
<p />
<font face=consolas>
<pre>
if(PreviousStateName !&#61; &#39;Alert&#39;)
{
   DoRotation(TurretRotations.AlertRotation, 1.0);
   SetTimer(1.0,false,&#39;BeginIdling&#39;);
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_037.jpg"/><br/> <strong><font color=blue>Figure 11.37 – The turret first rotates to the Alert position before proceeding to the Idle position.</font></strong>
<p />
<strong>12.</strong>	If the previous state was any other state, the BeginIdling() function is simply called straight away.
<p />
<font face=consolas>
<pre>
else
   BeginIdling();
</pre>
</font>
<p />
<strong>13.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.15 – TURRET, PART XI: ALERT STATE BODY PART I"></a> TUTORIAL 11.15 – TURRET, PART XI: ALERT STATE BODY PART I </h2>
<p />
If the Idle state is like DEFCON 5 for the turret, then the Alert state is somewhere around DEFCON 3. The turret is by no means in attack mode, but this is most certainly an increased state of readiness. In the Alert stat, the turret is now scanning the area and actively searching for any visible enemies: moving or not. In this tutorial, the Tick() and IdleTimer() functions will be set up.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	The Tick() function is overridden in the Alert state to append a small chunk of code onto the global Tick() function of the turret class. This chunk of code will cause the turret to scan the area by animating its rotation. Declare the Tick() function in the Alert state.
<p />
<font face=consolas>
<pre>
function Tick(Float Delta)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	A local Rotator is needed in this Tick() function. This rotation is the amount of rotation to be added to the turret’s current rotation each tick to animate the turret scanning the area.
<p />
<font face=consolas>
<pre>
local Rotator AnimRot;
</pre>
</font>
<p />
<strong>4.</strong>	Before any other code in this function is executed, the global version of the Tick() function is called.
<p />
<font face=consolas>
<pre>
Global.Tick(Delta);
</pre>
</font>
<p />
<strong>5.</strong>	The Yaw property of the AnimRot is calculated by multiplying the MinTurretRotRate by the time passed since the last tick, or Delta. Then, this Rotator is added to the turret’s rotation specified as the BoneRotation property of the PivotController.
<p />
<font face=consolas>
<pre>
AnimRot.Yaw &#61; MinTurretRotRate &#42; Delta;
PivotController.BoneRotation +&#61; AnimRot;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_038.jpg"/><br/> <strong><font color=blue>Figure 11.38 – The turret scans the area by rotating around the Yaw axis of the pivot.</font></strong>
<p />
<strong>6.</strong>	The final piece of the Tick() function is to account for any rotation limiting according to the RotLimit struct. If the blimitYaw property is True and the Yaw of the current rotation is outside the limits set in the RotLimitMin and RotLimitMax Rotators, the MinTurretRotrate value is multiplied by -1 to reverse the direction of the turret’s rotation.
<p />
<font face=consolas>
<pre>
if(RotLimit.bLimitYaw)
{
   if(   PivotController.BoneRotation.Yaw &#62;&#61; RotLimit.RotLimitMax.Yaw    &#124;&#124;
      PivotController.BoneRotation.Yaw &#60;&#61; RotLimit.RotLimitMin.Yaw   )
   {
      MinTurretRotRate &#42;&#61; -1;
   }
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_039.jpg"/><br/> <strong><font color=blue>Figure 11.39 – The scanning rotation is now limited causing it to alternate back and forth.</font></strong>
<p />
<strong>7.</strong>	The IdleTimer() function is a simple timer function that is declared with no parameters.
<p />
<font face=consolas>
<pre>
function IdleTimer()
{
}
</pre>
</font>
<p />
<strong>8.</strong>	This function’s sole purpose is to place the turret back into the Idle state if it has not been destroyed.
<p />
<font face=consolas>
<pre>
if(!bDestroyed)
{
   GotoState(&#39;Idle&#39;);
}
</pre>
</font>
<p />
<strong>9.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.16 – TURRET, PART XII: ALERT STATE BODY PART II"></a> TUTORIAL 11.16 – TURRET, PART XII: ALERT STATE BODY PART II </h2>
<p />
Continuing with the Alert state, the BeginState() event handles initializing the turret for the Alert. Though it provides the ability to perform separate actions based on the previous state by means of the PreviousStateName parameter, the initialization of the Alert state will be the same regardless of which state the turret is leaving. This function will place the turret into the appropriate pose to begin scanning the area and calculate the amount of time necessary to do a thorough sweep as well as determine which direction the turret should begin rotating to perform the sweep.
<p />
<strong>1.</strong>	Open ContEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	Declare the BeginState() event for the Alert state.
<p />
<font face=consolas>
<pre>
event BeginState(Name PreviousStateName)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	This event needs two local variables. The first is a Rotator to hold the initial rotation the sweep should begin from. This rotation is the rotation specified in the AlertRotation property of the TurretRotations struct with its Yaw value substituted with the current Yaw of the turret. The other local variable is a Float value representing the amount of total time the turret’s sweep of the area will last.
<p />
<font face=consolas>
<pre>
local Rotator AlertRot;
local Float RevTime;
</pre>
</font>
<p />
<strong>4.</strong>	The AlertRot rotation is first assigned the value of the AlertRotation. Then its Yaw value is replaced with the current Yaw of the turret normalized to the range of 0 to 65536, removing any full revolutions that may have been performed up to this point.
<p />
<font face=consolas>
<pre>
AlertRot &#61; TurretRotations.AlertRotation;
AlertRot.Yaw &#61; PivotController.BoneRotation.Yaw &#37; 65536;
</pre>
</font>
<p />
<strong>5.</strong>	One of two paths is taken at this point depending on whether the turret’s Yaw rotation is limited. If the Yaw is limited, determined by the bLimitYaw property of the RotLimit struct, the limits must be taken into account when calculating the total time to perform a sweep of the area. This sweep will consist of panning from the current yaw to the far limit, back to the near limit and then to the Yaw specified by the AlertRotation. First, set up the If-statement.
<p />
<font face=consolas>
<pre>
if(RotLimit.bLimitYaw)
{
}
else
{
}
</pre>
</font>
<p />
<strong>6.</strong>	Inside the If block, another If-statement checks to see which limit is farther by comparing the current Yaw value to the midpoint of the Yaw rotation limits.
<p />
<font face=consolas>
<pre>
if(AlertRot.Yaw &#62; Float(RotLimit.RotLimitMax.Yaw + RotLimit.RotLimitMin.Yaw) / 2.0)
{
}
else
{
}
</pre>
</font>
<p />
The time it takes to make the full sweep given the current rotation of the turret is calculated by taking the difference between the far limit and the current rotation and dividing that value by the original minimum rotation rate of the turret. Then the amount of time it takes to make one complete sweep from the minimum limit to the maximum limit is calculate using the same method and added to the previous calculation. Finally, the time to pan from the far limit to the AlertRotation is calculated and added to the overall result. This value is assigned to the RevTime variable in each of the If/Else blocks. The only differences in the calculations are that the limits are reversed and the order of the subtraction operands is reversed.
<p />
<font face=consolas>
<pre>
if(AlertRot.Yaw &#62; Float(RotLimit.RotLimitMax.Yaw + RotLimit.RotLimitMin.Yaw) / 2.0)
{
   RevTime &#61; (Float(AlertRot.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate)) +
      (Float(RotLimit.RotLimitMax.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate)) +
      (Float(RotLimit.RotLimitMax.Yaw - TurretRotations.AlertRotation.Yaw) / Float(OrigMinRotRate));
}
else
{
   RevTime &#61; (Float(RotLimit.RotLimitMax.Yaw - AlertRot.Yaw) / Float(OrigMinRotRate)) +
      (Float(RotLimit.RotLimitMax.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate)) +
      (Float(TurretRotations.AlertRotation.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate));
}
</pre>
</font>
<p />
The MinTurretRotRate is set to either the OrrigTurretRotRate or the OrigTurretRotRate multiplied by -1 depending on which way the turret needs to rotate to begin with.
<p />
<font face=consolas>
<pre>
if(AlertRot.Yaw &#62; Float(RotLimit.RotLimitMax.Yaw + RotLimit.RotLimitMin.Yaw) / 2.0)
{
   RevTime &#61; (Float(AlertRot.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate)) +
      (Float(RotLimit.RotLimitMax.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate)) +
      (Float(RotLimit.RotLimitMax.Yaw - TurretRotations.AlertRotation.Yaw) / Float(OrigMinRotRate));

   MinTurretRotRate &#61; -1 &#42; OrigMinRotRate;
}
else
{
   RevTime &#61; (Float(RotLimit.RotLimitMax.Yaw - AlertRot.Yaw) / Float(OrigMinRotRate)) +
      (Float(RotLimit.RotLimitMax.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate)) +
      (Float(TurretRotations.AlertRotation.Yaw - RotLimit.RotLimitMin.Yaw) / Float(OrigMinRotRate));

   MinTurretRotRate &#61; OrigMinRotRate;
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_040.jpg"/><br/> <strong><font color=blue>Figure 11.40 – One potential scanning motion of the Yaw-limited turret.</font></strong>
<p />
<strong>7.</strong>	The main Else block in the BeginAlert() function is much more straightforward because no limits are being imposed. In this situation, the turret will rotate the long way around from its current rotation back to the AlertRotation. First off, the RevTime is initialized with the FullRevTime value.
<p />
<font face=consolas>
<pre>
RevTime &#61; FullRevTime;
</pre>
</font>
<p />
Next, the current rotation is compared to the AlertRotation to determine which direction the turret needs to rotate. Half a revolution is added to the AlertRotation’s Yaw property. By checking the current rotation against that value, the turret can be narrowed down to facing one hemisphere or the other.
<p />
<font face=consolas>
<pre>
if(AlertRot.Yaw &#62; (TurretRotations.AlertRotation.Yaw + 32768))
{
}
else
{
}
</pre>
</font>
<p />
The amount of time to be removed from the full revolution time is calculated by taking the difference between the current rotation and either the AlertRotation or one full revolution from the AlertRotation. That value is then divided by the OrigTurretRotRate. The subtractions in these calculations should be performed in an order such that the results are negative values as the point of the calculations is to find the portion of the full revolution that needs to be omitted based on the current rotation.
<p />
<font face=consolas>
<pre>
if(AlertRot.Yaw &#62; (TurretRotations.AlertRotation.Yaw + 32768))
{
   RevTime +&#61; Float(AlertRot.Yaw - (TurretRotations.AlertRotation.Yaw + 65536)) /
         Float(OrigMinRotRate);
}
else
{
   RevTime +&#61; Float(TurretRotations.AlertRotation.Yaw - AlertRot.Yaw) /
         Float(OrigMinRotRate);
}
</pre>
</font>
<p />
The MinTurretRotRate value is set just as in the previous step.
<p />
<font face=consolas>
<pre>
if(AlertRot.Yaw &#62; (TurretRotations.AlertRotation.Yaw + 32768))
{
   RevTime +&#61; Float(AlertRot.Yaw - (TurretRotations.AlertRotation.Yaw + 65536)) /
         Float(OrigMinRotRate);

   MinTurretRotRate &#61; -1 &#42; OrigMinRotRate;
}
else
{
   RevTime +&#61; Float(TurretRotations.AlertRotation.Yaw - AlertRot.Yaw) /
         Float(OrigMinRotRate);

   MinTurretRotRate &#61; OrigMinRotRate;
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_041.jpg"/><br/> <strong><font color=blue>Figure 11.41 – One potential scanning motion of the non-limited turret.</font></strong>
<p />
<strong>8.</strong>	After the RevTime and MinTurretRotrate have been set by one of these four routines, a timer is set outside of all the If-statements to run the IdleTimer() function. The rate of the timer is the RevTime + 1.0 seconds to account for the initial rotation to the AlertRot pose.
<p />
<font face=consolas>
<pre>
SetTimer(RevTime + 1.0,false,&#39;Idletimer&#39;);
</pre>
</font>
<p />
<strong>9.</strong>	Once the timer has been set, an interpolation to the AlertRot is started by using the DoRotation() function.
<p />
<font face=consolas>
<pre>
DoRotation(AlertRot, 1.0);
</pre>
</font>
<p />
<strong>10.</strong>	Finally, the WakeSound SoundCue is played if one has been specified.
<p />
<font face=consolas>
<pre>
if(TurretSounds.WakeSound !&#61; None)
   PlaySound(TurretSounds.WakeSound);
</pre>
</font>
<p />
<strong>11.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.17 – TURRET, PART XIII: DEFEND STATE BODY PART I"></a> TUTORIAL 11.17 – TURRET, PART XIII: DEFEND STATE BODY PART I </h2>
<p />
The firing functionality of the turret is handled by two functions. The first function named TimedFire() spawns the projectile, activates the muzzle flash, and plays the firing sound. The second function named StopMuzzleFlash() simply deactivates the muzzle flash as you might expect from the name. The creation of these two function is covered in this tutorial.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	The StopMuzzeFlash() function is extremely simple so we begin with it. Declare this function inside the body of the Defend state with no parameters.
<p />
<font face=consolas>
<pre>
function StopMuzzleFlash()
{
}
</pre>
</font>
<p />
<strong>3.</strong>	The muzzle flash particle system is stopped by calling the DeactivateSystem() function of the ParticleSystemComponent. This is the entire body of the StopMuzzleFlash() function.
<p />
<font face=consolas>
<pre>
MuzzleFlashEffect.DeactivateSystem();
</pre>
</font>
<p />
<strong>4.</strong>	The TimedFire() function is a timer function that will be set to loop when the turret begins the Defend state and will be cleared when the turret leaves the Defend state. Declare this function now.
<p />
<font face=consolas>
<pre>
function TimedFire()
{
}
</pre>
</font>
<p />
<strong>5.</strong>	A local Projectile variable is needed to reference the spawned projectile.
<p />
<font face=consolas>
<pre>
local Projectile Proj;
</pre>
</font>
<p />
<strong>6.</strong>	The projectile is spawned using the class specified in the ProjClass variable at the FireLocation using the orientation obtained from the FireRotation variable and assigned to the Proj local variable.
<p />
<font face=consolas>
<pre>
Proj &#61; Spawn(ProjClass,self,,FireLocation,FireRotation,,True);
</pre>
</font>
<p />
<strong>7.</strong>	If the spawn was successful and the projectile is not about to be deleted, the Init() function of the projectile is called passing it the direction the projectile should be traveling. This function sets the rotation of the projectile according by casting the direction Vector passed to the function and initializes its Velocity accordingly.
<p />
<font face=consolas>
<pre>
if( Proj !&#61; None &#38;&#38; !Proj.bDeleteMe )
{
   Proj.Init(Vector(FireRotation));
}
</pre>
</font>
<p />
Note: This code was borrowed directly from one of the existing UT3 weapon classes. It is always a good idea to use similar existing classes as models when writing new code.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_042.jpg"/><br/> <strong><font color=blue>Figure 11.42 – The projectile is spawned and initialized with velocity in the direction the turret is aiming.</font></strong>
<p />
<strong>8.</strong>	Next, the muzzle flash is activated and a timer to shut off the muzzle flash is started assuming a muzzle flash emitter is specified.
<p />
<font face=consolas>
<pre>
if(TurretEmitters.MuzzleFlashEmitter !&#61; None)
{
   MuzzleFlashEffect.ActivateSystem();
   SetTimer(TurretEmitters.MuzzleFlashDuration,false,&#39;StopMuzzleFlash&#39;);
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_043.jpg"/><br/> <strong><font color=blue>Figure 11.43 – When activated, the muzzle flash effect becomes visible.</font></strong>
<p />
<strong>9.</strong>	Finally, the firing sound is played if specified by the designer.
<p />
<font face=consolas>
<pre>
if(TurretSounds.FireSound !&#61; None)
   PlaySound(TurretSounds.FireSound);
</pre>
</font>
<p />
<strong>10.</strong>	The BeginFire() function is a timer function that starts the firing process by setting a looping timer for the TimedFire() function and enables the targeting process by toggling the bCanFire variable. Declare this function.
<p />
<font face=consolas>
<pre>
function BeginFire()
{
}
</pre>
</font>
<p />
<strong>11.</strong>	If the value of RoundsPerSec is greater than 0, the TimedFire() function is set to execute with a rate calculated as the inverse of the RoundsPerSec property and set to loop. Also, the bCanFire property is set to True.
<p />
<font face=consolas>
<pre>
if(RoundsPerSec &#62; 0)
{
   SetTimer(1.0/RoundsPerSec,true,&#39;TimedFire&#39;);
   bCanFire &#61; true;
}
</pre>
</font>
<p />
<strong>12.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.18 – TURRET, PART XIV: DEFEND STATE BODY PART II"></a> TUTORIAL 11.18 – TURRET, PART XIV: DEFEND STATE BODY PART II </h2>
<p />
Continuing with the Defend state, the BeginState() and EndState() events are declared to initialize and terminate the Defend state.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	Declare the BeginState() event with the PreviousStateName parameter.
<p />
<font face=consolas>
<pre>
event BeginState(Name PreviousStateName)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	If the turret is entering the Defend state from the Alert state, the IdleTimer must be cleared if it is currently active to prevent the turret from inadvertently being placed into the Idle state.
<p />
<font face=consolas>
<pre>
if(PreviousStateName &#61;&#61; &#39;Alert&#39;)
{
   if(IstImerActive(&#39;IdleTimer&#39;))
      ClearTimer(&#39;IdleTimer&#39;);
}
</pre>
</font>
<p />
<strong>4.</strong>	The bCanFire property is always initially set to False to avoid any unwanted targeting actions.
<p />
<font face=consolas>
<pre>
bCanFire &#61; false;
</pre>
</font>
<p />
<strong>5.</strong>	Also in the BeginState() event, the FireLocation and FireRotation properties are initialized with the current location and rotation of the socket located at the muzzle tip by calling the GetSocketWorldLocationAndRotation() function of the SkeletalMeshComponent and passing it the two variables.
<p />
<font face=consolas>
<pre>
Mesh.GetSocketWorldLocationAndRotation(TurretBones.FireSocket,FireLocation,FireRotation);
</pre>
</font>
<p />
<strong>6.</strong>	Next, the turret interpolates to face the current enemy using the DoRotation() function.
<p />
<font face=consolas>
<pre>
DoRotation(Rotator((EnemyTarget.Location - FireLocation) &#60;&#60; Rotation), 1.0);
</pre>
</font>
<p />
The calculation below takes the vector from the muzzle tip to the enemy and transforms that into world space. Then, the resulting Vecotr is cast to a Rotator to get the rotation necessary to cause the turret to point at the enemy.
<p />
<font face=consolas>
<pre>
Rotator((EnemyTarget.Location - FireLocation) &#60;&#60; Rotation)
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_044.jpg"/><br/> <strong><font color=blue>Figure 11.44 – The turret is rotated to face the EnemyTarget.</font></strong>
<p />
<strong>7.</strong>	The SpinUpSound is played if one has been specified by the designer
<p />
<font face=consolas>
<pre>
if(TurretSounds.SpinUpsound !&#61; None)
   PlaySound(TurretSounds.SpinUpSound);
</pre>
</font>
<p />
<strong>8.</strong>	The final step in the BeginState() event is to start a timer to execute the BeginFire() function after 1.0 second has passed. This allows the turret to complete the rotation interpolation before any targeting of firing begins.
<p />
<font face=consolas>
<pre>
SetTimer(1.0,false,&#39;BeginFire&#39;);
</pre>
</font>
<p />
<strong>9.</strong>	The EndState() event is very similar to the BeginState() event in its declaration as it has only a single Name parameter.
<p />
<font face=consolas>
<pre>
event EndState(Name NewStateName)
{
}
</pre>
</font>
<p />
<strong>10.</strong>	The sole purpose of this event in the Defend state is to clear the TimedFire() timer to stop the turret from firing.
<p />
<font face=consolas>
<pre>
ClearTimer(&#39;TimedFire&#39;);
</pre>
</font>
<p />
<strong>11.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.19 – TURRET, PART XV: DEFEND STATE BODY PART III"></a> TUTORIAL 11.19 – TURRET, PART XV: DEFEND STATE BODY PART III </h2>
<p />
The final piece to the Defend state is the targeting code contained within the Tick() function of the state.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	Declare the Tick() function in the Defend state.
<p />
<font face=consolas>
<pre>
function Tick(Float Delta)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	This version of the Tick() function needs two local Rotators to perform targeting calculations with as well as a local Int.
<p />
<font face=consolas>
<pre>
local Rotator InterpRot;
local Rotator DiffRot;
local Int MaxDiffRot;
</pre>
</font>
<p />
<strong>4.</strong>	Before any new code is added, the global implementation of the Tick() function needs to be called so that the target acquisition code is still executed even though the function is being overridden.
<p />
<font face=consolas>
<pre>
Global.Tick(Delta);
</pre>
</font>
<p />
<strong>5.</strong>	The targeting code within the Tick() function is only to be executed when the turret is allowed to fire.
<p />
<font face=consolas>
<pre>
if(bCanFire)
{
}
</pre>
</font>
<p />
<strong>6.</strong>	Inside the If-statement, A direction Vector to from the turret to the enemy is calculated. This is calculated every tick to keep track of the enemy’s movement.
<p />
<font face=consolas>
<pre>
EnemyDir &#61; EnemyTarget.Location - Location;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_045.jpg"/><br/> <strong><font color=blue>Figure 11.45 – EnemyDir is the direction from the turret to the EnemyTarget.</font></strong>
<p />
<strong>7.</strong>	Next, if any of the following conditions are met, all of the targeting variables are initialized or reset.
<p /> <ul>
<li> A new enemy has been acquired
</li></ul>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_046.jpg"/><br/> <strong><font color=blue>Figure 11.46 – The turret has a new EnemyTarget.</font></strong>
<p /> <ul>
<li> The current enemy has moved
</li></ul>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_047.jpg"/><br/> <strong><font color=blue>Figure 11.47 – The turret’s EnemyTarget is on the move.</font></strong>
<p /> <ul>
<li> The current targeting interpolation has completed
</li></ul>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_048.jpg"/><br/> <strong><font color=blue>Figure 11.48 – The turret has rotated to face the stationary EnemyTarget.</font></strong>
<p />
<font face=consolas>
<pre>
if(   EnemyTarget !&#61; LastEnemyTarget    &#124;&#124;
   EnemyDir !&#61; LastEnemyDir       &#124;&#124;
   ElapsedTime &#62;&#61; TotalInterpTime   )
{
}
</pre>
</font>
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	First, the LastEnemyTarget and LastEnemyDir variables are updated with the current values.
<p />
<font face=consolas>
<pre>
LastEnemyDir &#61; EnemyDir;
LastEnemyTarget &#61; EnemyTarget;
</pre>
</font>
<p />
<strong>b.</strong>	Next, the beginning and ending rotation values for the interpolation are initialized.
<p />
<font face=consolas>
<pre>
StartRotation &#61; PivotController.BoneRotation;
TargetRotation &#61; Rotator((EnemyTarget.Location - FireLocation) &#60;&#60; Rotation);
</pre>
</font>
<p />
<strong>c.</strong>	Then, the DiffRot is calculated by taking the difference between the beginning and ending rotations. The MaxDiffRot is then calculated by finding the largest element, Pitch, Yaw, or Roll, of the resulting DiffRot. Two Max() function calls are nested to perform this calculation in a single expression.
<p />
<font face=consolas>
<pre>
DiffRot &#61; TargetRotation - StartRotation;
MaxDiffRot &#61; Max(Max(DiffRot.Pitch,DiffRot.Yaw),DiffRot.Roll);
</pre>
</font>
<p />
<strong>d.</strong>	The total time needed to interpolate to the desired rotation is calculated by dividing the MaxDiffRot by the MaxTurretRotRate and taking the absolute value of that result.
<p />
<font face=consolas>
<pre>
TotalInterpTime &#61; Abs(Float(MaxDiffRot) / Float(MaxTurretRotRate));
</pre>
</font>
<p />
<strong>e.</strong>	Finally, the ElapsedTime is set equal to the time passed since the last tick.
<p />
<font face=consolas>
<pre>
ElapsedTime &#61; Delta;
</pre>
</font>
<p />
The resulting If block:
<p />
<font face=consolas>
<pre>
if(   EnemyTarget !&#61; LastEnemyTarget    &#124;&#124;
   ElapsedTime &#62;&#61; TotalInterpTime    &#124;&#124;
   EnemyDir !&#61; LastEnemyDir      )
{
   LastEnemyDir &#61; EnemyDir;
   LastEnemyTarget &#61; EnemyTarget;
   StartRotation &#61; PivotController.BoneRotation;
   TargetRotation &#61; Rotator((EnemyTarget.Location - FireLocation) &#60;&#60; Rotation);
   DiffRot &#61; TargetRotation - StartRotation;
   MaxDiffRot &#61; Max(Max(DiffRot.Pitch,DiffRot.Yaw),DiffRot.Roll);
   TotalInterpTime &#61; Abs(Float(MaxDiffRot) / Float(MaxTurretRotRate));
   ElapsedTime &#61; Delta;
}
</pre>
</font>
</div>
<p />
<strong>8.</strong>	Otherwise, the elapsed time of the current interpolation is incremented
<p />
<font face=consolas>
<pre>
else
{
   ElapsedTime +&#61; Delta;
}
</pre>
</font>
<p />
<strong>9.</strong>	Once all the variables needed for the interpolation have been set, the current alpha for the interpolation is calculated and the interpolation is performed with the result being assigned to the InterpRot local Rotator.
<p />
<font face=consolas>
<pre>
RotationAlpha &#61; FClamp(ElapsedTime / TotalInterpTime,0.0,1.0);
InterpRot &#61; RLerp(StartRotation,TargetRotation,RotationAlpha,true);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_049.jpg"/><br/> <strong><font color=blue>Figure 11.49 – The turret is rotated a portion of the way towards the final desired rotation each tick.</font></strong>
<p />
<strong>10.</strong>	The resulting rotation is limited by any rotational limits that may be implemented by the designer.
<p />
<font face=consolas>
<pre>
if(RotLimit.bLimitPitch)
   InterpRot.Pitch &#61; Clamp(InterpRot.Pitch,
            RotLimit.RotLimitMin.Pitch,
            RotLimit.RotLimitMax.Pitch   );

if(RotLimit.bLimitYaw)
   InterpRot.Yaw &#61; Clamp(   InterpRot.Yaw,
            RotLimit.RotLimitMin.Yaw,
            RotLimit.RotLimitMax.Yaw   );

if(RotLimit.bLimitRoll)
   InterpRot.Roll &#61; Clamp(   InterpRot.Roll,
            RotLimit.RotLimitMin.Roll,
            RotLimit.RotLimitMax.Roll   );
</pre>
</font>
<p />
<strong>11.</strong>	The final interpolated rotation is assigned to the PivotController’s BoneRotation to update te turret.
<p />
<font face=consolas>
<pre>
PivotController.BoneRotation &#61; InterpRot;
</pre>
</font>
<p />
<strong>12.</strong>	The firing location and rotation variables are updated with the new orientation of the turret.
<p />
<font face=consolas>
<pre>
Mesh.GetSocketWorldLocationAndRotation(TurretBones.FireSocket,FireLocation,FireRotation);
</pre>
</font>
<p />
<strong>13.</strong>	Finally, the new firing rotation is adjusted with a random aim error.
<p />
<font face=consolas>
<pre>
FireRotation.Pitch +&#61; Rand(AimRotError &#42; 2) - AimRotError;
FireRotation.Yaw +&#61; Rand(AimRotError &#42; 2) - AimRotError;
FireRotation.Roll +&#61; Rand(AimRotError &#42; 2) - AimRotError;
</pre>
</font>
<p />
A random integer between 0 and twice the AimRotError value is calculated. The resulting value is then offset by the AimRotError, effectively producing a random value between –AimRotError and AimRotError. This random value is added to each component of the FireRotation.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_050.jpg"/><br/> <strong><font color=blue>Figure 11.50 – The variation in the trajectories of these projectiles is due to the turret’s aim being randomly offset.</font></strong>
<p />
<strong>14.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.20 – TURRET, PART XVI: DEAD STATE BODY"></a> TUTORIAL 11.20 – TURRET, PART XVI: DEAD STATE BODY </h2>
<p />
The final state belonging to the turret class is the Dead state. This state is responsible for performing all destruction effects as well as making sure no more target acquisition or damage functionality is performed.
<p />
<strong>1.</strong>	Open ConTEXT and the MU_AutoTurret.uc script.
<p />
<strong>2.</strong>	The Tick() and TakeDamage() functions are going to be ignored in this state so they will no longer be executed .
<p />
<font face=consolas>
<pre>
ignores Tick, TakeDamage;
</pre>
</font>
<p />
<strong>3.</strong>	The PlayDeath() function is a timer function that handles the playing of the destruction effects.
<p />
<font face=consolas>
<pre>
function PlayDeath()
{
}
</pre>
</font>
<p />
<strong>4.</strong>	In the PlayDeath() function, the destroy particle effect is played if one has been set by the designer
<p />
<font face=consolas>
<pre>
if(TurretEmitters.DestroyEmitter !&#61; None)
   DestroyEffect.ActivateSystem();
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_051.jpg"/><br/> <strong><font color=blue>Figure 11.51 – The default destruction effect being activated.</font></strong>
<p />
<strong>5.</strong>	The death sound is slap played if one exists.
<p />
<font face=consolas>
<pre>
if(TurretSounds.DeathSound !&#61; None)
   PlaySound(TurretSounds.DeathSound);
</pre>
</font>
<p />
<strong>6.</strong>	The DestroyedMesh is set as the new skeletal mesh of the turret if one has been chosen by the designer.
<p />
<font face=consolas>
<pre>
if(DestroyedMesh !&#61; None)
   Mesh.SetSkeletalMesh(DestroyedMesh);
</pre>
</font>
<p />
<strong>7.</strong>	Lastly, the damage particle effect is deactivated if bStopDamageEmmiterOnDeath has been set.
<p />
<font face=consolas>
<pre>
if(TurretEmitters.bStopDamageEmitterOnDeath)
   DamageEffect.DeactivateSystem();
</pre>
</font>
<p />
<strong>8.</strong>	In the event that the bRandomDeath variable has been set to True, the turret must create a random rotation taking any rotational limits into account and interpolate to that rotation. The DoRandomDeath() function handles this functionality.
<p />
<font face=consolas>
<pre>
function DoRandomDeath()
{
}
</pre>
</font>
<p />
<strong>9.</strong>	A local Rotator named DeathRot is used to hold the random rotation.
<p />
<font face=consolas>
<pre>
local Rotator DeathRot;
</pre>
</font>
<p />
<strong>10.</strong>	The RotRand() function is used to calculate a random rotation. A value of True is passed to the function to include the Roll component. The resulting rotation is assigned to the DeathRot variable.
<p />
<font face=consolas>
<pre>
DeathRot &#61; RotRand(true);
</pre>
</font>
<p />
<strong>11.</strong>	The components of the new rotation are then clamped according to any rotational limits that have been set.
<p />
<font face=consolas>
<pre>
if(RotLimit.bLimitPitch)
   DeathRot.Pitch &#61; Clamp(   DeathRot.Pitch,
            RotLimit.RotLimitMin.Pitch,
            RotLimit.RotLimitMax.Pitch   );
if(RotLimit.bLimitYaw)
   DeathRot.Yaw &#61; Clamp(   DeathRot.Yaw,
            RotLimit.RotLimitMin.Yaw,
            RotLimit.RotLimitMax.Yaw   );
if(RotLimit.bLimitRoll)
   DeathRot.Roll &#61; Clamp(   DeathRot.Roll,
            RotLimit.RotLimitMin.Roll,
            RotLimit.RotLimitMax.Roll   );
</pre>
</font>
<p />
<strong>12.</strong>	Finally, the DoRotation() function is called passing it the limited DeathRot to interpolate the turret to the new rotation.
<p />
<font face=consolas>
<pre>
DoRotation(DeathRot, 1.0);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_052.jpg"/><br/> <strong><font color=blue>Figure 11.52 – The turret assumes a random rotation.</font></strong>
<p />
<strong>13.</strong>	The BeginState() event is used in the Dead state to initiate the previous two functions.
<p />
<font face=consolas>
<pre>
event BeginState(Name PreviousSateName)
{
}
</pre>
</font>
<p />
<strong>14.</strong>	First, the bDestroyed variable is set to identify the turret as having been destroyed.
<p />
<font face=consolas>
<pre>
bDestroyed &#61; true;
</pre>
</font>
<p />
<strong>15.</strong>	If a random death rotation is not to be used, the DoRotation() function is called passing it the DeathRotation specified in the TurretRotations struct.
<p />
<font face=consolas>
<pre>
if(!TurretRotations.bRandomDeath)
   DoRotation(TurretRotations.DeathRotation, 1.0);
</pre>
</font>
<p />
Otherwise, the DoRandomDeath() function is called.
<p />
<font face=consolas>
<pre>
else
   DoRandomDeath();
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_053.jpg"/><br/> <strong><font color=blue>Figure 11.53 – The turret rotates to the DeathRotation.</font></strong>
<p />
<strong>16.</strong>	Then, a timer is set to execute the PlayDeath() function after the interpolation to the new rotation has completed.
<p />
<font face=consolas>
<pre>
SetTimer(1.0,false,&#39;PlayDeath&#39;);
</pre>
</font>
<p />
<strong>17.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.21 TURRET, PART XVII – COMPILING AND TESTING"></a> TUTORIAL 11.21 TURRET, PART XVII – COMPILING AND TESTING </h2>
<p />
With all the code for the turret in place, the script can now be compiled and tested inside of UnrealEd.
<p />
<strong>1.</strong>	Copy the TurretContent.upk file provided on the DVD with the files for this chapter to the Unpublished\CookedPC directory
<p />
<strong>2.</strong>	Compile the scripts and fix any syntax errors that may be present.
<p />
<strong>3.</strong>	Open UnrealEd and the DM-CH_11_Turret.ut3 map provided with the files for this chapter. This map may look familiar as it is a slightly modified version of the test map that has been used extensively throughout the book.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_054.jpg"/><br/> <strong><font color=blue>Figure 11.54 – The DM-CH_11_Turret map.</font></strong>
<p />
<strong>4.</strong>	Open the Generic Browser and go to the Actor Classes tab. Expand the Pawn section and choose MU_AutoTurret from the list.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_055.jpg"/><br/> <strong><font color=blue>Figure 11.55 – The MU_AutoTurret class in the Actor Browser.</font></strong>
<p />
<strong>5.</strong>	Right-click in the perspective viewport and choose Add MU_AutoTurret Here. The turret actor should appear in the map. Rotate the turret 180 degrees around the X-axis, or by adjusting the Movement-&gt;Rotation-&gt;Roll property in the Properties Window, so the turret is upside down. Position it on the ceiling of the room with the 3 PlayerStarts near the back of the room.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_056.jpg"/><br/> <strong><font color=blue>Figure 11.56 – The turret actor is positioned in the map.</font></strong>
<p />
<strong>6.</strong>	With the turret actor selected, press F4 to open the Properties Window. Expand the Turret category to view the editable properties. Feel free to make any adjustments you wish to make, though the defaults should work fine for initial testing purposes.
<p />
<strong>7.</strong>	Rebuild the map by pressing the Rebuild All button on the toolbar. Then right-click in the adjacent empty room and choose Play From Here.
<p />
<strong>8.</strong>	Open the console by pressing Tab and enter ‘ghost’ to allow you to fly through the map and avoid being damaged by the turret. Move into the room with the turret. The turret should begin targeting you and firing.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_057.jpg"/><br/> <strong><font color=blue>Figure 11.57 – The turret is firing on the player.</font></strong>
<p />
<strong>9.</strong>	To get a better view of the turret in action, open the console again and enter ‘addbots 3’ to add three bots to the map. The turret should begin targeting and firing on the new bots in the map. You may have to move yourself out of the room and then back into it for the turret to choose a new enemy.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_058.jpg"/><br/> <strong><font color=blue>Figure 11.58 – A bot is being fired upon by the turret.</font></strong>
<p />
<strong>10.</strong>	Exit the map by pressing the Esc key. Play around with the properties, such as the RotLimit rotations, and continue testing the map to make sure everything seems to be working as intended.
<p />
<strong>11.</strong>	Save the map under a new name if you wish to save your setup.
<p />
Over the course of the turret tutorials, you have seen an example of how states can be used to cause an actor to behave differently under different circumstances. At the same time, the basic functionality of creating a completely new weapon was implemented along with showing you how to manipulate bones through the use of skeletal controllers inside of an AnimTree.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.22 – UTBOT_PELLET CLASS SETUP"></a> TUTORIAL 11.22 – UTBOT_PELLET CLASS SETUP </h2>
<p />
When constructing the UTPElletGame gametype in the previous chapter, it was mentioned that we would be tackling creating custom bots to use with the new gametype. In this tutorial we will begin the process of setting up those custom bots by declaring the UTBot_Pellet class.
<p />
<strong>1.</strong>	Open ConTEXT and create a new file using the UnrealScript highlighter.
<p />
<strong>2.</strong>	Declare the UTBot_Pellet class extending from the UTBot class. This will give us a solid functioning base from which to build.
<p />
<font face=consolas>
<pre>
class UTBot&#95;Pellet extends UTBot;
</pre>
</font>
<p />
<strong>3.</strong>	This new class will need a few class variables in order to implement the new functionality.
<p />
<font face=consolas>
<pre>
var Actor CurrentGoal;
</pre>
</font>
<p />
This will hold a reference to the final destination the bot will be navigating towards, which will either be some type of pellet or some player depending on which navigational state the bot is currently in.
<p />
<font face=consolas>
<pre>
var Bool bResetMove;
</pre>
</font>
<p />
This Bool variable will be used to cause a bot currently navigating towards a pellet to choose a new pellet to navigate to. This is used when another player collects the pellet before the bot reaches it.
<p />
<font face=consolas>
<pre>
var Float HPDistanceThreshold;
</pre>
</font>
<p />
This value specifies how close a HyperPellet needs to be in order for it to overtake other pellets in precendence.
<p />
<font face=consolas>
<pre>
var Float MinAggressiveness;
var Float MaxAggressiveness;
</pre>
</font>
<p />
These two values will represent a range from which to select a random value to be used for the Aggressiveness property of the bots. This will give a small amount of variation to th behavior of the bots.
<p />
<strong>4.</strong>	Moving on to the default properties block, we can set some default values for some of the variables that were just declared.
<p />
<font face=consolas>
<pre>
defaultproperties
{
}
</pre>
</font>
<p />
Add the defaultproperties block.
<p />
<font face=consolas>
<pre>
MinAggressiveness&#61;0.25
MaxAggressiveness&#61;0.85
</pre>
</font>
<p />
Values of 0.25 to 0.85 will give a nice range with no extremes to the bots for their Aggressiveness.
<p />
<font face=consolas>
<pre>
HPDistanceThreshold&#61;512
</pre>
</font>
<p />
This value will force bots only to go directly after a HyperPellet and ignore all other pellets if one is within 512 units of the bot’s current location.
<p />
<strong>5.</strong>	Now the PostBeginPlay() function will be overridden to enable the Aggressiveness variable to be set using the range of MinAggressiveness and MaxAggressiveness instead of the current way the UTBot class handles it. Declare the PostbEginPlay() function now.
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
}
</pre>
</font>
<p />
<strong>6.</strong>	Next, the UTBot class’s PostBeginPlay() function needs to be called before anything else is done using the Super keyword.
<p />
<font face=consolas>
<pre>
Super.PostBeginPlay();
</pre>
</font>
<p />
<strong>7.</strong>	 Then set the Agressiveness variable to a random value within the range specified by the MinAggressiveness and MaxAggressiveness variables using the RandRange() function.
<p />
<font face=consolas>
<pre>
Aggressiveness &#61; RandRange(MinAggressiveness, MaxAggressiveness);
</pre>
</font>
<p />
<strong>8.</strong>	Save the script in the MasteringUnrealScript/Classes directory with the name UTBot_Pellet.uc.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.23 – PELLETCOLLECTING STATE, PART I: FINDNEWGOAL() FUNCTION"></a> TUTORIAL 11.23 – PELLETCOLLECTING STATE, PART I: FINDNEWGOAL() FUNCTION </h2>
<p />
The behavior of the bot will be determined by which state the bot is currently in. The first state that will be added to the UTBot_Pellet class is the PelletCollecting state. This state causes the bot to navigate the path network in search of pellets. The behavior of the bot within the PelletCollecting state can essentially be broken down into the following actions. First the bot chooses a destination. Then, the bot moves toward that destination. Once the bot arrives at the destination, it chooses a new destination and repeats the process.
<p />
<strong>1.</strong>	Open ConTEXT and the UTBot_Pellet script.
<p />
<strong>2.</strong>	Declare the new PelletCollecting state.
<p />
<font face=consolas>
<pre>
auto state PelletCollecting
{
}
</pre>
</font>
<p />
Notice that the auto keyword was used when declaring the state to force the bot to begin in the PelletCollecting state.
<p />
<strong>3.</strong>	The choosing of a destination will be handled by a function named FindNewGoal(). Declare this new function inside of the PelletCollecting state block.
<p />
<font face=consolas>
<pre>
function FindNewGoal()
{
}
</pre>
</font>
<p />
<strong>4.</strong>	This function makes use of several local variables.
<p />
<font face=consolas>
<pre>
local Pellet CurrPellet;
</pre>
</font>
<p />
This holds a reference to the current pellet as the Pellets array belonging  to the PelleInfo of the UTPelletGame class is iterated over.
<p />
<font face=consolas>
<pre>
local Float Distance;
</pre>
</font>
<p />
This holds the distance of the closest pellet found thus far.
<p />
<font face=consolas>
<pre>
local Float currDistance;
</pre>
</font>
<p />
This holds the distance of the current pellet from the bot.
<p />
<font face=consolas>
<pre>
local Bool bGoalIsHP;
</pre>
</font>
<p />
This Bool’s value specifies whether or not the CurrentGoal references a HyperPellet.
<p />
<font face=consolas>
<pre>
local Bool bCurrIsHP;
</pre>
</font>
<p />
This Bool’s value specifies whether or not the current pellet in the iteration is a HyperPellet.
<p />
<strong>5.</strong>	First, the bot is checked to see that it is controlling a Pawn. Execution is only allowed to continue if the Pawn variable has a reference assigned to it.
<p />
<font face=consolas>
<pre>
if(Pawn &#61;&#61; None)
   return;
</pre>
</font>
<p />
<strong>6.</strong>	Next, we set the value of Distance to some large value to use when comparing the distances of each pellet during the iteration and remove any references assigned to the CurrentGoal so that we ensure a new CurrentGoal is chosen.
<p />
<font face=consolas>
<pre>
Distance &#61; 1000000.0;
CurrentGoal &#61; None;
</pre>
</font>
<p />
<strong>7.</strong>	Set up the iterator to loop through the Pellets array belonging to the PelletInfo of the UTPelletGame using the CurrPellet local variable to hold a reference to each pellet.
<p />
<font face=consolas>
<pre>
foreach UTPelletGame(WorldInfo.Game).PelletInfo.Pellets(CurrPellet)
{
}
</pre>
</font>
<p />
<strong>8.</strong>	Initialize the currDistance, bGoalIsHP, and bCurrIsHP variables. The currDistance variable’s value will be the distance, calculated using the VSize() function, from the CurrPellet to the bot’s Pawn. The two Bool variables will use the IsA() function to find whether the CurrentGoal and CurrPellet are HyperPellets, respectively.
<p />
<font face=consolas>
<pre>
currDistance &#61; VSize(CurrPellet.Location - Pawn.Location);
bGoalIsHP &#61; CurrentGoal.IsA(&#39;HyperPellet&#39;);
bCurrIsHP &#61; CurrPellet.IsA(&#39;HyperPellet&#39;);
</pre>
</font>
<p />
<strong>9.</strong>	An If-statement consisting of four separate conditions, only one of which must be met, decides whether the current pellet is chosen as the new CurrentGoal.
<p />
<font face=consolas>
<pre>
if( (CurrentGoal !&#61; none &#38;&#38; bGoalIsHP &#38;&#38; bCurrIsHP &#38;&#38; currDistance &#60; Distance)          &#124;&#124;
    (CurrentGoal !&#61; none &#38;&#38; !bGoalIsHP &#38;&#38; bCurrIsHP &#38;&#38; currDistance &#60; HPDistanceThreshold) &#124;&#124;
    (CurrentGoal !&#61; none &#38;&#38; !bGoalIsHP &#38;&#38; currDistance &#60; Distance)             &#124;&#124;
    (CurrentGoal &#61;&#61; none &#38;&#38; currDistance &#60; Distance) )
{
}
</pre>
</font>
<p />
The four conditions are explained below in the order they appear in the code:
<p /> <ul>
<li> A goal exists, both the goal and the current pellet are HyperPellets, and the current pellet is closer than the goal.
</li></ul>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_059.jpg"/><br/> <strong><font color=blue>Figure 11.59 – The current pellet and goal are HyperPellets, with the current pellet closer.</font></strong>
<p /> <ul>
<li> A goal exists, the current pellet is a HyperPellet but the goal is not, and the current pellet is closer than the HPDistanceThreshold.
</li></ul>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_060.jpg"/><br/> <strong><font color=blue>Figure 11.60 – The current pellet is a HyperPellet, the goal is a regular Pellet, and the current pellet is within the HPDistanceThreshold.</font></strong>
<p /> <ul>
<li> A goal is set, the goal is not a HyperPellet, and the current pellet is closer than the goal.
</li></ul>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_061.jpg"/><br/> <strong><font color=blue>Figure 11.61 – The current pellet and goal are regular pellets, with the current pellet closer.</font></strong>
<p /> <ul>
<li> No goal is set and the current pellet is closer than the value of Distance.
</li></ul>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_062.jpg"/><br/> <strong><font color=blue>Figure 11.62 – There is no goal currently and the current pellet is closer than the current distance value.</font></strong>
<p />
<strong>10.</strong>	If any of the preceding conditions are met, the current pellet is set as the new CurrentGoal and the Distance variable is updated with the distance from the bot to the current pellet.
<p />
<font face=consolas>
<pre>
CurrentGoal &#61; CurrPellet;
Distance &#61; currDistance;
</pre>
</font>
<p />
<strong>11.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.24 – PELLETCOLLECTING STATE, PART II: HASREACHEDGOAL() FUNCTION"></a> TUTORIAL 11.24 – PELLETCOLLECTING STATE, PART II: HASREACHEDGOAL() FUNCTION </h2>
<p />
The second function added to the PelletCollecting state is the HasReachedGoal() function. This function determines if the bot has reached its final destination mainly by checking the location of the bot and comparing it to the location of the destination. If that distance between them is smaller than the collision radius of the bot, then the bot is assumed to have reached its destination and can then choose a new destination.
<p />
<strong>1.</strong>	Open ConTEXT and the UTBot_Pellet.uc script.
<p />
<strong>2.</strong>	Declare the HasReachedGoal() function with a Bool return type inside the PelletCollecting state.
<p />
<font face=consolas>
<pre>
function Bool HasReachedGoal()
{
}
</pre>
</font>
<p />
<strong>3.</strong>	This function consists of a series of If-statements which either return True or False. The first condition checks to make sure the bot has a Pawn assigned to it. If not, there is no reason continuing the execution of this function si ti returns False.
<p />
<font face=consolas>
<pre>
if(Pawn&#61;&#61;none)
   return false;
</pre>
</font>
<p />
<strong>4.</strong>	Next, another If-statement checks that there is indeed a CurrentGoal and MoveTarget set. The CurrentGoal represents the final destination while the MoveTarget represents the intermediate waypoint the bot is navigating to on its way to the final destination. If either of these is not set, then a new destination needs to be set meaning the function should return True.
<p />
<font face=consolas>
<pre>
if(CurrentGoal &#61;&#61; None &#124;&#124; MoveTarget &#61;&#61; none)
   return true;
</pre>
</font>
<p />
<strong>5.</strong>	The last If-statement also returns True if the condition is met. This statement checks the bResetMove variable and if True, returns True to choose a new destination. In addition, the check to see if the bot has reached its final destination is performed.
<p />
<font face=consolas>
<pre>
if(   bResetMove   &#124;&#124;
   VSize(CurrentGoal.Location-Pawn.Location) &#60; Pawn.CylinderComponent.CollisionRadius    )
   return true;
</pre>
</font>
<p />
Note: The reason this statement is separate from the previous statement is simply to keep things more legible. One If-statement with a whole slew of conditions can become unruly. Breaking them up into smaller individual checks is easier to read, though if we were using the &amp;&amp; operator it may be faster to have them all grouped since the statement would fail as soon as one of the conditions failed saving processing time.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_063.jpg"/><br/> <strong><font color=blue>Figure 11.63 – The bot must be within its collision radius of the goal to register as reaching the goal.</font></strong>
<p />
<strong>6.</strong>	Finally, after all of the If-statements, the function will return False as a catch-all.
<p />
<font face=consolas>
<pre>
return false;
</pre>
</font>
<p />
<strong>7.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.25 – PELLETCOLLECTING STATE CODE"></a> TUTORIAL 11.25 – PELLETCOLLECTING STATE CODE </h2>
<p />
The final piece of the PelletCollecting state is the state code itself. This code is not contained within a function, but runs when the bot is placed into the PelletCollecting state. This code is where the bot is actually told what to do while in the PelletCollecting state.
<p />
Note: Many of the functions used within the state code in this tutorial and subsequent tutorials are latent functions meaning they can only be called from within state code and not from within any function.
<p />
<strong>1.</strong>	Open ConTEXT and the UTBot_pellet.uc script.
<p />
<strong>2.</strong>	The state code is placed after all the function declarations within the state and begins with a label, in this case Begin.
<p />
<font face=consolas>
<pre>
Begin:
</pre>
</font>
<p />
<strong>3.</strong>	Each time the state begins, a check will be performed to determine if the bot has reached its current destination by calling the HasReachedGoal() function and using the return value as the condition in an If-statement. If the function returns True, the FindNewGoal() function will be called to find a new destination for the bot.
<p />
<font face=consolas>
<pre>
if(HasReachedGoal())
{
   FindNewGoal();
}
</pre>
</font>
<p />
<strong>4.</strong>	Next another If-statement checks to see whether a new destination was found.
<p />
<font face=consolas>
<pre>
if(CurrentGoal !&#61; None)
{
}
</pre>
</font>
<p />
<strong>5.</strong>	Inside this If-statement, one of two possible actions is taken. First, the bot checks whether the CurrentGoal is directly reachable from its current location using the ActorReachable() function. This function determines whether the Actor passed to the function can be navigated toward without the need of first navigating to an intermediate waypoint using the navigational path network. If the CurrentGoal is reachable, the bot is directed to move toward that actor by means of the MoveToward() function.
<p />
<font face=consolas>
<pre>
if(Actorreachable(CurrentGoal))
{
   MoveToward(CurrentGoal);
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_064.jpg"/><br/> <strong><font color=blue>Figure 11.64 – The bot moves directly to the goal.</font></strong>
<p />
<strong>6.</strong>	If the CurrentGoal is not directly reachable, the bot needs to use the path network to find an intermediate waypoint to move towards in order to ultimately reach its final destination. The FindPathToward() function is passed the desired final destination and returns the next waypoint on the path to the final destination. That waypoint is then passed to the MoveToward() function to direct the bot to being moving toward the CurrentGoal indirectly.
<p />
<font face=consolas>
<pre>
else
{
   MoveTarget &#61; FindPathToward(CurrentGoal);
   MoveToward(MoveTarget,CurrentGoal);
}
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_065.jpg"/><br/> <strong><font color=blue>Figure 11.65 – The bot moves toward an intermediate waypoint.</font></strong>
<p />
<strong>7.</strong>	After all the preceding state code, outside of any If-statements, the LatentWhatToDoNext() function is called. This function will ultimately cause the ExecuteWhatToDoNext() function to be called which is where the major decision making of the bot is done. We will be overriding this function in a subsequent tutorial implementing code to cause the bot to use this new PelletCollecting state as well as any other states that are added to the UTBot_pellet class.
<p />
<font face=consolas>
<pre>
LatentWhatToDoNext();
</pre>
</font>
<p />
<strong>8.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.26 – PELLETHUNTING STATE, PART I: FINDNEWGOAL() FUNCTION"></a> TUTORIAL 11.26 – PELLETHUNTING STATE, PART I: FINDNEWGOAL() FUNCTION </h2>
<p />
While in the PelletCollecting state, the bot seeks out pellets which have not been collected. Once all the pellets have initially been collected, the bot uses the PelletHunting state to seek out the player with the most points currently in order to hunt down and kill them and acquire their points. This state extends the PelletCollecting state and will override both functions contained within it.
<p />
<strong>1.</strong>	Open ConTEXT and the UTBot_Pellet.uc script.
<p />
<strong>2.</strong>	After the PelletCollecting state, declare the new PelletHunting state extending from the PelletCollecting state.
<p />
<font face=consolas>
<pre>
state PelletHunting extends PelletCollecting
{
}
</pre>
</font>
<p />
<strong>3.</strong>	The FindNewGoal() function is declared first overriding the version inherited from the PelletCollecting state.
<p />
<font face=consolas>
<pre>
function FindNewGoal()
{
}
</pre>
</font>
<p />
<strong>4.</strong>	The basic idea of the FindNewGoal() function remains; it locates the most desirable destination for the bot to move toward. In this instance, the most desirable destination will be the player with the most points, other than the bot itself. This function will iterate through all the controllers within the level comparing their scores. This will require two local variables: one to hold the current controller and one to hold the highest score.
<p />
<font face=consolas>
<pre>
local Controller CurrController;
local Int CurrScore;
</pre>
</font>
<p />
<strong>5.</strong>	First, the Pawn of the controller is checked to see that it has a valid reference. If not, there is no need to continue execution of this function.
<p />
<font face=consolas>
<pre>
if(Pawn&#61;&#61;none)
   return;
</pre>
</font>
<p />
<strong>6.</strong>	Next the CurrentGoal and CurrScore are initialized. The CurrentGoal variable has any current reference to an acotr removed, while the CurrScore variable has its value set to -1 to ensure that a destination is chosen even if all the other players have no points.
<p />
<font face=consolas>
<pre>
CurrScore &#61; -1;
CurrentGoal &#61; None;
</pre>
</font>
<p />
<strong>7.</strong>	Now the AllControllers iterator is used to loop through each controller within the level. The base Controller class is used so that players and bots are both included and the current controller is held by the CurrController local variable.
<p />
<font face=consolas>
<pre>
foreach WorldInfo.AllControllers(class&#39;Engine.Controller&#39;,CurrController)
{
}
</pre>
</font>
<p />
<strong>8.</strong>	Inside the iterator, the current controller is compared to the bot using the Self keyword to make sure the current controller is not the bot in question. Also, the current controller’s score is compared to the CurrScore  to see if the controller has more points. If both these conditions are met, The current controller’s Pawn is set as the CurrentGoal and its score is set as the CurrScore.
<p />
<font face=consolas>
<pre>
if(CurrController !&#61; self &#38;&#38; CurrController.PlayerReplicationInfo.Score &#62; CurrScore)
{
   CurrScore &#61; CurrController.PlayerReplicationInfo.Score;
   CurrentGoal &#61; CurrController.Pawn;
}
</pre>
</font>
<p />
<strong>9.</strong>	Save the script to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.27 – PELLETHUNTING STATE, PART II: HASREACHEDGAOL() FUNCTION"></a> TUTORIAL 11.27 – PELLETHUNTING STATE, PART II: HASREACHEDGAOL() FUNCTION </h2>
<p />
Because the bot is now hunting down players, the definition of reaching the destination has changed slightly. In the PelletHunting state, the bot only needs to be within a certain distance from the destination before it is considered to have reached that destination. It isn’t usually the best fighting tactic to run straight up to your opponent. So, once the bot is within an acceptable radius, it will be told to begin hunting and fighting the player using its existing fighting functionality.
<p />
<strong>1.</strong>	Open ConTEXT and the UTBot_Pellet.uc script.
<p />
<strong>2.</strong>	Inside the PelletHunting state after the FindNewGoal() function, copy and paste the HasReachedGoal() function from the PelletCollection state as this state’s version will be very similar.
<p />
<font face=consolas>
<pre>
function Bool HasReachedGoal()
{
   if(Pawn&#61;&#61;none)
      return false;

   if(CurrentGoal &#61;&#61; None &#124;&#124; MoveTarget &#61;&#61; none)
      return true;

   if(  bResetMove &#124;&#124;
        VSize(CurrentGoal.Location-Pawn.Location) &#60; Pawn.CylinderComponent.CollisionRadius  )
      return true;

   return false;
}
</pre>
</font>
<p />
<strong>3.</strong>	The first two If-statements remain, but the third must be changed. It is replaced by an If-statement that calculates the distance from the CurrentGoal to the bot and compares the result to a set distance, 1024 units in this case, that will represent the minimum distance the bot must be from the destination to proceed.
<p />
<font face=consolas>
<pre>
if(VSize(CurrentGoal.Location-Pawn.Location) &#60; 1024)
{
}
</pre>
</font>
<p />
<strong>4.</strong>	Inside the If-statement, The CurrentGoal is set to be the Enemy of the bot at this point.
<p />
<font face=consolas>
<pre>
Enemy &#61; Pawn(CurrentGoal);
</pre>
</font>
<p />
The Enemy must be a Pawn so a cast is needed here. This only works because the CurrentGoal is guaranteed to be a Pawn in the PelletHunting state.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_066.jpg"/><br/> <strong><font color=blue>Figure 11.66 – The goal becomes the enemy when within 1024 units of the bot.</font></strong>
<p />
<strong>5.</strong>	Another If-statement uses the return value of the CanSee() function which returns True if the Pawn passed to it can be seen within the peripheral vision of the bot.
<p />
<font face=consolas>
<pre>
if(CanSee(Pawn(CurrentGoal)))
{
}
</pre>
</font>
<p />
<strong>6.</strong>	If the condition is met, the FightEnemy() function is called passing a value of True specifying the bot can charge the Enemy as well as passing in the strength of the Enemy as returned from the RelativeStrength() function. This function uses the existing functionality from the UTBot class to determine how to go about fighting the Enemy.
<p />
<font face=consolas>
<pre>
FightEnemy(true,RelativeStrength(Enemy));
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_067.jpg"/><br/> <strong><font color=blue>Figure 11.67 – The bot attacks when it has line of sight to the enemy.</font></strong>
<p />
<strong>7.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.28 – EXECUTEWHATTODONEXT() AND WANDERORCAMP() FUNCTION OVERRIDES"></a> TUTORIAL 11.28 – EXECUTEWHATTODONEXT() AND WANDERORCAMP() FUNCTION OVERRIDES </h2>
<p />
The states within the UTBot_Pellet class exist, but currently there is no functionality for placing the bot into either of these two states besides being initially placed in the PelletCollecting state by means of the auto keyword. Simply being placed into the state once only causes the state code to be executed a single time and then the bot ceases to function. The call to the LatentWhatToDoNext() function in the state code accounts for this by forcing the ExecuteWhatToDoNext() function when appropriate. By overriding that function, the bot can essentially choose whether to collect pellets, hunt down the leader, or use the existing UTBot behavior.
<p />
<strong>1.</strong>	Open ConTEXT and the UTBot_Pellet.uc script.
<p />
<strong>2.</strong>	Outside of any state, declare the ExecuteWhatToDoNext() event. It should have the following signature:
<p />
<font face=consolas>
<pre>
protected event ExecuteWhatToDoNext()
{
}
</pre>
</font>
<p />
<strong>3.</strong>	This class’s version of this function uses a weighted average of several properties belonging to the bot to calculate a percentage of likelihood that the bot collects pellets or hunts down the leader instead of using the UTBot behavior. This weighted average is made up of four individual  pieces.
<p />
<font face=consolas>
<pre>
4 &#42; FClamp(Skill/6.0, 0.0, 1.0)
</pre>
</font>
<p />
The Skill of the bot is normalized and clamped toa  range of 0.0 to 1.0 and given a weighting of 4.
<p />
<font face=consolas>
<pre>
2 &#42; Aggressiveness
</pre>
</font>
<p />
The previous Skill weighted value is added to Aggressiveness of the bot with a weighting of 2.
<p />
<font face=consolas>
<pre>
2 &#42; (1 - ((CombatStyle + 1.0) / 2))
</pre>
</font>
<p />
The previous result is then added to the Inverse of the CombatStyle of the bot after it has been shifted and normalized to the range of 0.0 to 1.0 and given a weighting of 2.
<p />
<font face=consolas>
<pre>
2 &#42; (1 - Jumpiness)
</pre>
</font>
<p />
Next, the inverse of the Jumpiness property of the bot is given a weight of 2 and added to the previous result.
<p />
<font face=consolas>
<pre>
(   4 &#42; FClamp(Skill/6.0, 0.0, 1.0)    +
   2 &#42; Aggressiveness          +
   2 &#42; (1 - ((CombatStyle + 1.0) / 2))    +
   2 &#42; (1 - Jumpiness)         )   /  10
</pre>
</font>
<p />
Finally, the entire calculation is divided by 10, or the total sum of all the weights in order to calculate the average. These values are simply the result of trial and error and the properties used are personal preference other than Skill. The skill is used and weighted the most as it is directly being modified by the gametype created in the previous chapter in order to make the difficulty of the game increase as it progresses. By using this property, we ensure that the bots are more aggressive in collecting pellets or hunting down the leader as the game progresses as well.
<p />
<strong>4.</strong>	The weighted average from the previous step is compared against a random value from the range 0.0 to 1.0 as the condition for an If-statement. If the weighted average is greater than the random value, the bot is placed into one of the states added to the UTBot_Pellet class. If not, a call to the UTBot version of ExecuteWhatToDoNext() is made to use standard bot behavior.
<p />
<font face=consolas>
<pre>
if(RandRange(0.0,1.0) &#60; (   4 &#42; FClamp(Skill/6.0, 0.0, 1.0)    +
            2 &#42; Aggressiveness          +
            2 &#42; (1 - ((CombatStyle + 1.0) / 2))    +
            2 &#42; (1 - Jumpiness)         )   / 10)
{
}
else
   Super.ExecuteWhatToDoNext();
</pre>
</font>
<p />
<strong>5.</strong>	Inside the If-statement, another If-statement is used to determine if any pellets remain in the level to be collected.
<p />
<font face=consolas>
<pre>
if(UTPelletGame(WorldInfo.Game).PelletInfo.Pellets.Length &#62; 0)
{
}
else
{
}
</pre>
</font>
<p />
<strong>6.</strong>	Beginning inside the If block, when there are still pellets remaining to be collected, the bot is placed in the PelletCollecting state. Prior to that, the CurrentGoal of the bot is cleared if the bot was not already in the PelletCollecting state. This makes sure an appropriate destination is chosen when entering a new state because the bot could have made its way across the level in another state and would begin navigating toward a previous destination nowhere near its current location.
<p />
<font face=consolas>
<pre>
if(!IsInState(&#39;PelletCollecting&#39;))
   CurrentGoal &#61; None;
GotoState(&#39;PelletCollecting&#39;,&#39;Begin&#39;);
</pre>
</font>
<p />
The IsInState() function returns a Bool value specifying whether the bot is currently in the PelletCollecting state. The GotoState() function places the bot into the specified PelletCollecting state. The optional label Begin passed to the function directs the bot to begin execution at that label in the state’s state code.
<p />
<strong>7.</strong>	Continuing inside the Else block, the bot is placed into the PelletHunting state because there are no more pellets to be collected. As in the previous step, the CurrentGoal is cleared if the bot is not already in the PelletHunting state.
<p />
<font face=consolas>
<pre>
if(!IsInState(&#39;PelletHunting&#39;))
   CurrentGoal &#61; None;
GotoState(&#39;PelletHunting&#39;,&#39;Begin&#39;);
</pre>
</font>
<p />
<strong>8.</strong>	The WanderOrCamp() function of the UTBot class is called at certain times throughout the class and simply sends the bot to the Defending state. There is nothing in particular to defend in the UTPelletGame and using that state is not particularly useful. This function will be overridden in the UTBot_Pellet class to send the bot to one of the new states defined in the class. Declare the WanderOrCamp() function to override it.
<p />
<font face=consolas>
<pre>
function WanderOrCamp()
{
}
</pre>
</font>
<p />
<strong>9.</strong>	Now copy the inner If-statement from the ExecuteWhatToDoNext() function to place the bot in the appropriate state depending on the amount of pellets left to be collected.
<p />
<font face=consolas>
<pre>
if(UTPelletGame(WorldInfo.Game).PelletInfo.Pellets.Length &#62; 0)
{
   if(!IsInState(&#39;PelletCollecting&#39;))
      CurrentGoal &#61; None;
   GotoState(&#39;PelletCollecting&#39;,&#39;Begin&#39;);
}
else
{
   if(!IsInState(&#39;PelletHunting&#39;))
      CurrentGoal &#61; None;
   GotoState(&#39;PelletHunting&#39;,&#39;Begin&#39;);
}
</pre>
</font>
<p />
<strong>10.</strong>	Save the script to preserve your work.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.29 – PELLET CLASSES BOT SETUP"></a> TUTORIAL 11.29 – PELLET CLASSES BOT SETUP </h2>
<p />
With the majority of the behavior for the bots in place, we run into problems when a bot is navigating toward a pellet and another player collects that pellet before the bot reaches it. Some additional functionality must be added to the Pellet, HyperPellet, and SuperPellet classes in order to account for this situation.
<p />
<strong>1.</strong>	Open ConTEXT and the Pellet.uc, HyperPEllet.uc, and SuperPellet.uc scripts.
<p />
<strong>2.</strong>	In the Touch() event, any bots that are currently navigating toward this pellet need to have their bResetMove variable set to True to cause the bot to choose a new destination. This will be done by iterating through the UTBot_Pellet controllers within the level which means a UTBot_Pellet local variable named AI is needed.
<p />
<font face=consolas>
<pre>
local UTBot&#95;Pellet AI;
</pre>
</font>
<p />
<strong>3.</strong>	Inside the If-statement, set upan iterator using the AllControllers iterator function passing it the UTBot_Pellet class and the AI local variable.
<p />
<font face=consolas>
<pre>
foreach WorldInfo.AllCOntrollers(class&#39;MasteringUnrealScript.UTBot&#95;Pellet&#39;,AI)
{
}
</pre>
</font>
<p />
<strong>4.</strong>	Inside the iterator, the CurrentGoal of the current bot is checked against the pellet using an If-statement. If the pellet and the bot’s CurrentGoal are one and the same, the bresetMove property of the bot is set to True.
<p />
<font face=consolas>
<pre>
if(AI.CurrentGoal &#61;&#61; self)
   AI.bResetMove &#61; true;
</pre>
</font>
<p />
<strong>5.</strong>	Now, copy the new local variable declaration into the Touch() event of both the HyperPellet and SuperPellet classes.
<p />
<strong>6.</strong>	Finally, copy the iterator into the two additional pellet classes.
<p />
<strong>7.</strong>	Save the scripts to preserve your progress.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="TUTORIAL 11.30 – PELLET BOT COMPILING AND TESTING"></a> TUTORIAL 11.30 – PELLET BOT COMPILING AND TESTING </h2>
<p />
With the custom bots for the UTPelletGame gametype completed, the UTPelletGame class needs to be told to se the new bot class. Once  that is completed, the scripts can be compiled and the gametype can be tested to make sure the bots behave as expected.
<p />
<strong>1.</strong>	Oopen ConTEXT and the UTPelletGame.uc script.
<p />
<strong>2.</strong>	In the defaultproperties block, set the BotClass property to reference the new bot class, UTBot_Pellet.
<p />
<font face=consolas>
<pre>
BotClass&#61;Class&#39;MasteringUnrealScript.UTBot&#95;Pellet&#39;
</pre>
</font>
<p />
<strong>3.</strong>	Save the script and compile the scripts, fixing any syntax errors which may be present.
<p />
<strong>4.</strong>	Load up Unreal Tournament 3 and choose an Instant Action game.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_068.jpg"/><br/> <strong><font color=blue>Figure 11.68 – An Instant Action game is started.</font></strong>
<p />
<strong>5.</strong>	Select UTPelletGame from the next screen and the CH_10_PowerDome map after that.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_069.jpg"/><br/> <strong><font color=blue>Figure 11.69 – The CH_10_PowerDome map is selected.</font></strong>
<p />
<strong>6.</strong>	Choose the number of bots so there are as many bots as you would like in the map, five to seven is usually a good number for this map, and choose to start the game.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_070.jpg"/><br/> <strong><font color=blue>Figure 11.70 – Bots must be added to the map for testing.</font></strong>
<p />
<strong>7.</strong>	At this point, testing the game and the bots’ behavior is up to you. Turning on God mode by entering ‘god’ in the console is usually a good idea so you are not being killed while observing the behavior of the new bots. You can press F1 to show the scoreboard at any time to see how many points each bot has. This is usually a good way to see if they are collecting pellets as you would expect.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_071.jpg"/><br/> <strong><font color=blue>Figure 11.71 – The in-game scoreboard shows the number of pellets collection by each playet in the game.</font></strong>
<p />
The main things to look for are that the pellets are being collected and that the bots with less pellets are seeking out and attacking the bot with the most. Collecting more than half the pellets yourself is a good way to test this as the rest of the bots should all come after you in force once all the remaining pellets have been collected.
<p />
<img src="rsrc/Three/MasteringUnrealScriptStates/CH_11_FIGURE_072.jpg"/><br/> <strong><font color=blue>Figure 11.72 – The bots are now collecting the pellets.</font></strong>
<p />
These tutorials should not only have shown the use of states to differentiate behaviors, but hopefully has given you an insight into how to implement new AI and navigation functionality using the functions built into the controller classes.
<p />
<strong><font color="orange">&lt;&lt;&lt;&lt; End of Tutorial &gt;&gt;&gt;&gt;</font></strong>
<p />
<h2><a name="11.8 - SUMMARY"></a> 11.8 - SUMMARY </h2>
<p />
States are an incredibly powerful tool within Unreal Engine 3 enabling objects within the game to behave in distinctly different manners in various situations while minimizing the need for convoluted control structures. This is yet another case of the UnrealScript programming language being tailored specifically to the creation of objects to be used within a gaming environment. The organization and readability provided by states makes creating new items with incredibly complex behaviors much easier for you as a gameplay programmer.
<p />
<h2><a name="SUPPLEMENTAL FILES"></a> SUPPLEMENTAL FILES </h2>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptStates/TurretContent.upk" target="_top">TurretContent.upk</a>: TurretContent.upk
</li></ul>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptStates/Chapte11_CompleteSource.rar" target="_top">Chapte11_CompleteSource.rar</a>: Complete Source Files
</li></ul>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptStates/Chapter11_Maps.rar" target="_top">Chapter11_Maps.rar</a>: Chapter 11 Maps
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
