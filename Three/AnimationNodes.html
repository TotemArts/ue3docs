<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | AnimationNodes    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">AnimationNodes  </b></div>
<div id="tooltext">
<a href="AnimationNodesJP.html" class="twikiLink">日本語訳</a><br><a href="AnimationNodesCH.html" class="twikiLink">中国翻译</a><br><a href="AnimationNodesKR.html" class="twikiLink">한국어</a><br>

<!-- Three/AnimationNodes -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/Three/AnimationNodes/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AnimationHome.html" class="twikiLink">Animation</a></b> &gt; Animation Nodes <br/>
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AnimatorHome.html" class="twikiLink">Animators</a></b> &gt; Animation Nodes
</div>
<hr size="1" noshade="noshade">
<h1><a name="Animation Nodes"></a> Animation Nodes </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="AnimationNodes.html#Animation Nodes"> Animation Nodes</a> <ul>
<li> <a href="AnimationNodes.html#Overview"> Overview</a>
</li> <li> <a href="AnimationNodes.html#How to think about animation blending when creating Anim Trees"> How to think about animation blending when creating Anim Trees</a>
</li> <li> <a href="AnimationNodes.html#Animation Nodes"> Animation Nodes</a> <ul>
<li> <a href="AnimationNodes.html#Modifying animation nodes"> Modifying animation nodes</a>
</li> <li> <a href="AnimationNodes.html#Referencing animation nodes within Unrealscript"> Referencing animation nodes within Unrealscript</a>
</li> <li> <a href="AnimationNodes.html#AnimTree ownership"> AnimTree ownership</a>
</li> <li> <a href="AnimationNodes.html#Uncategorized"> Uncategorized</a> <ul>
<li> <a href="AnimationNodes.html#AnimNodeAimOffset"> AnimNodeAimOffset</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlend"> AnimNodeBlend</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeCrossfader"> AnimNodeCrossfader</a>
</li> <li> <a href="AnimationNodes.html#AnimNodePlayCustomAnim"> AnimNodePlayCustomAnim</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeScalePlayRate"> AnimNodeScalePlayRate</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeScaleRateBySpeed"> AnimNodeScaleRateBySpeed</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeSlot"> AnimNodeSlot</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeSynch"> AnimNodeSynch</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByDriving / _UTAnimBlendByDriving"> UDKAnimBlendByDriving / UTAnimBlendByDriving </a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByHoverboardTilt / _UTAnimBlendByHoverboardTilt"> UDKAnimBlendByHoverboardTilt / UTAnimBlendByHoverboardTilt </a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByHoverboardTurn / _UTAnimBlendByHoverboardTurn"> UDKAnimBlendByHoverboardTurn / UTAnimBlendByHoverboardTurn </a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendBySpeed / _UTAnimBlendBySpeed"> UDKAnimBlendBySpeed / UTAnimBlendBySpeed</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimNodeCopyBoneTranslation / _UTAnimNodeCopyBoneTranslation"> UDKAnimNodeCopyBoneTranslation / UTAnimNodeCopyBoneTranslation</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimNodeJumpLeanOffset / _UTAnimNodeJumpLeanOffset"> UDKAnimNodeJumpLeanOffset / UTAnimNodeJumpLeanOffset</a>
</li></ul>
</li> <li> <a href="AnimationNodes.html#Filter"> Filter</a> <ul>
<li> <a href="AnimationNodes.html#AnimNode_MultiBlendPerBone"> AnimNode_MultiBlendPerBone</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlendMultiBone"> AnimNodeBlendMultiBone</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlendPerBone"> AnimNodeBlendPerBone</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendBySlotActive / _UTAnimBlendBySlotActive"> UDKAnimBlendBySlotActive / UTAnimBlendBySlotActive</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByWeapon / _UTAnimBlendByWeapon"> UDKAnimBlendByWeapon / UTAnimBlendByWeapon</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByWeapType / _UTAnimBlendByWeaponType"> UDKAnimBlendByWeapType / UTAnimBlendByWeaponType</a>
</li></ul>
</li> <li> <a href="AnimationNodes.html#Additive"> Additive</a> <ul>
<li> <a href="AnimationNodes.html#AnimNodeAdditiveBlending"> AnimNodeAdditiveBlending</a>
</li></ul>
</li> <li> <a href="AnimationNodes.html#BlendBy"> BlendBy</a> <ul>
<li> <a href="AnimationNodes.html#AnimNodeBlendByBase"> AnimNodeBlendByBase</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlendByPhysics"> AnimNodeBlendByPhysics</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlendByPosture"> AnimNodeBlendByPosture</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlendByProperty"> AnimNodeBlendByProperty</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlendBySpeed"> AnimNodeBlendBySpeed</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeBlendList"> AnimNodeBlendList</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendBase / _UTAnimBlendBase"> UDKAnimBlendBase / UTAnimBlendBase</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByFall / _UTAnimBlendByFall"> UDKAnimBlendByFall / UTAnimBlendByFall</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByFlying / _UTAnimBlendByFlying"> UDKAnimBlendByFlying / UTAnimBlendByFlying</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByHoverboarding / _UTAnimBlendByHoverboarding"> UDKAnimBlendByHoverboarding / UTAnimBlendByHoverboarding</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByHoverJump / _UTAnimBlendByHoverJump"> UDKAnimBlendByHoverJump / UTAnimBlendByHoverJump</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByIdle / _UTAnimBlendByIdle"> UDKAnimBlendByIdle / UTAnimBlendByIdle</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByPhysics / _UTAnimBlendByPhysics"> UDKAnimBlendByPhysics / UTAnimBlendByPhysics</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByPhysicsVolume / _UTAnimBlendByPhysicsVolume"> UDKAnimBlendByPhysicsVolume / UTAnimBlendByPhysicsVolume</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByPosture / _UTAnimBlendByPosture"> UDKAnimBlendByPosture / UTAnimBlendByPosture</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByTurnInPlace / _UTAnimBlendByTurnInPlace"> UDKAnimBlendByTurnInPlace / UTAnimBlendByTurnInPlace</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimBlendByVehicle / _UTAnimBlendByVehicle"> UDKAnimBlendByVehicle / UTAnimBlendByVehicle</a>
</li></ul>
</li> <li> <a href="AnimationNodes.html#Directional"> Directional</a> <ul>
<li> <a href="AnimationNodes.html#AnimNodeBlendDirectional"> AnimNodeBlendDirectional</a>
</li></ul>
</li> <li> <a href="AnimationNodes.html#Mirror"> Mirror</a> <ul>
<li> <a href="AnimationNodes.html#AnimNodeMirror"> AnimNodeMirror</a>
</li></ul>
</li> <li> <a href="AnimationNodes.html#Random"> Random</a> <ul>
<li> <a href="AnimationNodes.html#AnimNodeRandom"> AnimNodeRandom</a>
</li></ul>
</li> <li> <a href="AnimationNodes.html#Animation Node Sequences"> Animation Node Sequences</a> <ul>
<li> <a href="AnimationNodes.html#AnimNodeSequence"> AnimNodeSequence</a>
</li> <li> <a href="AnimationNodes.html#AnimNodeSequenceBlendByAim"> AnimNodeSequenceBlendByAim</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimNodeFramePlayer / _UTAnimNodeFramePlayer"> UDKAnimNodeFramePlayer / UTAnimNodeFramePlayer</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimNodeSequence / _UTAnimNodeSequence"> UDKAnimNodeSequence / UTAnimNodeSequence</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimNodeSequenceByBoneRotation / _UTAnimNodeSequenceByBoneRotation"> UDKAnimNodeSequenceByBoneRotation / UTAnimNodeSequenceByBoneRotation</a>
</li> <li> <a href="AnimationNodes.html#UDKAnimNodeSeqWeapon / _UTAnimNodeSeqWeapon"> UDKAnimNodeSeqWeapon / UTAnimNodeSeqWeapon</a>
</li></ul>
</li></ul>
</li> <li> <a href="AnimationNodes.html#Example"> Example</a>
</li> <li> <a href="AnimationNodes.html#Downloads"> Downloads</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
<p />
This page is a reference for all of the base animation nodes available in the Anim Tree Editor. Animation nodes are the building blocks for Unreal Engine 3's animation system. If you haven't already, please read the <a href="AnimationOverview.html" class="twikiLink">AnimationOverview</a> document, as it gives a good introduction to the animation system in Unreal Engine 3. Each animation node is a self contained black box which takes in inputs from either animation nodes or animation sequences, outputting the results.
<p />
<h2><a name="How to think about animation blending when creating Anim Trees"></a> How to think about animation blending when creating Anim Trees </h2>
<hr size="1" noshade="noshade">
Animation blend nodes perform an operation using animation data created by an animator. Thus it takes input(s), transforms the bone translation and rotation and then outputs the results. The results of one animation blend can then be used in another. Animation blend nodes may also poll for data contained within the anim tree's owning actor. This allows the animator to quickly set up an anim tree that will work in most instances. When more complex behavior is required, a programmer can then step in to add the complexity.
<p />
<h2><a name="Animation Nodes"></a> Animation Nodes </h2>
<hr size="1" noshade="noshade">
<p />
<img src="rsrc/Three/AnimationNodes/AnimationNodeTemplate.jpg" alt="AnimationNodeTemplate.jpg" width='445' height='367' />
<p /> <ol>
<li> <strong>Title bar</strong> - Displays the name and/or pertinent information about properties of the animation node.
</li> <li> <strong>Body</strong> - Displays the names associated with the input and output links.
</li> <li> <strong>Blend slider</strong> - Displays the current blend percentage as a visual slider. You may also manually adjust the blend percentage by left clicking and dragging it left or right.
</li> <li> <strong>Blend information</strong> - Displays the current blend percentage as a number.
</li> <li> <strong>Outputs</strong> - Links that output to the results of the animation node operation.
</li> <li> <strong>Inputs</strong> - Links that take in the value(s) to be used by the animation node.
</li></ol>
<p />
<h3><a name="Modifying animation nodes"></a> Modifying animation nodes </h3>
Right clicking on the animation node's input boxes, brings up this context menu. You can break the current link the input has, rename the input or delete the input (if the animation node allows you to do so).
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeContextOnInput.jpg" alt="AnimNodeContextOnInput.jpg" width='471' height='205' />
<p />
Right clicking on the animation node itself, brings up this context menu. You can add extra inputs (if the animation node allows you to do so), break all existing links, delete the animation node, copy the animation node to the clipboard, duplicate the animation node within this AnimTree Editor and paste an animation node that is in the clipboard.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeContextOnAnimNode.jpg" alt="AnimNodeContextOnAnimNode.jpg" width='471' height='276' />
<p />
By default animation nodes will have the animation node class name set in the title bar. You can alter this by using the <strong>Node Name</strong> property that is inside the "Anim Node" property category. The <strong>Node Name</strong> is also used to identify the animation node in Unrealscript; so try to have unique names for animation nodes if you wish to reference animation nodes at run time. However, unique animation node names are not enforced.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeCustomNodeName.jpg" alt="AnimNodeCustomNodeName.jpg" width='800' height='615' />
<p />
<h3><a name="Referencing animation nodes within Unrealscript"></a> Referencing animation nodes within Unrealscript </h3>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var Name AnimNodeBlendListName;
var AnimNodeBlendList AnimNodeBlendList;
var array&#60;AnimNodeBlendList&#62; AllAnimNodeBlendLists;

/&#42;
 &#42; Called after initializing the AnimTree for the given SkeletalMeshComponent that has this Actor as its Owner
 &#42; this is a good place to cache references to skeletal controllers, etc that the Actor modifies
 &#42;/
event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  local AnimNodeBlendList LocalAnimNodeBlendList;

  if (SkelComp &#61;&#61; None)
  {
    return;
  }

  if (AnimNodeBlendListName !&#61; &#39;&#39; &#38;&#38; AnimNodeBlendListName  !&#61; &#39;None&#39;)
  {
    // Search for the animation node blend list by name.
    AnimNodeBlendList &#61; AnimNodeBlendList(SkelComp.FindAnimNode(AnimNodeBlendListName));
    if (AnimNodeBlendList &#61;&#61; None)
    {
      `Warn(&#34;AnimNodeBlendList is none.&#34;);
    }
  }
  else
  {
    // Search for all animation node blend lists by class.
    ForEach SkelComp.AllAnimNodes(class&#39;AnimNodeBlendList&#39;, LocalAnimNodeBlendList)
    {
      AllAnimNodeBlendLists.AddItem(LocalAnimNodeBlendList);
    }
  }
}
</pre>
</div>
<p />
Ensure that you clear all anim node references when the actor is destroyed, otherwise they will not be garbage collected.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeBlendList &#61; None;
  AllAnimNodeBlendLists.Length &#61; 0;
}
</pre>
</div>
<p />
<p />
<h3><a name="AnimTree ownership"></a> AnimTree ownership </h3>
A brief note about AnimTree ownership. The actor that owns the skeletal mesh component, which instanced the AnimTree is the AnimTree's actor owner. This is important to remember because a few animation nodes look up variables in the AnimTree's actor owner.
<p />
<h3><a name="Uncategorized"></a> Uncategorized </h3>
<h4><a name="AnimNodeAimOffset"></a> AnimNodeAimOffset </h4>
<hr size="1" noshade="noshade">
In a game, you often want a weapon held by a character to point where that player is aiming. Because a Pawn is defined by a collision cylinder that is only able to rotate on the yaw axis and not the pitch or roll axis, it's difficult to simply rotate the pawn to make the player's aim. Even then, you may want the character's feet to remain locked in place.
<p />
The red arrow shows the rotation of the Pawn, represented by the red collision cylinder. The Green Arrow shows where the player is aiming. We can then define the aiming direction as a relative rotation from the Pawn's base rotation.
<p />
<img src="rsrc/Three/AnimationNodes/AimOffset.jpg" width="600" height="275" />
<p />
AnimNodeAimOffset takes an animation with no aim offset (the gun is pointing forward) as an input. AnimNodeAimOffset can alter several bones by adding a combination of rotation and translation offsets. These offsets are defined by nine poses:
<p /> <ul>
<li> <strong>Center Center</strong> - Animation pose is aiming forward with no pitch or yaw adjustment.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetCenterCenter.jpg" alt="AimOffsetCenterCenter.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Center Up</strong> - Animation pose is aiming straight up with no yaw adjustments.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetCenterUp.jpg" alt="AimOffsetCenterUp.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Center Down</strong> - Animation pose is aiming straight down with no yaw adjustments.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetCenterDown.jpg" alt="AimOffsetCenterDown.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Left Center</strong> - Animation pose is aiming to the left with no pitch adjustments.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetLeftCenter.jpg" alt="AimOffsetLeftCenter.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Left Up</strong> - Animation pose is aiming to the upper left.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetLeftUp.jpg" alt="AimOffsetLeftUp.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Left Down</strong> - Animation pose is aiming to the lower left.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetLeftDown.jpg" alt="AimOffsetLeftDown.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Right Center</strong> - Animation pose is aiming to the right with no pitch adjustments.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetRightCenter.jpg" alt="AimOffsetRightCenter.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Right Up</strong> - Animation pose is aiming to the upper right.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetRightUp.jpg" alt="AimOffsetRightUp.jpg" width='800' height='872' />
<p /> <ul>
<li> <strong>Right Down</strong> - Animation pose is aiming to the lower right.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AimOffsetRightDown.jpg" alt="AimOffsetRightDown.jpg" width='800' height='872' />
<p />
These nine poses are then blended using bilinear interpolation. This allows an animator to pose a mesh for any direction to be used for things like aiming, or head looks. The transformation is done in Actor Space, so that local bone rotation doesn't affect the outcome of the aiming. Therefore, you can have a character running with motion in the arms, and still aim accurately.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeOffsetAnimTree.jpg" alt="AnimNodeOffsetAnimTree.jpg" width='362' height='255' />
<p /> <ol>
<li> The AnimNodeAimOffset within the AnimTree editor. Double clicking on the animation node brings up the AimOffset editor.
</li> <li> A 2D draggable slider to see the blended results of the AnimNodeAimOffset in the real time viewport within the AnimTree editor.
</li></ol>
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeOffsetEditor.jpg" alt="AnimNodeOffsetEditor.jpg" width='610' height='480' />
<p />
AimOffset Editor is used to author the AimOffset profiles that is used by the AnimNodeAimOffset.
<p />
The nine poses basically define a rectangle. AnimNodeAimOffset uses a normalized relative aim offset to figure out which pose to use. The range is from X, Y: [-1, -1] to [+1, +1]. So an aim of [0,0] would be using just <strong>Center Center</strong>, [+1,0] would be using <strong>Right Center</strong>, and [+0.5,0] would be half way between <strong>Center Center</strong> and <strong>Right Center</strong>.
<p />
<h5><a name="Using the _AimOffset Editor"></a><a name=" Using the _AimOffset Editor"></a>  Using the AimOffset Editor </h5>
When using the editor, the first thing to do is to create a new profile. In the Profile section, click on "New", and type in the profile name. You can add several profiles per node, as well as delete them. On the tool bar above, note the "Open" and "Save" icons, as this lets you Import and Save profiles.
<p />
Once a profile has been created, then the next step is to select which bones to affect. This can be done clicking on the "Add Bone" button of the AimOffset Editor. The select bones are displayed in increasing order with their index and name.
<p />
Once the relevant bones have been selected, for each one of these you can edit the offsets for the nine poses. A bone is selected by clicking on its name in the Bones combo box. A pose is selected by clicking on the relevant button in the Aim Direction group.
<p />
Above the Aim Direction group is a tool bar to select either Bone Translation or Bone Rotation editing. Toggling these will display a proper widget gizmo in the real time viewport for interactive editing. The "World Space Widget" check box toggles between local and world space widget editing. Edit fields are also available to enter numerical values directly.
<p />
<h5><a name="Baking Offsets from Animations"></a><a name=" Baking Offsets from Animations"></a>  Baking Offsets from Animations </h5>
Instead of typing the offsets by hand, or using the widget gizmos, you can also extract offsets from animations. To do so, go to the node's properties, expand the Profiles section, select the profile index you wish to edit, and you'll find a few variables named AnimName_XX, with XX corresponding to all of the nine orientations. Set the animation names you'd like to use there and toggle the property <strong>bBakeFromAnimations</strong>. You don't need to assign animations to all nine poses, but you'll need at least the <strong>Center Center</strong> pose, as this is the reference pose, used to extract the offsets. When <strong>bBakeFromAnimations</strong> is clicked, the node will extract the offsets based on the difference between each pose and the reference pose.
<p />
<h5><a name="AnimNodeAimOffset Parameters"></a><a name=" _AnimNodeAimOffset Parameters"></a>  AnimNodeAimOffset Parameters </h5> <ul>
<li> <strong>Aim</strong> <ul>
<li> <strong>X</strong> - Normalized horizontal aim offset.
</li> <li> <strong>Y</strong> - Normalized veritcal aim offset.
</li></ul>
</li> <li> <strong>Angle Offset</strong> <ul>
<li> <strong>X</strong> - Horizontal aim offset to append to <strong>Aim</strong> before processing.
</li> <li> <strong>Y</strong> - Vertical aim offset to append to <strong>Aim</strong> before processing.
</li></ul>
</li> <li> <strong>ForceAimDir</strong> - Use <strong>ForcedAimDir</strong>, otherwise process the output based on <strong>Aim</strong> and <strong>Angle Offset</strong>.
</li> <li> <strong>Bake From Animations</strong> - When checked, offsets will then be baked from animations.
</li> <li> <strong>ForcedAimDir</strong> - Forced aim pose.
</li> <li> <strong>Profiles</strong> <ul>
<li> <strong>Profile Name</strong> - Name of the profile, set by the AnimOffset Editor.
</li> <li> <strong>Horizontal Range</strong> <ul>
<li> <strong>X</strong> - Minimum horizontal aim.
</li> <li> <strong>Y</strong> - Maximum horizontal aim.
</li></ul>
</li> <li> <strong>Vertical Range</strong> <ul>
<li> <strong>X</strong> - Minimum vertical aim.
</li> <li> <strong>Y</strong> - Maximum vertical aim.
</li></ul>
</li> <li> <strong>Anim Name LU</strong> - Animation which represents the avatar aiming / looking upper left.
</li> <li> <strong>Anim Name LC</strong> - Animation which represents the avatar aiming / looking left.
</li> <li> <strong>Anim Name LD</strong> - Animation which represents the avatar aiming / looking lower left.
</li> <li> <strong>Anim Name CU</strong> - Animation which represents the avatar aiming / looking up.
</li> <li> <strong>Anim Name CC</strong> - Animation which represents the avatar aiming / looking forward.
</li> <li> <strong>Anim Name CD</strong> - Animation which represents the avatar aiming / looking down.
</li> <li> <strong>Anim Name RU</strong> - Animation which represents the avatar aiming / looking upper right.
</li> <li> <strong>Anim Name RC</strong> - Animation which represents the avatar aiming / looking right.
</li> <li> <strong>Anim Name RD</strong> - Animation which represents the avatar aiming / looking lower right.
</li></ul>
</li></ul>
<p />
<h5><a name="Using the node in game"></a><a name=" Using the node in game"></a>  Using the node in game </h5>
Using this node will require the assistance of a programmer. You either need to reference each node in code, and have the Pawn directly modify the normalized Aim parameter<!--  -->.
<p />
Note that if you reference animation nodes, you will need to clear them when the Actor is destroyed, otherwise they won't be garbage collected.
<p />
<!--  -->
<p />
Also, the node will be saved with the last edited profile. It is possible to switch profile during game play by calling the following functions from Unrealscript <!--  --> with <strong>SetActiveProfileByName()</strong> or <strong>SetActiveProfileByIndex()</strong>.
<p />
This code snippet shows you how to create a pawn which will look at a player's pawn.
<p />
<div class="codetitlebar">
<em>YourPawnClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var(Pawn) float ViewYawMin;
var(Pawn) float ViewYawMax;
var(Pawn) float AimSpeed;

var  AnimNodeAimOffset AimNode;
var Rotator DesiredAim;
var Rotator CurrentAim;

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AimNode &#61; AnimNodeAimOffset(SkelComp.FindAnimNode(&#39;AimNode&#39;));
}

simulated event Destroyed()
{
  Super.Destroyed();

  AimNode &#61; None;
}

simulated function Tick(float DeltaTime)
{
  local PlayerController PlayerController;

  Super.Tick(DeltaTime);

  PlayerController &#61; GetALocalPlayerController();
  if (PlayerController !&#61; None &#38;&#38; PlayerController.Pawn !&#61; None &#38;&#38; AimNode !&#61; None)
  {
    DesiredAim &#61; Rotator(Normal(Location - PlayerController.Pawn.Location));

    DesiredAim.Pitch &#61; Clamp(DesiredAim.Pitch, ViewPitchMin, ViewPitchMax);
    DesiredAim.Yaw &#61; Clamp(DesiredAim.Yaw, ViewYawMin, ViewYawMax);

    if (DesiredAim !&#61; CurrentAim)
    {
      CurrentAim &#61; RLerp(CurrentAim, DesiredAim, AimSpeed &#42; DeltaTime, false);
    }

    // Adjust the pitch
    if (CurrentAim.Pitch &#60; 0)
    {
      AimNode.Aim.Y &#61; Abs(float(CurrentAim.Pitch) / ViewPitchMax);
    }
    else if (CurrentAim.Pitch &#62; 0)
    {
      AimNode.Aim.Y &#61; float(CurrentAim.Pitch) / ViewPitchMin;
    }
    else
    {
      AimNode.Aim.Y &#61; 0.f;
    }

    // Adjust the yaw
    if (CurrentAim.Yaw &#62; 0)
    {
      AimNode.Aim.X &#61; float(CurrentAim.Yaw) / ViewYawMax;
    }
    else if (CurrentAim.Yaw &#60; 0)
    {
      AimNode.Aim.X &#61; Abs(float(CurrentAim.Yaw) / ViewYawMin) &#42; -1.f;
    }
    else
    {
      AimNode.Aim.X &#61; 0.f;
    }
  }
}

simulated function SetWeapAnimType(EWeapAnimType AnimType)
{
  if (AimNode !&#61; None)
  {
    switch(AnimType)
    {
    case EWAT&#95;Default:
      AimNode.SetActiveProfileByName(&#39;Default&#39;);
      break;

    case EWAT&#95;Pistol:
      AimNode.SetActiveProfileByName(&#39;SinglePistol&#39;);
      break;

    case EWAT&#95;DualPistols:
      AimNode.SetActiveProfileByName(&#39;DualPistols&#39;);
      break;

    case EWAT&#95;ShoulderRocket:
      AimNode.SetActiveProfileByName(&#39;ShoulderRocket&#39;);
      break;

    case EWAT&#95;Stinger:
      AimNode.SetActiveProfileByName(&#39;Stinger&#39;);
      break;
    }
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h5><a name="Weapon Alignment Issues"></a><a name=" Weapon Alignment Issues"></a>  Weapon Alignment Issues </h5>
The anim tree blends animations using Forward Kinematics (FK), and this causes problems with interpolation where bone positioning is important. And unfortunately this is the case with weapon aiming. The below picture shows the difference between Forward Kinematics and Inverse Kinematics (IK) interpolation that is necessary to understand this problem.
<p />
<img src="rsrc/Three/AnimationNodes/FK_VS_IK.jpg" width="512" height="256" />
<p />
When blending two animations using FK, the bone rotations are interpolated. In the case of weapon aiming, this results in having both left and right hands misaligned. There are several ways to get around that problem. One could glue the left hand at a fixed offset from the right hand, although that won't really fix the right hand being misaligned. What we really want is to interpolate the end positions of the hands, and determine the arm position from there, so both hands stay aligned together. So we need to use Inverse Kinematics (IK) to get that working properly.
<p />
For performance reasons the aiming nodes do not provide a built in IK option, since it is quite costly to evaluate that for every single Aim node. However it is possible to fix this problem by using a specific skeleton hierarchy. "IK Bones" can be made (direct childs of the root bone), and moved by translation only, matching closely the position of the hands frame by frame. When different animations are now blended the hands will by default use FK blending (since they use rotations), and the IK bones IK (since they use translations). By using a SkelControlLimb (simple 2 bone IK solver bone controller) and triggering it on demand, it is possible to switch between FK and IK at will. The bone controller is used as some sort of post process effect, processed only once, instead of for every Aim node in the tree.
<p />
<p />
<h4><a name="AnimNodeBlend"></a> AnimNodeBlend </h4>
<hr size="1" noshade="noshade">
This is a simple blend node that blends two inputs together. You can specify the desired blend target and how long it will take in seconds to blend to the final weight.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlend.jpg" alt="AnimNodeBlend.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Skip Blend When Not Rendered</strong> - Skips the blend instruction when the skeletal mesh is not being rendered.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetBlendTarget(float BlendTarget, float BlendTime)</strong> - Sets the desired balance of this blend node. <ul>
<li> <strong>BlendTarget</strong> - Target amount of weight to put on the second input. This value should be between 0.f and 1.f.
</li> <li> <strong>BlendTime</strong> - How long to take to get to the blend target.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
The example below shows how to blend between Child 1 and Child 2 with a blend time of half a second.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var AnimNodeBlend AnimNodeBlend;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeBlend &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodeBlend &#61; AnimNodeBlend(SkelComp.FindAnimNode(&#39;AnimNodeBlend&#39;));
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (AnimNodeBlend &#61;&#61; None)
  {
    return;
  }

  if (AnimNodeBlend.BlendTimeToGo &#60;&#61; 0.f)
  {
    AnimNodeBlend.SetBlendTarget((AnimNodeBlend.Child2Weight &#62;&#61; 1.f) ? 0.f : 1.f, 0.5f);
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="AnimNodeCrossfader"></a> AnimNodeCrossfader </h4>
<hr size="1" noshade="noshade">
This blend node allows the anim tree to cross fade between two animations through script control. A typical usage scenario would be to blend between two player idle animations. This blend node requires 2 AnimNodeSequences as inputs, you cannot connect any other type of animation blend nodes.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeCrossfader.jpg" alt="AnimNodeCrossfader.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Default Anim Seq Name</strong> - Default animation sequence to play upon start up.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>PlayOneShotAnim(name AnimSeqName, optional float BlendInTime, optional float BlendOutTime, optional bool bDontBlendOut, optional float Rate)</strong> - Plays a one shot animation. <ul>
<li> <strong>AnimSeqName</strong> - Name of animation sequence to play.
</li> <li> <strong>BlendInTime</strong> - Time to blend from current animation to this (new) one.
</li> <li> <strong>BlendOutTime</strong> - Time to blend from this animation (before it finishes playing) back to the previous one.
</li> <li> <strong>bDontBlendOut</strong> - If true, animation will freeze at last frame, and not blend back to the old one.
</li> <li> <strong>Rate</strong> - Playing rate of animation.
</li></ul>
</li> <li> <strong>BlendToLoopingAnim(name AnimSeqName, optional float BlendInTime, optional float Rate)</strong> - Blends in a looping animation <ul>
<li> <strong>AnimSeqName</strong> - Name of animation sequence to play.
</li> <li> <strong>BlendInTime</strong> - Time to blend from current animation to this (new) one.
</li> <li> <strong>Rate</strong> - Playing rate of animation.
</li></ul>
</li> <li> <strong>GetAnimName()</strong> - Returns the name of the animation that is currently playing
</li> <li> <strong>GetActiveChild()</strong> - Returns the active AnimNodeSequence that is currently active.
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This code snippet shows how to cross fade between two different looping animations defined in the <strong>LoopingAnimNames</strong> array with a blend time of a quarter of a second.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var(Pawn) array&#60;Name&#62; LoopingAnimNames;
var AnimNodeCrossfader AnimNodeCrossfader;
var float NextBlendTime;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeCrossfader &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodeCrossfader &#61; AnimNodeCrossfader(SkelComp.FindAnimNode(&#39;AnimNodeCrossfader&#39;));
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (AnimNodeCrossfader &#61;&#61; None)
  {
    return;
  }

  if (WorldInfo.TimeSeconds &#62;&#61; NextBlendTime)
  {
    AnimNodeCrossfader.BlendToLoopingAnim(LoopingAnimNames&#91;Rand(LoopingAnimNames.Length)], 0.25f, 1.f);
    NextBlendTime &#61; worldInfo.TimeSeconds + 2.f;
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="AnimNodePlayCustomAnim"></a> AnimNodePlayCustomAnim </h4>
<hr size="1" noshade="noshade">
This blend node gives code control to override an anim tree branch, with a custom animation. The normal branch is the normal tree branch, for example the upper body. The custom branch must be connected to an AnimNodeSequence. Thus, the blend node can then take over the upper body to play a custom animation given various parameters.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodePlayCustomAnim.jpg" alt="AnimNodePlayCustomAnim.jpg" width='800' height='372' />
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>PlayCustomAnim(name AnimName, float Rate, optional float BlendInTime, optional float BlendOutTime, optional bool bLooping, optional bool bOverride)</strong> - This function plays an animation back. <ul>
<li> <strong>AnimName</strong> - Name of the animation sequence to play.
</li> <li> <strong>Rate</strong> - Animation play back rate.
</li> <li> <strong>BlendInTime</strong> - Time in seconds to blend the animation in.
</li> <li> <strong>BlendOutTime</strong> - Time in seconds to blend the animation out.
</li> <li> <strong>bLooping</strong> - Loop the animation.
</li> <li> <strong>bOverride</strong> - If the same animation sequence is set to be played again, the animation will be played again. Otherwise, attempting to play the same animation sequence will do nothing.
</li></ul>
</li> <li> <strong>PlayCustomAnimByDuration(name AnimName, float Duration, optional float BlendInTime, optional float BlendOutTime, optional bool bLooping, optional bool bOverride)</strong> - This function makes it easier to play an animation for <em>x</em> seconds. <ul>
<li> <strong>AnimName</strong> - Name of the animation sequence to play.
</li> <li> <strong>Duration</strong> - How long in seconds this animation should play for.
</li> <li> <strong>BlendInTime</strong> - Time in seconds to blend the animation in.
</li> <li> <strong>BlendOutTime</strong> - Time in seconds to blend the animation out.
</li> <li> <strong>bLooping</strong> - Loop the animation.
</li> <li> <strong>bOverride</strong> - If the same animation sequence is set to be played again, the animation will be played again. Otherwise, attempting to play the same animation sequence will do nothing.
</li></ul>
</li> <li> <strong>StopCustomAnim(float BlendOutTime)</strong> - Stops the currently playing animation. <ul>
<li> <strong>BlendOutTime</strong> - Time in seconds to blend the animation out.
</li></ul>
</li> <li> <strong>SetCustomAnim(Name AnimName)</strong> - Switch currently played animation to another one. <ul>
<li> <strong>AnimName</strong> - Name of the animation sequence.
</li></ul>
</li> <li> <strong>SetActorAnimEndNotification(bool bNewStatus)</strong> - Enable or disable the OnAnimEnd() event. <ul>
<li> <strong>bNewStatus</strong> - True or false to enable or disable the event.
</li></ul>
</li> <li> <strong>GetCustomAnimNodeSeq()</strong> - Returns the AnimNodeSequence instance that is being used.
</li> <li> <strong>SetRootBoneAxisOption(optional ERootBoneAxis AxisX, optional ERootBoneAxis AxisY, optional ERootBoneAxis AxisZ)</strong> - Sets the root bone axis that is used for <a href="RootMotion.html" class="twikiLink">Root Motion</a>. <ul>
<li> <strong>AxisX</strong> - X Axis.
</li> <li> <strong>AxisY</strong> - Y Axis.
</li> <li> <strong>AxisZ</strong> - Z Axis.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This code snippet shows how to use the AnimNodePlayCustomAnim node. It plays back random animations defined in <strong>CustomAnimNames</strong> with a blend in and blend out time of one tenth of a second. It will also play back the same animation if it is randomly chosen again.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var(Pawn) array&#60;Name&#62; CustomAnimNames;
var AnimNodePlayCustomAnim AnimNodePlayCustomAnim;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodePlayCustomAnim &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodePlayCustomAnim &#61; AnimNodePlayCustomAnim(SkelComp.FindAnimNode(&#39;AnimNodePlayCustomAnim&#39;));
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (AnimNodePlayCustomAnim &#61;&#61; None)
  {
    return;
  }

  if (!AnimNodePlayCustomAnim.bIsPlayingCustomAnim)
  {
    AnimNodePlayCustomAnim.PlayCustomAnim(CustomAnimNames&#91;Rand(CustomAnimNames.Length)], 1.f, 0.1f, 0.1f, false, true);
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="AnimNodeScalePlayRate"></a> AnimNodeScalePlayRate </h4>
<hr size="1" noshade="noshade">
This animation node gives the anim tree control to override the input animation play rate. This would allow you to scale the animation in a single place.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeScalePlayRate.jpg" alt="AnimNodeScalePlayRate.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Scale By Value</strong> - Animation play back scale as a percentage.
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This example shows how to use the AnimNodeScalePlayRate node to scale the animation play back rate. The play back rate is scaled using Sin to perform a sinusoidal play back rhythm.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var(AnimTree) const Name ScalePlayRateAnimNodeName;
var(AnimTree) const float PlayRateOffset;

var AnimNodeScalePlayRate AnimNodeScalePlayRate;

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  if (ScalePlayRateAnimNodeName !&#61; &#39;&#39;)
  {
    AnimNodeScalePlayRate &#61; AnimNodeScalePlayRate(SkelComp.FindAnimNode(ScalePlayRateAnimNodeName));
  }
}

simulated event Destroyed()
{
  Super.Destroyed();
  AnimNodeScalePlayRate &#61; None;
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);
  AnimNodeScalePlayRate.ScaleByValue &#61; (Sin(WorldInfo.TimeSeconds + PlayRateOffset) + 1) &#42; 0.5f;
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="AnimNodeScaleRateBySpeed"></a> AnimNodeScaleRateBySpeed </h4>
<hr size="1" noshade="noshade">
This animation node gives the anim tree control to override the input animation play rate based on the size of the velocity of the owning actor.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeScaleRateBySpeed.jpg" alt="AnimNodeScaleRateBySpeed.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Base Speed</strong> - Base speed to use when evaluating the final speed. For example, this should be equivalent to the maximum speed of your pawn; 600.f by default. If the size of velocity is 600.f then the play rate will be 1.f or normal speed. If the size of the velocity is 300.f then the play rate will be 0.5f or half the speed.
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This code snippet has a pawn which will adjust its <strong>GroundSpeed</strong> depending on how much health it has. As the pawn is damaged, it will move slower and the animation will also be played back slower.
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
event TakeDamage(int Damage, Controller InstigatedBy, vector HitLocation, vector Momentum, class&#60;DamageType&#62; DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
  Super.TakeDamage(Damage, InstigatedBy, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);

  GroundSpeed &#61; default.GroundSpeed &#42; (float(Health) / float(HealthMax));
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="AnimNodeSlot"></a> AnimNodeSlot </h4>
<hr size="1" noshade="noshade">
AnimNodeSlot is also covered here in <a href="MatineeAnimControlTrack.html" class="twikiLink">Matinee Anim Control Track</a> for its use with Matinee.
<p />
Basically this node creates a "Slot" which allows Matinee, Unrealscript<!--  -->, to override an input with one or several animations.
<p />
The purpose of this node is to play animations on demand, that don't necessarily have to be witin the anim tree. The best examples are one shot animations triggered by code (idle breaks, special moves, melee attacks, executions, deaths, etc). This allows to keep the anim tree at a reasonable size yet play a great number of one shot / unique animations.
<p />
AnimNodeSlots know how to handle additive animations. By default they will add the additive animation to the Source input. But they can also treat the additive animation like normal animation data and perform a switch (if you were to have a sub branch in your tree that only dealt with additive data). For this behavior, set bAdditiveAnimationsOverrideSource to true.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeSlot.jpg" alt="AnimNodeSlot.jpg" width='800' height='287' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Early Anim End Notify</strong> - If true, then executee the OnAnimEnd event on the owning actor when we start blending out the animation. This usually improves transitions and blends, as we can start playing new animations as soon as this one starts blending out; as opposed to waiting until it is fully blended out.
</li> <li> <strong>Skip Blend When Not Rendered</strong> - Do not blend when the skeletal mesh is not visible.
</li> <li> <strong>Additive Animations Override Source</strong> - If true, then the additive animations override the source input. Otherwise additive animations are added to the source input.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>PlayCustomAnim(name AnimName, float Rate, optional float BlendInTime, optional float BlendOutTime, optional bool bLooping, optional bool bOverride, optional float StartTime, optional float EndTime)</strong> <ul>
<li> <strong>AnimName</strong> - Name of animation to play.
</li> <li> <strong>Rate</strong> - Rate that the animation should be played at.
</li> <li> <strong>BlendInTime</strong> - Time in seconds to blend in the animation.
</li> <li> <strong>BlendOutTime</strong> - Time in seconds to blend out the animation.
</li> <li> <strong>bLooping</strong> - Should the animation loop and play forever until told to stop.
</li> <li> <strong>bOverride</strong> - Play the same animation over again only if set to true.
</li> <li> <strong>StartTime</strong> - When to start the animation (e.g. start at two seconds into the animation).
</li> <li> <strong>EndTime</strong> - When to end the animation (e.g. end at four second into the animation).
</li></ul>
</li> <li> <strong>PlayCustomAnimByDuration(name AnimName, float Duration, optional float BlendInTime, optional float BlendOutTime, optional bool bLooping, optional bool bOverride)</strong> - Similar to the above function, except allowing you to control how long in seconds the animation is played over. <ul>
<li> <strong>AnimName</strong> - Name of animation to play.
</li> <li> <strong>Duration</strong> - Time in seconds the animation should be played for.
</li> <li> <strong>BlendInTime</strong> - Time in seconds to blend in the animation.
</li> <li> <strong>BlendOutTime</strong> - Time in seconds to blend out the animation.
</li> <li> <strong>bLooping</strong> - Should the animation loop and play forever until told to stop.
</li> <li> <strong>bOverride</strong> - Play the same animation over again only if set to true.
</li></ul>
</li> <li> <strong>GetPlayedAnimation()</strong> - Returns the name of the currently played animation or '' if an animation is not playing.
</li> <li> <strong>StopCustomAnim(float BlendOutTime)</strong> - Stop playing a custom animation. <ul>
<li> <strong>BlendOutTime</strong> - Time in seconds to blend out the animation.
</li></ul>
</li> <li> <strong>SetCustomAnim(Name AnimName)</strong> - Switch currently played animation to another one. <ul>
<li> <strong>AnimName</strong> - Name of animation to play.
</li></ul>
</li> <li> <strong>SetActorAnimEndNotification(bool bNewStatus)</strong> - Enable or disable the OnAnimEnd() event. <ul>
<li> <strong>bNewStatus</strong> - True of false to enable or disable the event.
</li></ul>
</li> <li> <strong>GetCustomAnimNodeSeq()</strong> - Returns AnimNodeSequence currently selected for playing animations.
</li> <li> <strong>SetRootBoneAxisOption(optional ERootBoneAxis AxisX, optional ERootBoneAxis AxisY, optional ERootBoneAxis AxisZ)</strong> - Set custom animation root bone options. <ul>
<li> <strong>AxisX</strong> - X Axis.
</li> <li> <strong>AxisY</strong> - Y Axis.
</li> <li> <strong>AxisZ</strong> - Z Axis.
</li></ul>
</li> <li> <strong>SetRootBoneRotationOption(optional ERootRotationOption AxisX, optional ERootRotationOption AxisY, optional ERootRotationOption AxisZ)</strong> - Set custom animation root rotation options. <ul>
<li> <strong>AxisX</strong> - Roll Axis.
</li> <li> <strong>AxisY</strong> - Yaw Axis.
</li> <li> <strong>AxisZ</strong> - Pitch Axis.
</li></ul>
</li> <li> <strong>AddToSynchGroup(name GroupName)</strong> - Synchronize this animation with others.  <ul>
<li> <strong>GroupName</strong> - Synchronization group name.
</li></ul>
</li> <li> <strong>TickChildWeights(float DeltaSeconds)</strong> - Advance time regarding child weights. <ul>
<li> <strong>DeltaSeconds</strong> - Time in seconds to advance the child weights.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This code snippet shows how to play back a random animation defined in <strong>CustomAnimNames</strong> half way through the previous animation. As long as AnimNodeSlot has enough slots, it will be able to tween smoothly across them.
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var(Pawn) array&#60;Name&#62; CustomAnimNames;
var AnimNodeSlot AnimNodeSlot;
var float NextAnimationTime;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeSlot &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodeSlot &#61; AnimNodeSlot(SkelComp.FindAnimNode(&#39;AnimNodeSlot&#39;));
}

simulated event Tick(float DeltaTime)
{
  local float Duration;

  Super.Tick(DeltaTime);

  if (AnimNodeSlot &#61;&#61; None)
  {
    return;
  }

  if (WorldInfo.TimeSeconds &#62;&#61; NextAnimationTime)
  {
    Duration &#61; AnimNodeSlot.PlayCustomAnim(CustomAnimNames&#91;Rand(CustomAnimNames.Length)], 1.f, 0.3f, 0.3f, false, true);
    NextAnimationTime &#61; WorldInfo.TimeSeconds + (Duration &#42; 0.5f);
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="AnimNodeSynch"></a> AnimNodeSynch </h4>
<hr size="1" noshade="noshade">
The AnimNodeSynch node is now obsolete, and replaced by the AnimGroup system found in the AnimTree node (root node of the blend tree). Please read <a href="AnimationOverview.html#AnimGroups" class="twikiAnchorLink">Animation Overview</a> for more information. AnimNodeSynch continues to be functional, but support will be discontinued, it is recommended to transition to the new system.
<p />
The screen shot below demonstrates how to add new animation groups into the Anim Tree.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeSynch.jpg" alt="AnimNodeSynch.jpg" width='800' height='615' />
<p />
Once you have set up the animation groups, you then need to set the animation node sequences to be part of the animation group.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeSynchAnimNodeSequence.jpg" alt="AnimNodeSynchAnimNodeSequence.jpg" width='800' height='615' />
<p />
<p />
<h4><a name="UDKAnimBlendByDriving / _UTAnimBlendByDriving"></a> UDKAnimBlendByDriving / UTAnimBlendByDriving </h4>
<hr size="1" noshade="noshade">
This node automatically blends to the 'Driving' branch if the owner is either driving a vehicle, or it is a vehicle being driven.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByDriving.jpg" alt="AnimNodes_UDKAnimBlendByDriving.jpg" width='800' height='340' />
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>UpdateDrivingState()</strong> - Forces an update of the driving state. This is useful if the animation blend is not currently relevant, thus not being ticked.
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByHoverboardTilt / _UTAnimBlendByHoverboardTilt"></a> UDKAnimBlendByHoverboardTilt / UTAnimBlendByHoverboardTilt </h4>
<hr size="1" noshade="noshade">
This node automatically blends between the branches to reflect the state of the player tilting on the hover board.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByHoverboardTilt.jpg" alt="AnimNodes_UDKAnimBlendByHoverboardTilt.jpg" width='800' height='313' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>TiltScale</strong> - Scales the lean weights.
</li> <li> <strong>TiltDeadZone</strong> - If the turn magnitude is below this, then the node blend to the 'Flat' branch.
</li> <li> <strong>TiltYScale</strong> - Scales the up vector used in calculating the tilt angle.
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByHoverboardTurn / _UTAnimBlendByHoverboardTurn"></a> UDKAnimBlendByHoverboardTurn / UTAnimBlendByHoverboardTurn </h4>
<hr size="1" noshade="noshade">
This node automatically blends between the branches to reflect the state of the player turning on the hover board.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByHoverboardTurn.jpg" alt="AnimNodes_UDKAnimBlendByHoverboardTurn.jpg" width='800' height='303' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>TurnScale</strong> - Scales the turning velocity, which scales the resulting weight.
</li> <li> <strong>MaxBlendPerSec</strong> - Sets the maximum blend change per second, this tweaks how fast the branches blend.
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendBySpeed / _UTAnimBlendBySpeed"></a> UDKAnimBlendBySpeed / UTAnimBlendBySpeed </h4>
<hr size="1" noshade="noshade">
This node automatically blends between 'Slow' and 'Fast' depending on the velocity of the skeletal mesh component's owner. This is simplified version of AnimBlendBySpeed.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendBySpeed.jpg" alt="AnimNodes_UDKAnimBlendBySpeed.jpg" width='800' height='340' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>MinSpeed</strong> - Minimum speed; at this or below this, the node blends to the 'Slow' branch.
</li> <li> <strong>MaxSpeed</strong> - maximum speed; at this or above this, the node blends to the 'Fast' branch.
</li></ul>
<p />
<p />
<h4><a name="UDKAnimNodeCopyBoneTranslation / _UTAnimNodeCopyBoneTranslation"></a> UDKAnimNodeCopyBoneTranslation / UTAnimNodeCopyBoneTranslation </h4>
<hr size="1" noshade="noshade">
This node automatically copies bone translations to allow the AnimTree to simulate different styles of equipping weapons. This node is used in conjection with AnimNodeAimOffset, UDKAnimNodeSeqWeap / UTAnimNodeSeqWeap and UDKAnimBlendByWeapType / UTAnimBlendByWeapType. This node detects profile changes in an attached aim node, and then updates all connected UDKAnimNodeSeqWeap / UTAnimNodeSeqWeap and UDKAnimBlendByWeapType / UTAnimBlendByWeapType nodes of the profile change. It also copies source bone transformations into the destination bone transformations.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimNodeCopyBoneTranslation.jpg" alt="AnimNodes_UDKAnimNodeCopyBoneTranslation.jpg" width='800' height='285' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>DefaultBoneCopyArray</strong> - Array of source and destination bone names. <ul>
<li> <strong>SrcBoneName</strong> - Source bone name to get the bone transformation.
</li> <li> <strong>DstBoneName</strong> - Destination bone name to set the bone transformation.
</li></ul>
</li> <li> <strong>DualWieldBoneCopyArray</strong> - Array of source and destination bone names to use if the AnimNodeAimOffset profile is named 'DualPistols'. <ul>
<li> <strong>SrcBoneName</strong> - Source bone name to get the bone transformation.
</li> <li> <strong>DstBoneName</strong> - Destination bone name to set the bone transformation.
</li></ul>
</li></ul>
<p />
<p />
<h4><a name="UDKAnimNodeJumpLeanOffset / _UTAnimNodeJumpLeanOffset"></a> UDKAnimNodeJumpLeanOffset / UTAnimNodeJumpLeanOffset </h4>
<hr size="1" noshade="noshade">
This node acts in a similar way to AnimNodeAimOffset, except that it also uses another AnimNodeAimOffset's aim as the direction. This node is used for handle interpolation so that the player's character looks like it is leaning is the correct direction as the character is jumping or falling.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimNodeJumpLeanOffset.jpg" alt="AnimNodes_UDKAnimNodeJumpLeanOffset.jpg" width='800' height='312' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>JumpLeanStrength</strong> - Amount to activate the 'jump lean' node.
</li> <li> <strong>MaxLeanChangeSpeed</strong> - How quickly the leaning can change.
</li> <li> <strong>bMultiplyByZVelocity</strong> - If we should invert the leaning when coming down.
</li> <li> <strong>bDodging</strong> - Set by native code if the player is dodging. When this is true, it will change its own profile to ControllerName_DBLJUMP.
</li> <li> <strong>bDoubleJumping</strong> - Set by native code if the player is performing a double jump. When this is true, it will change its own profile to ControllerName_DODGE.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetLeanWeight(float WeightTarget, float BlendTime)</strong> - Allows blending in and out of leaning over time. <ul>
<li> <strong>WeightTarget</strong> - Desired weight target.
</li> <li> <strong>BlendTime</strong> - Time in seconds to blend to the desired weight target.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
class ExampleUDKAnimNodeJumpLeanOffset extends Pawn
  placeable;

var UDKAnimNodeJumpLeanOffset UDKAnimNodeJumpLeanOffset;
var bool Flipper;

simulated event Destroyed()
{
  Super.Destroyed();

  UDKAnimNodeJumpLeanOffset &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  UDKAnimNodeJumpLeanOffset &#61; UDKAnimNodeJumpLeanOffset(SkelComp.FindAnimNode(&#39;UDKAnimNodeJumpLeanOffset&#39;));
  if (UDKAnimNodeJumpLeanOffset !&#61; None)
  {
    SetLeanWeight();
    SetTimer(1.f, true, NameOf(SetLeanWeight));
  }
}

simulated event SetLeanWeight()
{
  if (UDKAnimNodeJumpLeanOffset !&#61; None)
  {
    UDKAnimNodeJumpLeanOffset.SetLeanWeight((Flipper) ? 0.f : 1.f, 0.2f);
    Flipper &#61; !Flipper;
  }
}

defaultproperties
{
  Begin Object Class&#61;SkeletalMeshComponent Name&#61;PawnMesh
  End Object
  Mesh&#61;PawnMesh
  Components.Add(PawnMesh)

  Begin Object Name&#61;CollisionCylinder
    CollisionRadius&#61;+0030.0000
    CollisionHeight&#61;+0072.000000
  End Object
}
</pre>
</div>
<p />
<p />
<h3><a name="Filter"></a> Filter </h3>
<h4><a name="AnimNode_MultiBlendPerBone"></a> AnimNode_MultiBlendPerBone </h4>
<hr size="1" noshade="noshade">
This blend node allows you to create masks which have their own per bone blending and input sources. You may combine any number of masks together at different blend weights, and they can be automatically enabled or disabled based on rules you design. However it is not required and this blend node may be controlled using Unrealscript. This blend node reduces the number of nodes given it's functionality is compressed into a single blend node.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNode_MultiBlendPerBone.jpg" alt="AnimNode_MultiBlendPerBone.jpg" width='800' height='312' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Mask List</strong> - List of all the masks for this blend node. <ul>
<li> <strong>Branch List</strong> - An array of bone names and their specific weights for a given mask. <ul>
<li> <strong>Bone Name</strong> - Name of the bone to apply the blend to.
</li> <li> <strong>Per Bone Weight Increase</strong> - Percentage of the mask weight to apply to this bone.
</li></ul>
</li> <li> <strong>Desired Weight</strong> - Desired weight to set this mask.
</li> <li> <strong>Blend Time To Go</strong> - How much time left to go in seconds when blending in this mask. Not really useful within the AnimTree Editor.
</li> <li> <strong>Weight Rule List</strong> - Rules that will automatically enable or disable this mask. <ul>
<li> <strong>Node Name</strong> - Name of the node to check.
</li> <li> <strong>Weight Check</strong> - How the weight should be checked.
</li> <li> <strong>Child Index</strong> - Child index of the node to check weight for.
</li></ul>
</li> <li> <strong>Weight Based On Node Rules</strong> - Is the weight of this mask calculated based on the weight rules?
</li> <li> <strong>Disable For Non Local Human Players</strong> - If the owner is not a local human player, then ignore this branch.
</li></ul>
</li> <li> <strong>Rotation Blend Type</strong> - How rotation should be blended.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetMaskWeight(int MaskIndex, float DesiredWeight, float BlendTime)</strong> - Controls the weight of the given mask. <ul>
<li> <strong>MaskIndex</strong> - Index of the mask to apply properties to.
</li> <li> <strong>DesiredWeight</strong> - Weight to give to the mask.
</li> <li> <strong>BlendTime</strong> - Time in seconds for the mask to blend in.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var AnimNode&#95;MultiBlendPerBone AnimNode&#95;MultiBlendPerBone;
var float NextBlendTime;
var int PreviousMaskIndex;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNode&#95;MultiBlendPerBone &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNode&#95;MultiBlendPerBone &#61; AnimNode&#95;MultiBlendPerBone(SkelComp.FindAnimNode(&#39;AnimNode&#95;MultiBlendPerBone&#39;));
}

simulated event Tick(float DeltaTime)
{
  local int NewMaskIndex;

  Super.Tick(DeltaTime);

  if (AnimNode&#95;MultiBlendPerBone &#61;&#61; None)
  {
    return;
  }

  if (WorldInfo.TimeSeconds &#62;&#61; NextBlendTime)
  {
    AnimNode&#95;MultiBlendPerBone.SetMaskWeight(PreviousMaskIndex, 0.f, 0.25f);
    NewMaskIndex &#61; Rand(AnimNode&#95;MultiBlendPerBone.MaskList.Length);
    AnimNode&#95;MultiBlendPerBone.SetMaskWeight(NewMaskIndex, 1.f, 0.25f);
    PreviousMaskIndex &#61; NewMaskIndex;

    NextBlendTime &#61; worldInfo.TimeSeconds + 2.f;
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<h4><a name="AnimNodeBlendMultiBone"></a> AnimNodeBlendMultiBone </h4>
<hr size="1" noshade="noshade">
This animation node is deprecated and should not be used.
<p />
<h4><a name="AnimNodeBlendPerBone"></a> AnimNodeBlendPerBone </h4>
<hr size="1" noshade="noshade">
This is the same as AnimNodeBlend, only gives you per-bone control over how the 2 child animations are blended together. This node acts essentially as a per bone mask or filter. For example Child 1 takes the legs, and child 2 the upper body. The BranchStartBoneName array contains the bones parents that you want to mask out from Child 1, and take from Child 2. For the above example, you would put in that array the Spine1 bone name, and that would take care of the entire upper body.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendPerBone.jpg" alt="AnimNodeBlendPerBone.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Force Local Space Blend</strong> - If true, blending is done in local space rather than world space. This may help preserve some of the animation from the Source input.
</li> <li> <strong>Branch Start Bone Name</strong> - Array of bone names where the blending start at (affecting it and its children). You may have multiple bone names defined here if you wish to affect multiple disjointed parts of the skeleton.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetBlendTarget(float BlendTarget, float BlendTime)</strong> - Sets the blending target allow you to blend the bone effects in and out. <ul>
<li> <strong>BlendTarget</strong> - Target to blend to. Should be either 0 or 1.
</li> <li> <strong>BlendTime</strong> - Time to perform the blending.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var AnimNodeBlendPerBone AnimNodeBlendPerBone;
var float NextBlendTime;
var bool BlendToChildTwo;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeBlendPerBone &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodeBlendPerBone &#61; AnimNodeBlendPerBone(SkelComp.FindAnimNode(&#39;AnimNodeBlendPerBone&#39;));
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (AnimNodeBlendPerBone &#61;&#61; None)
  {
    return;
  }

  if (WorldInfo.TimeSeconds &#62;&#61; NextBlendTime)
  {
    BlendToChildTwo &#61; !BlendToChildTwo;

    AnimNodeBlendPerBone.SetBlendTarget((BlendToChildTwo) ? 1 : 0, 0.25f);
    NextBlendTime &#61; WorldInfo.TimeSeconds + 2.f;
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="UDKAnimBlendBySlotActive / _UTAnimBlendBySlotActive"></a> UDKAnimBlendBySlotActive / UTAnimBlendBySlotActive </h4>
<hr size="1" noshade="noshade">
This node blends fully to the Slot node only if the connected AnimNodeSlot is playing a custom animation or its current blend time is above zero. This blend node is useful if you want the AnimTree to automatically detect if the connected AnimSlot is playing an animation, if it is then it will automatically blend to it. This allows programmers to simply get an AnimNodeSlot to play an animation and for the AnimTree to automatically blend it in. An example of where this might be useful, is for playing back emotes that the player can trigger.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendBySlotActive.jpg" alt="AnimNodes_UDKAnimBlendBySlotActive.jpg" width='800' height='279' />
<p />
<p />
<h4><a name="UDKAnimBlendByWeapon / _UTAnimBlendByWeapon"></a> UDKAnimBlendByWeapon / UTAnimBlendByWeapon </h4>
<hr size="1" noshade="noshade">
This node blends in the 'Firing' branch when <strong>AnimFire</strong> is called. When the connected animation node sequence has stopped firing, if bLooping has been set false then AnimStopFire is called, otherwise the connected animation node sequence has it's animation changed to the looping anim sequence and is played in a looping fashion.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByWeapon.jpg" alt="AnimNodes_UDKAnimBlendByWeapon.jpg" width='800' height='332' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Looping</strong> - Is this weapon playing a looped anim.
</li> <li> <strong>Looping Anim</strong> - If set, after the fire anim completes this anim is looped instead of looping the fire anim.
</li> <li> <strong>Blend Time</strong> - Animation blending time.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>AnimFire(name FireSequence, bool bAutoFire, optional float AnimRate, optional float SpecialBlendTime, optional name LoopSequence = LoopingAnim)</strong> - Call to trigger the fire sequence. It will blend to the fire animation. If bAutoFire is specified, if LoopSequence is 'None' or unspecified, FireSequence will be looped, otherwise FireSequence will be played once and LoopSequence will be looped after that. <ul>
<li> <strong>FireSequence</strong> - Name of the animation sequence use for one off firing.
</li> <li> <strong>bAutoFire</strong> - bLooping is set to this value.
</li> <li> <strong>AnimRate</strong> - Rate to play the animation at.
</li> <li> <strong>SpecialBlendTime</strong> - If set, this will override the default BlendTime.
</li> <li> <strong>LoopSequence</strong> - Name of the animation sequence used for looping.
</li></ul>
</li> <li> <strong>AnimStopFire(optional float SpecialBlendTime)</strong> - Blends out the fire animation. This event is called automatically for non-looping fire animations; otherwise it must be called manually. <ul>
<li> <strong>SpecialBlendTime</strong> - If set, this will override the default BlendTime.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
class ExampleUDKAnimBlendByWeapon extends Pawn;

// Name of the firing weapon animation
var() const name FireSequenceName;
// Is the player holding an automatic firing weapon
var() const bool IsWeaponAutoFire;
// Animation play rate
var() const float FirePlayRate;
// Override blend  time for fire animation
var() const float FireBlendTime;
// Name of the looping firing weapon animation
var() const name LoopingFireSequenceName;

var UDKAnimBlendByWeapon UDKAnimBlendByWeapon;

simulated event Destroyed()
{
  Super.Destroyed();

  UDKAnimBlendByWeapon &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  UDKAnimBlendByWeapon &#61; UDKAnimBlendByWeapon(SkelComp.FindAnimNode(&#39;UDKAnimBlendByWeapon&#39;));
  if (UDKAnimBlendByWeapon !&#61; None)
  {
    FireWeapon();
  }
}

simulated function FireWeapon()
{
  if (UDKAnimBlendByWeapon !&#61; None)
  {
    // Start the firing animation
    UDKAnimBlendByWeapon.AnimFire(FireSequenceName, IsWeaponAutoFire, FirePlayRate, FireBlendTime, LoopingFireSequenceName);
    // After a second, stop firing
    SetTimer(1.f, false, NameOf(StopFireWeapon));
  }
}

simulated function StopFireWeapon()
{
  if (UDKAnimBlendByWeapon !&#61; None)
  {
    // Stop firing animation
    UDKAnimBlendByWeapon.AnimStopFire(FireBlendTime);
    // Restart firing in half a second
    SetTimer(0.5f, false, NameOf(FireWeapon));
  }
}

defaultproperties
{
  Begin Object Class&#61;SkeletalMeshComponent Name&#61;PawnMesh
  End Object
  Mesh&#61;PawnMesh
  Components.Add(PawnMesh)

  Begin Object Name&#61;CollisionCylinder
    CollisionRadius&#61;+0030.0000
    CollisionHeight&#61;+0072.000000
  End Object
}
</pre>
</div>
<p />
<p />
<h4><a name="UDKAnimBlendByWeapType / _UTAnimBlendByWeaponType"></a> UDKAnimBlendByWeapType / UTAnimBlendByWeaponType </h4>
<hr size="1" noshade="noshade">
This node blends in the 'Weapon' branch when anything other than the rifle is being used. This node is used in conjunction with UDKAnimNodeCopyBoneTranslation / UTAnimNodeCopyBoneTranslation, as it is that node that updates all connected UDKAnimBlendByWeapType / UTAnimBlendByWeaponType nodes. The names are fixed and cannot be changed.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByWeapType.jpg" alt="AnimNodes_UDKAnimBlendByWeapType.jpg" width='800' height='350' />
<p />
<p />
<h3><a name="Additive"></a> Additive </h3>
<h4><a name="AnimNodeAdditiveBlending"></a> AnimNodeAdditiveBlending </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to combine <a href="AdditiveAnimations.html" class="twikiLink">additive animation</a>, or a blend of additive animations, and adds it to the Source input. Target weight scales the additive animation. Additive animation can also be directly played using the AnimNodeSlot.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeAdditive.jpg" alt="AnimNodeAdditive.jpg" width='800' height='372' />
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetBlendTarget(float BlendTarget, float BlendTime)</strong> - Sets the blending target allow you to blend the bone effects in and out. <ul>
<li> <strong>BlendTarget</strong> - Target to blend to. Should be either 0 or 1.
</li> <li> <strong>BlendTime</strong> - Time to perform the blending.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var AnimNodeAdditiveBlending AnimNodeAdditiveBlending;
var float NextBlendTime;
var bool BlendToChildTwo;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeAdditiveBlending &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodeAdditiveBlending &#61; AnimNodeAdditiveBlending(SkelComp.FindAnimNode(&#39;AnimNodeAdditiveBlending&#39;));
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (AnimNodeAdditiveBlending &#61;&#61; None)
  {
    return;
  }

  if (WorldInfo.TimeSeconds &#62;&#61; NextBlendTime)
  {
    BlendToChildTwo &#61; !BlendToChildTwo;

    AnimNodeAdditiveBlending.SetBlendTarget((BlendToChildTwo) ? 1 : 0, 0.25f);
    NextBlendTime &#61; WorldInfo.TimeSeconds + 2.f;
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h3><a name="BlendBy"></a> BlendBy </h3>
<h4><a name="AnimNodeBlendByBase"></a> AnimNodeBlendByBase </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to automatically blend between the two inputs dependent on what the owning actor is based on. This is helpful in the situation where you want characters to move differently when they are standing on different kinds of surfaces.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendByBase.jpg" alt="AnimNodeBlendByBase.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Type</strong>  <ul>
<li> <strong>BBT_ByActorTag</strong> - Use the based actor's tag as the filter.
</li> <li> <strong>BBT_ByActorClass</strong> - Use the based actor's class as the filter.
</li></ul>
</li> <li> <strong>Actor Tag</strong> - Tag to match in order to blend to the <strong>Based</strong> input.
</li> <li> <strong>Actor Class</strong> - Class to match in order to blend to the <strong>Based</strong> input.
</li> <li> <strong>Blend Time</strong> - Time to blend between the two different inputs.
</li></ul>
<p />
<p />
<h4><a name="AnimNodeBlendByPhysics"></a> AnimNodeBlendByPhysics </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to automatically blend between the inputs which match the owning actor's <strong>Physics</strong> variable. This is helpful in the situation where you want characters to animate differently when they're walking, falling, swimming etc. This blend node is automatic.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendByPhysics.jpg" alt="AnimNodeBlendByPhysics.jpg" width='800' height='372' />
<p />
<h4><a name="AnimNodeBlendByPosture"></a> AnimNodeBlendByPosture </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to automatically blend between two inputs; Standing and Crouched. This blend node is only really helpful for Pawns.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendByPosture.jpg" alt="AnimNodeBlendByPosture.jpg" width='800' height='372' />
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This code snippet shows you how to use AnimNodeBlendByPosture in a Pawn class. AnimNodeBlendByPosture looks up the <strong>bIsCrouched</strong> variable within Pawn to determine it's blending state.
<p />
<div class="codetitlebar">
<em>YourPawnClass.uc</em>
</div>
<div class="codesnippet">
<pre>
simulated function Tick(float DeltaTime)
{
  local PlayerController PlayerController;

  PlayerController &#61; GetALocalPlayerController();
  if (PlayerController !&#61; None &#38;&#38; PlayerController.Pawn !&#61; None)
  {
    ShouldCrouch(VSize(PlayerController.Pawn.Location - Location) &#60;&#61; 256.f);
  }
}

defaultproperties
{
  bCanCrouch&#61;true
}
</pre>
</div>
<p />
<h4><a name="AnimNodeBlendByProperty"></a> AnimNodeBlendByProperty </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to automatically blend between inputs which best represent the named variable in the owning actor. <ul>
<li> <strong>boolean</strong> - Blend node only uses two inputs. If the boolean property is false, then the blend node will blend to the first input. If the boolean property is true, then the blend node will blend to the second input.
</li> <li> <strong>float</strong> - Blend node only uses two inputs. The float property will then blend between the two inputs. Avoid using float values outside the blend node's defined range.
</li> <li> <strong>byte</strong> - Blend node uses as many inputs as you like. Acting much like the <strong>boolean</strong> type, the blend node will blend to the corresponding indexes. Bytes have a range between 0 and 255.
</li></ul>
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendByProperty.jpg" alt="AnimNodeBlendByProperty.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Property Name</strong> - Name of the variable for the blend node to look up within the owning actor (or owning actor's base if Use Owners Base is true).
</li> <li> <strong>Use Owners Base</strong> - Check if you wish to look up the property on the owning actor's base instead of the owning actor.
</li> <li> <strong>Use Specific Blend Times</strong> - Use <strong>Blend To Child 1 Time</strong> and <strong>Blend To Child 2 Time</strong> instead of <strong>Blend Time</strong>. Useful if you've only for two inputs.
</li> <li> <strong>Blend Time</strong> - Blend time to use when switching between different indexes. Useful if the property is not a float.
</li> <li> <strong>Float Prop Min</strong> - Minimum float value to use if using a float property. Useful if the property is a float.
</li> <li> <strong>Float Pop Max</strong> - Maximum float value to use if using a float property. Useful if the property is a float.
</li> <li> <strong>Blend To Child 1 Time</strong> - Blend time to use when switching to Child 1. Useful if you've only got two inputs.
</li> <li> <strong>Blend To Child 2 Time</strong> - Blend time to use when switching to Child 2. Useful if you've only got two inputs.
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This code snippet shows you how you would use AnimNodeBlendByProperty for a boolean variable. The boolean variable <strong>MyBlendProperty</strong> will cause the AnimNodeBlendByProperty to switch between Child 0 and Child 1 every two seconds. It is not necessary to reference the animation node since AnimNodeBlendByProperty looks up the variable, defined by it's node name.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var bool MyBlendProperty;
var float NextBlendTime;

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (WorldInfo.TimeSeconds &#62;&#61; NextBlendTime)
  {
    MyBlendProperty &#61; !MyBlendProperty;
    NextBlendTime &#61; WorldInfo.TimeSeconds + 2.f;
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
This code snippet shows you how you would use AnimNodeBlendByProperty for a float variable. The float variable <strong>MyBlendProperty</strong> will cause the AnimNodeBlendProperty to interpolate between Child 0 and Child 1 using an interpolation time of two seconds. It is not necessary to reference the animation node since AnimNodeBlendByProperty looks up the variable, defined by it's node name.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var float MyBlendProperty;

simulated event PostBeginPlay()
{
  Super.PostBeginPlay();
  IsBlendingDown();
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (IsTimerActive(NameOf(IsBlendingUp)))
  {
    MyBlendProperty &#61; GetTimerCount(NameOf(IsBlendingUp)) / GetTimerRate(NameOf(IsBlendingUp));
  }
  else if (IsTimerActive(NameOf(IsBlendingDown)))
  {
    MyBlendProperty &#61; 1.f - (GetTimerCount(NameOf(IsBlendingDown)) / GetTimerRate(NameOf(IsBlendingDown)));
  }
}

simulated function IsBlendingUp()
{
  SetTimer(2.f, false, NameOf(IsBlendingDown));
}

simulated function IsBlendingDown()
{
  SetTimer(2.f, false, NameOf(IsBlendingUp));
}

defaultproperties
{
}
</pre>
</div>
<p />
This code snippet shows you how you would use AnimNodeBlendByProperty for a byte variable. The byte variable <strong>MyBlendProperty</strong> will cause the AnimNodeBlendByProperty to cycle from Child 0 to Child 4 every two seconds. It is not necessary to reference the animation node since AnimNodeBlendByProperty looks up the variable, defined by it's node name.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var byte MyBlendProperty;
var float NextBlendTime;

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (WorldInfo.TimeSeconds &#62;&#61; NextBlendTime)
  {
    MyBlendProperty++;

    if (MyBlendProperty &#62; 4)
    {
      MyBlendProperty &#61; 0;
    }

    NextBlendTime &#61; WorldInfo.TimeSeconds + 2.f;
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="AnimNodeBlendBySpeed"></a> AnimNodeBlendBySpeed </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to automatically blend between inputs between the constraints based on the size of the Velocity or Acceleration vector within the owning actor. The constraints define the bounds between each input, for example, Constraints[0] and Constraints[1] define the lower and upper bound for index 0; Constraints[1] and Constraints[2] define the lower and upper bound for index 1; and so forth. These bounds are modified by the <strong>Blend Down Perc</strong> value, set <strong>Blend Down Perc</strong> to zero if you wish to keep the bounds strict.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendBySpeed.jpg" alt="AnimNodeBlendBySpeed.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Blend Up Time</strong> - How fast to blend when going up an index.
</li> <li> <strong>Blend Down Time</strong> - How fast to blend when going down an index.
</li> <li> <strong>Blend Down Perc</strong> - Where abouts in the constraint bounds should the blend start blending down.
</li> <li> <strong>Constraints</strong> - Array of floats which define the bounds for each index. 0.f to 180.f may mean the actor is walking, 180.f to 600.f may mean the actor is running, 600.f to 1200.f may mean the actor is sprinting.
</li> <li> <strong>Use Acceleration</strong> - Use the acceleration variable in the owning actor, rather than the velocity variable.
</li> <li> <strong>Blend Up Delay</strong> - Time delay before blending up an index.
</li> <li> <strong>Blend Down Delay</strong> - Time delay before blending down an index.
</li></ul>
<p />
<p />
<h4><a name="AnimNodeBlendList"></a> AnimNodeBlendList </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to blend between inputs. This blend node must be used in conjunction with Unrealscript.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendList.jpg" alt="AnimNodeBlendList.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Play Active Child</strong> - When the active child index changes then it will play the Anim Node Sequences attached.
</li> <li> <strong>Editor Active Child Index</strong> - Child index to use within the editor. Only used by the AnimTree Editor.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetActiveChild(int ChildIndex, float BlendTime)</strong> - Sets the active child allowing you to blend between the different children. <ul>
<li> <strong>ChildIndex</strong> - Child indexto blend to.
</li> <li> <strong>BlendTime</strong> - Time to perform the blending.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var AnimNodeBlendList AnimNodeBlendList;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeBlendList &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodeBlendList &#61; AnimNodeBlendList(SkelComp.FindAnimNode(&#39;AnimNodeBlendList&#39;));
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (AnimNodeBlendList &#61;&#61; None)
  {
    return;
  }

  if (AnimNodeBlendList.BlendTimeToGo &#60;&#61; 0.f)
  {
    AnimNodeBlendList.SetActiveChild(Rand(AnimNodeBlendList.Children.Length), 0.25f);
  }
}

defaultproperties
{
}
</pre>
</div>
<p />
<p />
<h4><a name="UDKAnimBlendBase / _UTAnimBlendBase"></a> UDKAnimBlendBase / UTAnimBlendBase </h4>
<hr size="1" noshade="noshade">
This is a base class which can be used to create custom script based blend nodes.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendBase.jpg" alt="AnimNodes_UDKAnimBlendBase.jpg" width='800' height='345' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>BlendTime</strong> - How fast show a given child blend in.
</li> <li> <strong>ChildBlendTimes</strong> - Allow blend overrides.
</li> <li> <strong>bTickAnimInScript</strong> - If true, <strong>TickAnim()</strong> is called when this node is relevant or is always ticked.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>GetBlendTime(int ChildIndex, optional bool bGetDefault)</strong> <ul>
<li> <strong>ChildIndex</strong> - Returns the blend time of this child index.
</li> <li> <strong>bGetDefault</strong> - If true, then this will just return BlendTime otherwise will return <strong>ChildBlendTimes[ChildIndex]</strong>.
</li></ul>
</li> <li> <strong>GetAnimDuration(int ChildIndex)</strong> - If child is an AnimNodeSequence, find its duration at current play rate. <ul>
<li> <strong>ChildIndex</strong> - Returns the animation duration of this child index.
</li></ul>
</li> <li> <strong>TickAnim(float DeltaSeconds)</strong> - Use to implement custom anim blend functionality in Unrealscript. <ul>
<li> <strong>DeltaSeconds</strong> - Time since the last time <strong>TickAnim()</strong> was called/
</li></ul>
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByFall / _UTAnimBlendByFall"></a> UDKAnimBlendByFall / UTAnimBlendByFall </h4>
<hr size="1" noshade="noshade">
This node automatically blends to the appropriate branches depending on the state of the fall of the player.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByFall.jpg" alt="AnimNodes_UDKAnimBlendByFall.jpg" width='800' height='328' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>bIgnoreDoubleJumps</strong> - If true, double jump versions of the inputs will be ignored.
</li> <li> <strong>PreLandTime</strong> - Time before predicted landing to trigger pre-land animation.
</li> <li> <strong>PreLandStartUprightTime</strong> - Time before landing we should start becoming upright again.
</li> <li> <strong>ToDblJumpUprightTime</strong> - Time to become upright when executing double jump.
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByFlying / _UTAnimBlendByFlying"></a> UDKAnimBlendByFlying / UTAnimBlendByFlying </h4>
<hr size="1" noshade="noshade">
This node automatically blends if the pawn is flying. It also able to automatically play animations which can simulate wings opening up and wings closing up. This blend node is similar to UDKAnimBlendByDriving.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByFlying.jpg" alt="AnimNodes_UDKAnimBlendByFlying.jpg" width='800' height='335' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>StartingAnimName</strong> - Does this pawn have a special start anim to play.
</li> <li> <strong>EndingAnimName</strong> - Does this pawn have a special end anim to play.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>UpdateFlyingState()</strong> - Force an update of the flying state now.
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByHoverboarding / _UTAnimBlendByHoverboarding"></a> UDKAnimBlendByHoverboarding / UTAnimBlendByHoverboarding </h4>
<hr size="1" noshade="noshade">
This node automatically blends between different branches depending on the state of UDKVehicleSimHoverboard. The UDKVehicleSimHoverboard instance used is the one being driven by the owner of the skeletal mesh component.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByHoverboarding.jpg" alt="AnimNodes_UDKAnimBlendByHoverboarding.jpg" width='800' height='346' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strike><b>FallTimeBeforeAnim</b> - Not used.</strike>
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByHoverJump / _UTAnimBlendByHoverJump"></a> UDKAnimBlendByHoverJump / UTAnimBlendByHoverJump </h4>
<hr size="1" noshade="noshade">
This node automatically blends between different branches depending on the 'hover' state of the owner's vehicle.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByHoverboardJump.jpg" alt="AnimNodes_UDKAnimBlendByHoverboardJump.jpg" width='944' height='461' />
<p />
<p />
<h4><a name="UDKAnimBlendByIdle / _UTAnimBlendByIdle"></a> UDKAnimBlendByIdle / UTAnimBlendByIdle </h4>
<hr size="1" noshade="noshade">
This node automatically blends between idle and moving depending on the owner's velocity. If the owner's velocity is zero (or a relatively small number) then the node blend to the 'Idle' branch. Otherwise the node blends to the 'Moving' branch.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByIdle.jpg" alt="AnimNodes_UDKAnimBlendByIdle.jpg" width='1015' height='461' />
<p />
<p />
<h4><a name="UDKAnimBlendByPhysics / _UTAnimBlendByPhysics"></a> UDKAnimBlendByPhysics / UTAnimBlendByPhysics </h4>
<hr size="1" noshade="noshade">
This node is used to determine which branch to player by looking at the current physics of the pawn. It uses the current physics enum index to look inside PhysicsMap to then choose the appropriate branch to blend to. If the PhysicsMap array value is below zero, then the first branch is always used.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByPhysics.jpg" alt="AnimNodes_UDKAnimBlendByPhysics.jpg" width='800' height='341' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>PhysicsMap</strong> - Remaps the physics enum index to other branch indices.
</li> <li> <strong>LandBlendDelay</strong> - How long to delay blending to the landing animation. However, this is not used if the owner has been in the air for less than half a second.
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByPhysicsVolume / _UTAnimBlendByPhysicsVolume"></a> UDKAnimBlendByPhysicsVolume / UTAnimBlendByPhysicsVolume </h4>
<hr size="1" noshade="noshade">
This node blends between different branches based on parameters of the owner's current physics volume.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByPhysicsVolume.jpg" alt="AnimNodes_UDKAnimBlendByPhysicsVolume.jpg" width='800' height='328' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>PhysicsParamList</strong> - List of parameters to check for. <ul>
<li> <strong>ChildIndex</strong> - Index of child that should become active when the owner's physics volume matches these parameters.
</li> <li> <strong>bWaterVolume</strong> - Whether the volume is a water volume or not.
</li> <li> <strong>bCheckGravity</strong> - Whether we care about the volume's gravity.
</li> <li> <strong>MinGravity</strong> - Minimum gravity threshold for bCheckGravity.
</li> <li> <strong>MaxGravity</strong> - Maximum gravity thresholds for bCheckGravity.
</li></ul>
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>PhysicsVolumeChanged(PhysicsVolume NewVolume)</strong> - Called when the physics volume of the owner has changed. <ul>
<li> <strong>NewVolume</strong> - The PhysicsVolume the owner is in now.
</li></ul>
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByPosture / _UTAnimBlendByPosture"></a> UDKAnimBlendByPosture / UTAnimBlendByPosture </h4>
<hr size="1" noshade="noshade">
This node is used to determine if we should be playing the crouch or running animations. If the owner has bIsCrouched set to true, then the 'Crouch' branch is blended in, otherwise the 'Run' branch is blended in.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByPosture.jpg" alt="AnimNodes_UDKAnimBlendByPosture.jpg" width='800' height='365' />
<p />
<p />
<h4><a name="UDKAnimBlendByTurnInPlace / _UTAnimBlendByTurnInPlace"></a> UDKAnimBlendByTurnInPlace / UTAnimBlendByTurnInPlace </h4>
<hr size="1" noshade="noshade">
This node checks if the UDKPawn owner is turning or not. If the UDKPawn owner's absolute RootYawSpeed is above RootYawSpeedThresh, then the 'TurnInPlace' branch is blended in. Otherwise, the anim node sequence attached to the 'Idle' branch, played back an animation named 'Rotate_Settle_Rif'.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByTurnInPlace.jpg" alt="AnimNodes_UDKAnimBlendByTurnInPlace.jpg" width='1089' height='461' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Root Yaw Speed Thresh</strong> - Threshold the root yaw speed must be at before the 'TurnInPlace' branch is activated.
</li> <li> <strike><b>Turn In Place Blend Speed</b> - Not used.</strike>
</li></ul>
<p />
<p />
<h4><a name="UDKAnimBlendByVehicle / _UTAnimBlendByVehicle"></a> UDKAnimBlendByVehicle / UTAnimBlendByVehicle </h4>
<hr size="1" noshade="noshade">
This node checks if the pawn is within a vehicle. If the pawn within a vehicle, it will then attempt to match the vehicle's class with the name of a branch. If a suitable branch is found, it will then blend to that branch. If the branch index is zero, it will attempt to play an animation defined by the vehicle on the attached anim sequence node, or stop the attached anim sequence node.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimBlendByVehicle.jpg" alt="AnimNodes_UDKAnimBlendByVehicle.jpg" width='800' height='327' />
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>UpdateVehicleState()</strong> - Force an update of the vehicle state now.
</li></ul>
<p />
<p />
<h3><a name="Directional"></a> Directional </h3>
<h4><a name="AnimNodeBlendDirectional"></a> AnimNodeBlendDirectional </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to automatically blend between four inputs which represent the owning actor moving forwards, backwards, strafing left and strafing right. The blend node compares the direction of velocity or acceleration to the direction of the owning actor. Depending on the differences between the two, it will switch between the inputs.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeBlendDirectional.jpg" alt="AnimNodeBlendDirectional.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Dir Degrees Per Second</strong> - Allows you to control how quickly the directional blend should be allowed to change.
</li> <li> <strong>Single Anim At Or Above LOD</strong> - If the LOD for the mesh is at or above this value, only use a single directional animation instead of blending.
</li> <li> <strong>Use Acceleration</strong> - Use the direction of the acceleration instead of the velocity.
</li></ul>
<p />
<p />
<h3><a name="Mirror"></a> Mirror </h3>
<h4><a name="AnimNodeMirror"></a> AnimNodeMirror </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to set when to use <a href="AnimationMirroring.html" class="twikiLink">animation mirroring</a>.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeMirror.jpg" alt="AnimNodeMirror.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Enable Mirroring</strong> - Set true if you wish to mirror the input.
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This code snippet shows you how to enable and disable mirroring every two seconds.
<p />
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
var AnimNodeMirror AnimNodeMirror;
var float NextBlendTime;

simulated event Destroyed()
{
  Super.Destroyed();

  AnimNodeMirror &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  AnimNodeMirror &#61; AnimNodeMirror(SkelComp.FindAnimNode(&#39;AnimNodeMirror&#39;));
}

simulated event Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (AnimNodeMirror &#61;&#61; None)
  {
    return;
  }

  if (WorldInfo.TimeSeconds &#62;&#61; NextBlendTime)
  {
    AnimNodeMirror.bEnableMirroring &#61; !AnimNodeMirror.bEnableMirroring;
    NextBlendTime &#61; WorldInfo.TimeSeconds + 2.f;
  }
}

defaultproperties
{
}
</pre>
</div>
<h3><a name="Random"></a> Random </h3>
<h4><a name="AnimNodeRandom"></a> AnimNodeRandom </h4>
<hr size="1" noshade="noshade">
This blend node allows the Anim Tree to randomly blend between inputs set by the user.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeRandom.jpg" alt="AnimNodeRandom.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5>
AnimNodeRandom has an array called <strong>Random Info</strong>. <strong>Random Info</strong> is an array of structs. Each struct defines the properties used by the blend node which determines the randomness.
<p /> <ul>
<li> <strong>Chance</strong> - Chance that this child will be picked. If all indexes are zero, then every index has an equal chance.
</li> <li> <strong>Loop Count Min</strong> - Minimum number of loops to play this animation. If zero, only plays once.
</li> <li> <strong>Loop Cound Max</strong> - Maximum number of loops to play this animation.
</li> <li> <strong>Blend In Time</strong> - Time to blend into this index.
</li> <li> <strong>Play Rate Range</strong> - Animation play rate range. If zero, it will default to one.
</li> <li> <strong>Still Frame</strong> - If it's a still frame, don't play animation, but pick a random one and stick to it until we lose focus.
</li></ul>
<p />
<h3><a name="Animation Node Sequences"></a> Animation Node Sequences </h3>
<hr size="1" noshade="noshade">
<p />
<h4><a name="AnimNodeSequence"></a> AnimNodeSequence </h4>
<hr size="1" noshade="noshade">
This animation node outputs the animation data within an animation sequence, which resides inside an AnimSet.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeSequence.jpg" alt="AnimNodeSequence.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Anim Seq Name</strong> - Name of the animation sequence to bind to. This name will be looked for in all of the AnimSet's specified in the AnimSets array in the Skeletal Mesh Component.
</li> <li> <strong>Rate</strong> - Percentage speed at which the animation will be played back at. 1.f will play the animation back at 100% speed (normal). 0.5f will play the animation back at 50% speed (slower). 2.f will play the animation back at 200% speed (faster).
</li> <li> <strong>Playing</strong> - Is the animation currently playing?
</li> <li> <strong>Looping</strong> - Does the animation loop?
</li> <li> <strong>Cause Actor Anim End</strong> - Trigger the <strong>OnAnimEnd</strong> event within the owning actor when the animation reaches the end and stops. This does not trigger if the animation is set to looping.
</li> <li> <strong>Cause Actor Anim Play</strong> - Trigger the <strong>OnAnimPlay</strong> event within the owning actor when the animation starts.
</li> <li> <strong>Zero Root Rotation</strong> - Always return a zero rotation for the root bone of this animation.
</li> <li> <strong>Zero Root Translation</strong> - Always return a zero translation for the root bone of this animation.
</li> <li> <strong>Disable Warning When Anim Not Found</strong> - Disable the warning that appears if the anim node sequence is played with an invalid <strong>anim seq name</strong>.
</li> <li> <strong>No Notifies</strong> - If true, no anim notifies will be triggered for this anim node sequence.
</li> <li> <strong>Force Refpose When Not Playing</strong> - Forces the skeletal mesh into the ref pose when this anim node sequence is not playing. This is added as a optimization. If the anim node sequence always plays or loops, and isn't being used by the anim tree; this will skip the animation data look up thus increasing performance.
</li> <li> <strong>Current Time</strong> - Current position of the animation play back.
</li> <li> <strong>Notify Weight Threshold</strong> - Total weight that this node must be at in the final blend for notifies to be executed. This allows you to ensure that anim notifies trigger on the most dominant anim node sequence only. This is ignored if the anim node sequence is part of a group.
</li> <li> <strong>Root Bone Option</strong> <ul>
<li> <strong>RBA_Default</strong> - Leave root bone movement from animation and do not affect the owning actor's movement.
</li> <li> <strong>RBA_Discard</strong> - Discard any root bone movement, locking it to the first frame's location.
</li> <li> <strong>RBA_Translate</strong> - Discard any root bone movement, and forward its velocity to the owning actor.
</li></ul>
</li> <li> <strong>Root Rotation Option</strong> <ul>
<li> <strong>RRO_Default</strong> - Leave root bone rotation from animation and do not affect the owning actor's rotation. Does not affect the actor.
</li> <li> <strong>RRO_Discard</strong> - Discard any root bone rotation, locking it to the first frame's rotation. Does not affect the actor.
</li> <li> <strong>RRO_Extract</strong> - Discard any root bone rotation, and forward its rotation to the owning actor.
</li></ul>
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetAnim(name Sequence)</strong> - Change the animation this node is playing to the new name. Will be looked up in owning SkeletaMeshComponent's AnimSets array. <ul>
<li> <strong>Sequence</strong> - Name of the animation sequence.
</li></ul>
</li> <li> <strong>PlayAnim(bool bLoop, float InRate, float StartTime)</strong> - Start the current animation playing with the supplied parameters. <ul>
<li> <strong>bLoop</strong> - Should the animation loop and stop only when told to.
</li> <li> <strong>InRate</strong> - Rate to play the animation at.
</li> <li> <strong>StartTime</strong> - When to start the animation (e.g. start at two seconds into the animation).
</li></ul>
</li> <li> <strong>StopAnim()</strong> - Stop the current animation playing. CurrentTime will stay where it was.
</li> <li> <strong>ReplayAnim()</strong> - Calls PlayAnim with the current settings.
</li> <li> <strong>SetPosition(float NewTime, bool bFireNotifies)</strong> - Force the animation to a particular time. <ul>
<li> <strong>NewTime</strong> - New time in seconds to reposition the animation.
</li> <li> <strong>bFireNotifies</strong> - Fire off anim notifies.
</li></ul>
</li> <li> <strong>GetNormalizedPosition()</strong> - Finds out normalized position of a synchronized node given a relative position of a group. Takes into account node's relative SynchPosOffset.
</li> <li> <strong>FindGroupRelativePosition(float GroupRelativePosition)</strong> - Finds out position of a synchronized node given a relative position of a group. Takes into account node's relative SynchPosOffset.
</li> <li> <strong>FindGroupPosition(float GroupRelativePosition)</strong> <ul>
<li> <strong>GroupRelativePosition</strong> - Group relative position to find the position from. Should use values between 0.f to 1.f.
</li></ul>
</li> <li> <strong>GetGroupRelativePosition()</strong> - Get relative position of a synchronized node. Taking into account node's relative offset.
</li> <li> <strong>GetGlobalPlayRate()</strong> - Returns the global play rate of this animation. Taking into account all rate scales.
</li> <li> <strong>GetAnimPlaybackLength()</strong> - Returns the duration (in seconds) of the current animation at the current play rate. Returns 0.0 if no animation.
</li> <li> <strong>GetTimeLeft()</strong> - Returns in seconds the time left until the animation is done playing. This is assuming the play rate is not going to change.
</li> <li> <strong>SetRootBoneAxisOption(ERootBoneAxis AxisX, ERootBoneAxis AxisY, ERootBoneAxis AxisZ)</strong> - Set custom animation root bone options. <ul>
<li> <strong>AxisX</strong> - X Axis.
</li> <li> <strong>AxisY</strong> - Y Axis.
</li> <li> <strong>AxisZ</strong> - Z Axis.
</li></ul>
</li> <li> <strong>SetRootBoneRotationOption(ERootRotationOption AxisX, ERootRotationOption AxisY,ERootRotationOption AxisZ)</strong> - Sets the root bone axis that is used for <a href="RootMotion.html" class="twikiLink">Root Motion</a>. <ul>
<li> <strong>AxisX</strong> - X Axis.
</li> <li> <strong>AxisY</strong> - Y Axis.
</li> <li> <strong>AxisZ</strong> - Z Axis.
</li></ul>
</li></ul>
<p />
<p />
<h4><a name="AnimNodeSequenceBlendByAim"></a> AnimNodeSequenceBlendByAim </h4>
<hr size="1" noshade="noshade">
This animation node is very similar to AnimNodeAimOffset in that it is capable of blending between nine poses. It is much simpler the AnimNodeOffset and easier set up, but it doesn't resolve the issues as described the AnimNodeOffset. However for simplistic aiming / looking blending, this may be a useful animation node for you to use.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodeSequenceBlendByAim.jpg" alt="AnimNodeSequenceBlendByAim.jpg" width='800' height='372' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Aim</strong> <ul>
<li> <strong>X</strong> - Current horizontal aim position.
</li> <li> <strong>Y</strong> - Current vertical aim position.
</li></ul>
</li> <li> <strong>Horizontal Range</strong> <ul>
<li> <strong>X</strong> - Minimum horizontal aim.
</li> <li> <strong>Y</strong> - Maximum horizontal aim.
</li></ul>
</li> <li> <strong>Vertical Range</strong> <ul>
<li> <strong>X</strong> - Minimum vertical aim.
</li> <li> <strong>Y</strong> - Maximum vertical aim.
</li></ul>
</li> <li> <strong>Angle Offset</strong> <ul>
<li> <strong>X</strong> - Horizontal aim offset to append to <strong>Aim</strong> before processing.
</li> <li> <strong>Y</strong> - Vertical aim offset to append to <strong>Aim</strong> before processing.
</li></ul>
</li> <li> <strong>Anim Name LU</strong> - Animation which represents the avatar aiming / looking upper left.
</li> <li> <strong>Anim Name LC</strong> - Animation which represents the avatar aiming / looking left.
</li> <li> <strong>Anim Name LD</strong> - Animation which represents the avatar aiming / looking lower left.
</li> <li> <strong>Anim Name CU</strong> - Animation which represents the avatar aiming / looking up.
</li> <li> <strong>Anim Name CC</strong> - Animation which represents the avatar aiming / looking forward.
</li> <li> <strong>Anim Name CD</strong> - Animation which represents the avatar aiming / looking down.
</li> <li> <strong>Anim Name RU</strong> - Animation which represents the avatar aiming / looking upper right.
</li> <li> <strong>Anim Name RC</strong> - Animation which represents the avatar aiming / looking right.
</li> <li> <strong>Anim Name RD</strong> - Animation which represents the avatar aiming / looking lower right.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>CheckAnimsUpToDate()</strong> - Makes sure animations are updated. If you're changing any of the AnimName_XX during game, call this function afterwards.
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
This is similar to AnimNodeAimOffset, but there are no profile options with this animation node.
<p />
<h4><a name="UDKAnimNodeFramePlayer / _UTAnimNodeFramePlayer"></a> UDKAnimNodeFramePlayer / UTAnimNodeFramePlayer </h4>
<hr size="1" noshade="noshade">
This animation node is a helper animation node which allows you to set the animation position as a percentage, from 0.f to 1.f.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimNodeFramePlayer.jpg" alt="AnimNodes_UDKAnimNodeFramePlayer.jpg" width='800' height='437' />
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>SetAnimation(name Sequence, float RateScale)</strong> - Sets the animation node's animation sequence and rate scale.      <strong>Sequence</strong> - Animation sequence name.      <strong>RateScale</strong> - Rate to play the animation at.
</li> <li> <strong>SetAnimPosition(float Perc)</strong> - Sets the position of the animation based on a percentage value, from 0.f to 1.f.      <strong>Perc</strong> - Percentage to set the animation position.
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
class ExampleUDKAnimNodeFramePlayer extends Pawn
  placeable;

var UDKAnimNodeFramePlayer UDKAnimNodeFramePlayer;

simulated event Destroyed()
{
  Super.Destroyed();

  UDKAnimNodeFramePlayer &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  UDKAnimNodeFramePlayer &#61; UDKAnimNodeFramePlayer(SkelComp.FindAnimNode(&#39;UDKAnimNodeFramePlayer&#39;));
  if (UDKAnimNodeFramePlayer !&#61; None)
  {
    SetTimer(0.5f, true, NameOf(RandomizePosition));
  }
}

simulated function RandomizePosition()
{
  if (UDKAnimNodeFramePlayer !&#61; None)
  {
    UDKAnimNodeFramePlayer.SetAnimPosition(FRand());
  }
}

defaultproperties
{
  Begin Object Class&#61;SkeletalMeshComponent Name&#61;PawnMesh
  End Object
  Mesh&#61;PawnMesh
  Components.Add(PawnMesh)

  Begin Object Name&#61;CollisionCylinder
    CollisionRadius&#61;+0030.0000
    CollisionHeight&#61;+0072.000000
  End Object
}
</pre>
</div>
<p />
<p />
<h4><a name="UDKAnimNodeSequence / _UTAnimNodeSequence"></a> UDKAnimNodeSequence / UTAnimNodeSequence </h4>
<hr size="1" noshade="noshade">
This animation node keeps an internal stack of animations to play. When each animation ends, it is removed from the stack and the next animation on the stack is then played. This animation node is stopped by UDKAnimBlendByVehicle.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimNodeSequence.jpg" alt="AnimNodes_UDKAnimNodeSequence.jpg" width='800' height='405' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Auto Start</strong> - If true, this node will automatically start playing.
</li></ul>
<p />
<h5><a name="Unrealscript functions"></a><a name=" Unrealscript functions"></a>  Unrealscript functions </h5> <ul>
<li> <strong>PlayAnimation(name Sequence, float SeqRate, bool bSeqLoop)</strong> - Plays an animation. <ul>
<li> <strong>Sequence</strong> - Name of the animation sequence to play.
</li> <li> <strong>SeqRate</strong> - Rate to play the animation at.
</li> <li> <strong>bSeqLoop</strong> - True if this animation should loop.
</li></ul>
</li> <li> <strong>PlayAnimationSet(array<name> Sequences, float SeqRate, bool bLoopLast)</strong> - Plays the first animation in the Sequences array, and then adds the rest of the animations to the animation stack. <ul>
<li> <strong>Sequences</strong> - Names of the animation sequences to play.
</li> <li> <strong>SeqRate</strong> - Rate to play the animation at.
</li> <li> <strong>bLoopLast</strong> - True if the last animation should loop.
</li></ul>
</li></ul>
<p />
<h5><a name="How to use in Unrealscript"></a><a name=" How to use in Unrealscript"></a>  How to use in Unrealscript </h5>
<div class="codetitlebar">
<em>YourActorClass.uc</em>
</div>
<div class="codesnippet">
<pre>
class ExampleUDKAnimNodeSequence extends Pawn
  placeable;

// Array of anim sequences to play
var() const array&#60;Name&#62; Sequences;
// Rate to play the sequences at
var() const float SeqRate;
// If true, then the last animation will be loop
var() const bool bLoopLast;

var UDKAnimNodeSequence UDKAnimNodeSequence;

simulated event Destroyed()
{
  Super.Destroyed();

  UDKAnimNodeSequence &#61; None;
}

simulated event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
  UDKAnimNodeSequence &#61; UDKAnimNodeSequence(SkelComp.FindAnimNode(&#39;UDKAnimNodeSequence&#39;));
  if (UDKAnimNodeSequence !&#61; None)
  {
    UDKAnimNodeSequence.PlayAnimationSet(Sequences, SeqRate, bLoopLast);
  }
}

defaultproperties
{
  Begin Object Class&#61;SkeletalMeshComponent Name&#61;PawnMesh
  End Object
  Mesh&#61;PawnMesh
  Components.Add(PawnMesh)

  Begin Object Name&#61;CollisionCylinder
    CollisionRadius&#61;+0030.0000
    CollisionHeight&#61;+0072.000000
  End Object
}
</pre>
</div>
<p />
<p />
<h4><a name="UDKAnimNodeSequenceByBoneRotation / _UTAnimNodeSequenceByBoneRotation"></a> UDKAnimNodeSequenceByBoneRotation / UTAnimNodeSequenceByBoneRotation </h4>
<hr size="1" noshade="noshade">
This animation node sequence selects an animation from its list based on the rotation of the given bone relative to the rotation of the owning actor.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimNodeSequenceByBoneRotation.jpg" alt="AnimNodes_UDKAnimNodeSequenceByBoneRotation.jpg" width='800' height='416' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Bone Name</strong> - Bone whose direction should be tested.
</li> <li> <strong>Bone Axis</strong> - Axis of the bone to check.
</li> <li> <strong>Anim List</strong> - List of animations to choose from. <ul>
<li> <strong>Desired Rotation</strong> - Desired rotation of the bone to play this animation.
</li> <li> <strong>Anim Name</strong> - Name of the animation to play.
</li></ul>
</li></ul>
<p />
<p />
<h4><a name="UDKAnimNodeSeqWeapon / _UTAnimNodeSeqWeapon"></a> UDKAnimNodeSeqWeapon / UTAnimNodeSeqWeapon </h4>
<hr size="1" noshade="noshade">
This anim node sequence automatically changes the animation that is played back dependent on the owner's weapon type. This animation node is used in conjunction with UDKAnimNodeCopyBoneTranslation/UTAnimNodeCopyBoneTranslation and an AnimNodeAimOffset. The AnimNodeAimOffset profile is used to determine the owner's weapon type. The internal names that are used cannot be changed, and fit with Unreal Tournament 3's weapon categories.
<p />
<img src="rsrc/Three/AnimationNodes/AnimNodes_UDKAnimNodeSeqWeap.jpg" alt="AnimNodes_UDKAnimNodeSeqWeap.jpg" width='800' height='287' />
<p />
<h5><a name="Properties"></a><a name=" Properties"></a>  Properties </h5> <ul>
<li> <strong>Default Anim</strong> - Default animation to play when the player is holding a rifle.
</li> <li> <strong>Dual Pistol Anim</strong> - Default animation to play when the player is holding two pistols.
</li> <li> <strong>Single Pistol Anim</strong> - Default animation to play when the player is holding a pistol.
</li> <li> <strong>Shoulder Rocket Anim</strong> - Default animation to play when the player is holding a shoulder rocket.
</li> <li> <strong>Stinger Anim</strong> - Default animation to play when the player is holding a stringer (mini-gun like weapon).
</li></ul>
<p />
<p />
<h2><a name="Example"></a> Example </h2>
<hr size="1" noshade="noshade">
Using the some of the animation nodes above, this simple example shows combining them together can create logic pathways to decide how a skeletal mesh should animate given what the player's pawn is doing.
<p />
To further understand the logic, look at major pathways which determine how the rest of the tree is processed. The first major one is <strong>AnimNodeBlendByPhysics</strong>.
<p />
In this image, PHYS_Walking is currently selected. An <strong>AnimNodeSlot</strong> named FullBodySlot is inserted here to allow for full body animations to be played back. If no animation is playing, then it will go to <strong>AnimNodeBlendPerBone</strong>. This blend node is here to allow the Target <strong>AnimNodeSlot</strong> named UpperBodySlot to play upper body animations. The <strong>AnimNodeBlendPerBone</strong> will also use the Source children to derive the lower body animations and the upper body animations if it is not active. <strong>AnimNodeBlendByPosture</strong> then checks if the anim tree owner is crouching or not. If it is not crouch, <strong>AnimNodeBlendBySpeed</strong> checks if the anim tree owner is moving. If the anim tree owner is not moving, then use the <strong>AnimNodeSequence</strong> which is playing an idle animation. Otherwise, <strong>AnimNodeScaleRateBySpeed</strong> adjusts the overall play back rate, and <strong>AnimNodeBlendDirection</strong> blends together different running animations. If the anim tree owner was crouching then a similar logic is done but for crouch specific animations. To keep the run animations and crouch animations in synch, a <strong>Run</strong> synch group was created in the Anim Tree node.
<p />
If <strong>AnimNodeBlendByPhysics</strong> detects that the anim tree owner has PHYS_None applied, then an <strong>AnimNodeBlendByProperty</strong> checks if the anim tree owner is driving or not. If the anim tree owner is not driving, then the idle animation is outputted. Otherwise an <strong>AnimNodeBlendList</strong> is used to output different driving positions dependent on the vehicle being driven.
<p />
If <strong>AnimNodeBlendByPhysics</strong> detects that the anim tree owner has PHYS_Falling applied, then the falling idle animation is outputted.
<p />
If <strong>AnimNodeBlendByPhysics</strong> detects that the anim tree owner has PHYS_Swimming applied, then a similar logic to PHYS_Walking is applied by for swimming specific animations.
<p />
The results of the blending then get outputted into <strong>AnimNodeMirror</strong>. Depending if mirroring is required, this blend node may output a mirrored version or not. Lastly <strong>AnimNodeAimOffset</strong> adds different aim / look animation deltas onto the blended skeleton.
<p />
The Anim Tree reads the final skeleton and applies it to the skeletal mesh.
<p />
<a href="rsrc/Three/AnimationNodes/AnimNodeGameExample.jpg" target="_top"><img src="rsrc/Three/AnimationNodes/AnimNodeGameExample_Thumbnail.jpg" alt="AnimNodeGameExample_Thumbnail.jpg" width='800' height='237' /></a>
<p />
<p />
<h2><a name="Downloads"></a> Downloads </h2>
<hr size="1" noshade="noshade">
<p /> <ul>
<li> <a href="rsrc/Three/AnimationNodes/ExampleAnimationNodes-2011-Oct-21.zip" target="_top">Download</a> the content used in this documentation.
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
