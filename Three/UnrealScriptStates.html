<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | UnrealScriptStates    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">UnrealScriptStates  </b></div>
<div id="tooltext">
<a href="UnrealScriptStatesJP.html" class="twikiLink">日本語訳</a><br><a href="UnrealScriptStatesCH.html" class="twikiLink">中国翻译</a><br><a href="UnrealScriptStatesKR.html" class="twikiLink">한국어</a><br>

<!-- Three/UnrealScriptStates -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="UnrealScriptHome.html" class="twikiLink">UnrealScript</a></b> &gt; <b><a href="UnrealScriptReference.html" class="twikiLink">UnrealScript Language Reference</a></b> &gt; UnrealScript States
</div>
<hr size="1" noshade="noshade">
<h1><a name="UnrealScript States"></a> UnrealScript States </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="UnrealScriptStates.html#UnrealScript States"> UnrealScript States</a> <ul>
<li> <a href="UnrealScriptStates.html#Overview"> Overview</a>
</li> <li> <a href="UnrealScriptStates.html#State Labels and Latent Functions"> State Labels and Latent Functions</a>
</li> <li> <a href="UnrealScriptStates.html#State inheritance and scoping rules"> State inheritance and scoping rules</a>
</li> <li> <a href="UnrealScriptStates.html#Advanced state programming"> Advanced state programming</a> <ul>
<li> <a href="UnrealScriptStates.html#State Stacking"> State Stacking</a>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<p />
<h2><a name="Overview"></a> Overview </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
Historically, game programmers have been using the concept of states ever since games evolved past the "pong" phase. States (and what is known as "state machine programming") are a natural way of making complex object behaviour manageable. However, before UnrealScript, states have not been supported at the language level, requiring developers to create C/C++ "switch" statements based on the object's state. Such code was difficult to write and update.
<p />
UnrealScript supports states at the language level.
<p />
In UnrealScript, each actor in the world is always in one and only one state. Its state reflects the action it wants to perform. For example, moving brushes have several states like "StandOpenTimed" and "BumpOpenTimed". Pawns have several states such as "Dying", "Attacking", and "Wandering".
<p />
In UnrealScript, you can write functions and code that exist in a particular state. These functions are only called when the actor is in that state. For example, say you're writing a monster script, and you're contemplating how to handle the "SeePlayer" function. When you're wandering around, you want to attack the player you see. When you're already attacking the player, you want to continue on uninterrupted.
<p />
The easiest way to do this is by defining several states (Wandering and Attacking), and writing a different version of "Touch" in each state. UnrealScript supports this.
<p />
Before delving deeper into states, you need to understand that there are two major benefits to states, and one complication:
<p /> <ul>
<li> Benefit: States provide a simple way to write state-specific functions, so that you can handle the same function in different ways, depending on what the actor is doing.
</li> <li> Benefit: With a state, you can write special "state code", using the entire regular UnrealScript commands plus several special functions known as "latent functions". A latent function is a function that executes "slowly" (i.e. non-blocking), and may return after a certain amount of "game time" has passed. This enables you to perform time-based programming -- a major benefit which neither C, C++, nor Java offer. Namely, you can write code in the same way you conceptualize it; for example, you can write a script that says the equivalent of "open this door; pause 2 seconds; play this sound effect; open that door; release that monster and have it attack the player". You can do this with simple, linear code, and the Unreal engine takes care of the details of managing the time-based execution of the code.
</li> <li> Complication: Now that you can have functions (like <em>Touch</em>) overridden in multiple states as well as in child classes, you have the burden of figuring out exactly which "Touch" function is going to be called in a specific situation. UnrealScript provides rules which clearly delineate this process, but it is something you must be aware of if you create complex hierarchies of classes and states.
</li></ul>
<p />
Here is an example of states from the TriggerLight script:
<p />
<div class="codesnippet">
<pre>
<span style="color:#008800;">// Trigger turns the light on.</span>
state() TriggerTurnsOn
{
   function Trigger( actor Other, pawn EventInstigator )
   {
      Trigger = None;
      Direction = 1.0;
      Enable( 'Tick' );
   }
}

<span style="color:#008800;">// Trigger turns the light off.</span>
state() TriggerTurnsOff
{
   function Trigger( actor Other, pawn EventInstigator )
   {
      Trigger = None;
      Direction = -1.0;
      Enable( 'Tick' );
   }
}
</pre>
</div>
<p />
Here you are declaring two different states (TriggerTurnsOn and TriggerTurnsOff), and you're writing a different version of the Trigger function in each state. Though you could pull off this implementation without states, using states makes the code far more modular and expandable: in UnrealScript, you can easily subclass an existing class, add new states, and add new functions. If you had tried to do this without states, the resulting code would be more difficult to expand later.
<p />
A state can be declared as editable, meaning that the user can set an actor's state in UnrealEd, or not. To declare an editable state, do the following:
<p />
<div class="codesnippet">
<pre>
state() MyState
{
   ...
}
</pre>
</div>
<p />
To declare a non-editable state, do this:
<p />
<div class="codesnippet">
<pre>
state MyState
{
   ...
}
</pre>
</div>
<p />
You can also specify the automatic, or initial state that an actor should be in by using the "auto" keyword. This causes all new actors to be placed in that state when they first are activated:
<p />
<div class="codesnippet">
<pre>
auto state MyState
{
   ...
}
</pre>
</div>
<p />
<h2><a name="State Labels and Latent Functions"></a> State Labels and Latent Functions </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
In addition to functions, a state can contain one or more labels followed by UnrealScript code. For example:
<p />
<div class="codesnippet">
<pre>
auto state MyState
{
Begin:
   `log( &#34;MyState has just begun!&#34; );
   Sleep( 2.0 );
   `log( &#34;MyState has finished sleeping&#34; );
   goto(&#39;Begin&#39;);
}
</pre>
</div>
<p />
The above state code prints the message <code>"MyState has just begun!"</code>, then it pauses for two seconds, then it prints the message <code>"MyState has finished sleeping"</code>. The interesting thing in this example is the call to the latent function "Sleep": this function call doesn't return immediately, but returns after a certain amount of game time elapses. Latent functions can only be called from within state code, and not from within functions. Latent functions let you manage complex chains of events that include the passage of time.
<p />
All state code begins with a label definition; in the above example the label is named "Begin". The label provides a convenient entry point into the state code. You can use any label name in state code, but the "Begin" label is special: it is the default starting point for code in that state.
<p />
There are three main latent functions available to all actors:
<p /> <ul>
<li> Sleep( float Seconds ) pauses the state execution for a certain amount of time, and then continues.
</li> <li> FinishAnim() waits until the current animation sequence you're playing completes, and then continues. This function makes it easy to write animation-driven scripts, scripts whose execution is governed by mesh animations. For example, most of the AI scripts are animation-driven (as opposed to time-driven), because smooth animation is a key goal of the AI system.
</li> <li> FinishInterpolation() waits for the current InterpolationPoint movement to complete, and then continues.
</li></ul>
<p />
The Pawn class defines several important latent functions for actions such as navigating through the world and short-term movement. See the separate AI docs for descriptions of their usage.
<p />
Three native UnrealScript functions are particularly useful when writing state code:
<p /> <ul>
<li> The "Goto('LabelName')" function (similar to the C/C++/Basic goto) within a state causes the state code to continue executing at the specified label.
</li> <li> The special "Stop" command within a state causes the state code execution to stop. State code execution doesn't continue until you go to a new state, or go to a new label within the current state.
</li> <li> The "GotoState" function causes the actor to go to a new state, and optionally continue at a specified label (if you don't specify a label, the default is the "Begin" label). You can call GotoState from within state code, and it goes to the destination immediately. You can also call GotoState from within any function in the actor, but that does not take effect immediately: it doesn't take effect until execution returns back to the state code.
</li></ul>
<p />
Here is an example of the state concepts discussed so far:
<p />
<div class="codesnippet">
<pre>
<span style="color:#008800;">// This is the automatic state to execute.</span>
auto state Idle
{
	<span style="color:#008800;">// When touched by another actor...</span>
	function Touch( actor Other )
	{
		`log( "I was touched, so I'm going to Attacking" );
		GotoState( 'Attacking' );
		`log( "I have gone to the Attacking state" );
	}
Begin:
	`log( "I am idle..." );
	sleep( 10 );
	goto 'Begin';
}

<span style="color:#008800;">// Attacking state.</span>
state Attacking
{
Begin:
	`log( "I am executing the attacking state code" );
	...
}
</pre>
</div>
<p />
When you run this program and then go touch the actor, you will see:
<p />
<div class="codesnippet">
<pre>
I am idle...
I am idle...
I am idle...
I was touched, so I&#39;m going to Attacking
I have gone to the Attacking state
I am executing the attacking state code
</pre>
</div>
<p />
Make sure you understand this important aspect of GotoState: When you call GotoState from within a function, it does not go to the destination immediately, rather it goes there once execution returns back to the state code.
<p />
<h2><a name="State inheritance and scoping rules"></a> State inheritance and scoping rules </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
In UnrealScript, when you subclass an existing class, your new class inherits all of the variables, functions and states from its parent class. This is well-understood.
<p />
However, the addition of the state abstraction to the UnrealScript programming model adds additional twists to the inheritance and scoping rules. The complete inheritance rules are:
<p /> <ul>
<li> A new class inherits all of the variables from its parent class.
</li> <li> A new class inherits all of its parent class's non-state functions. You can override any of those inherited non-state functions. You can add entirely new non-state functions.
</li> <li> A new class inherits all of its parent class's states, including the functions and labels within those states. You can override any of the inherited state functions, and you can override any of the inherited state labels, you can add new state functions, and you can add new state labels.
</li></ul>
<p />
Here is an example of all the overriding rules:
<p />
<div class="codesnippet">
<pre>
<span style="color:#008800;">// Here is an example parent class.</span>
class MyParentClass extends Actor;

<span style="color:#008800;">// A non-state function.</span>
function MyInstanceFunction()
{
	`log( "Executing MyInstanceFunction" );
}

<span style="color:#008800;">// A state.</span>
state MyState
{
	<span style="color:#008800;">// A state function.</span>
	function MyStateFunction()
	{
		`log( "Executing MyStateFunction" );
	}
<span style="color:#008800;">// The "Begin" label.</span>
Begin:
	`log("Beginning MyState");
}

<span style="color:#008800;">// Here is an example child class.</span>
class MyChildClass extends MyParentClass;

<span style="color:#008800;">// Here I'm overriding a non-state function.</span>
function MyInstanceFunction()
{
	`log( "Executing MyInstanceFunction in child class" );
}

<span style="color:#008800;">// Here I'm redeclaring MyState so that I can override MyStateFunction.</span>
state MyState
{
	<span style="color:#008800;">// Here I'm overriding MyStateFunction.</span>
	function MyStateFunction()
	{
		`log( "Executing MyStateFunction" );
	}
<span style="color:#008800;">// Here I'm overriding the "Begin" label.</span>
Begin:
	`log( "Beginning MyState in MyChildClass" );
}
</pre>
</div>
<p />
When you have a function that is implemented globally, in one or more states, and in one or more parent classes, you need to understand which version of the function will be called in a given context. The scoping rules that resolve these complex situations are:
<p /> <ul>
<li> If the object is in a state, and an implementation of the function exists somewhere in that state (either in the actor's class or in some parent class), the most-derived state version of the function is called.
</li> <li> Otherwise, the most-derived non-state version of the function is called.
</li></ul>
<p />
<h2><a name="Advanced state programming"></a> Advanced state programming </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
If a state doesn't override a state of the same name in the parent class, then you can optionally use the "extends" keyword to make the state expand on an existing state in the current class. This is useful, for example, in a situation where you have a group of similar states (such as MeleeAttacking and RangeAttacking) that have a lot of functionality in common. In this case you could declare a base Attacking state as follows:
<p />
<div class="codesnippet">
<pre>
<span style="color:#008800;">// Base Attacking state.</span>
state Attacking
{
	<span style="color:#008800;">// Stick base functions here...</span>
}

<span style="color:#008800;">// Attacking up-close.</span>
state MeleeAttacking extends Attacking
{
	<span style="color:#008800;">// Stick specialized functions here...</span>
}

<span style="color:#008800;">// Attacking from a distance.</span>
state RangeAttacking extends Attacking
{
	<span style="color:#008800;">// Stick specialized functions here...</span>
}
</pre>
</div>
<p />
A state can optionally use the <code>ignores</code> specifier to ignore functions while in a state. The syntax for this is:
<p />
<div class="codesnippet">
<pre>
<span style="color:#008800;">// Declare a state.</span>
state Retreating
{
	<span style="color:#008800;">// Ignore the following messages...</span>
	ignores Touch, UnTouch, MyFunction;

	<span style="color:#008800;">// Stick functions here...</span>
}
</pre>
</div>
<p />
You can tell what specific state an actor is in from its "state" variable, a variable of type "name".
<p />
It is possible for an actor to be in "no state" by using <em>GotoState('')</em>. When an actor is in "no state", only its global (non-state) functions are called.
<p />
Whenever you use the <em>GotoState</em> command to set an actor's state, the engine can call two special notification functions, if you have defined them: <em>EndState()</em> and <em>BeginState()</em>. <em>EndState</em> is called in the current state immediately before the new state is begun, and <em>BeginState</em> is called immediately after the new state begins. These functions provide a convenient place to do any state-specific initialization and cleanup that your state may require.
<p />
<a name="StateStacking"></a>
<h3><a name="State Stacking"></a> State Stacking </h3>
<p />
With normal state changing you go from one state to the other without being able to return to the previous state as it was left. With state stacking this is possible. Calling the function <em>PushState</em> will change to a new state putting it on top of the stack. The current state will be frozen. When <em>PopState</em> is called the previous state will be restored and continue it's execution from the point where <em>PushState</em> was called.  <em>PushState</em> will act as a latent function when possible (only inside of state code), so code execution behavior is different if you call <em>PushState</em> from within a function.  Calling it from a function will not interrupt code execution (much like GotoState from within a function), whereas calling it from within state code will pause execution until the child state is popped (again, similar to GotoState from within state code).
<p />
A state can be put on the stack only once, trying to push the same state on the stack a second time will fail. <em>PushState</em> works just like <em>GotoState</em>, it takes the state name and an optional label for the state's entry point. The new state will receive an <em>PushedState</em> event, the current state receives a <em>PausedState</em> event. After calling <em>PopState</em> the current state receives a <em>PoppedState</em> event and the new state (the one that was next on the stack) will receive <em>ContinuedState</em>.
<p />
<div class="codesnippet">
<pre>
state FirstState
{
	function Myfunction()
	{
		doSomething();
		PushState('SecondState');
		<span style="color:#008800;">// this will be executed immediately since we're inside of a function (no latent functionality)</span>
		JustPushedSecondState();
   }

Begin:
	doSomething();
	PushState('SecondState');
	<span style="color:#008800;">// this will be executed once SecondState is popped since we're inside of a state code block (latent functionality)</span>
	JustPoppedSecondState();
}

state SecondState
{
	event PushState()
	{
		<span style="color:#008800;">// we got pushed, push back</span>
		PopState();
	}
}
</pre>
</div>
<p />
Using the function <em>IsInState</em> you will be able to check if a certain state is on the stack. This function only checks the name of the states and therefor can not be used to check on parent states. For example:
<p />
<div class="codesnippet">
<pre>
state BaseState
{
   ...
}

state ExtendedState extends BaseState
{
   ...
}
</pre>
</div>
<p />
If the active state is <code>ExtendedState</code> then <em>IsInState('BaseState')</em> will return false. Ofcourse calling <em>IsInState('BaseState', true)</em> will return true if <em>BaseState</em> is on the stack.
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
