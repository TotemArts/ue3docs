<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | ScaleformTechnicalGuide    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">ScaleformTechnicalGuide  </b></div>
<div id="tooltext">
<a href="ScaleformTechnicalGuideJP.html" class="twikiLink">日本語訳</a><br><a href="ScaleformTechnicalGuideCH.html" class="twikiLink">中国翻译</a><br><a href="ScaleformTechnicalGuideKR.html" class="twikiLink">한국어</a><br>

<!-- Three/ScaleformTechnicalGuide -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="UIAndHUDHome.html" class="twikiLink">User Interfaces &amp; HUDs</a></b> &gt; <b><a href="Scaleform.html" class="twikiLink">Scaleform GFx</a></b> &gt; Scaleform Technical Guide
</div>
<hr size="1" noshade="noshade">
<h1><a name="Scaleform Technical Guide"></a> Scaleform Technical Guide </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="ScaleformTechnicalGuide.html#Scaleform Technical Guide"> Scaleform Technical Guide</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#Overview"> Overview</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#GFxUI Components Reference"> GFxUI Components Reference</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#GFxMovie"> GFxMovie</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#GFxMoviePlayer Class"> GFxMoviePlayer Class</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#External Textures"> External Textures</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Sound Theme Bindings"> Sound Theme Bindings</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Widget Bindings"> Widget Bindings</a>
</li></ul>
</li> <li> <a href="ScaleformTechnicalGuide.html#GFxObject Class"> GFxObject Class</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#Display Info"> Display Info</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Color Transform"> Color Transform</a>
</li></ul>
</li></ul>
</li> <li> <a href="ScaleformTechnicalGuide.html#UnrealScript and _ActionScript"> UnrealScript and ActionScript</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#Call _ActionScript functions from _UnrealScript"> Call ActionScript functions from UnrealScript</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Calling _UnrealScript functions from _ActionScript"> Calling UnrealScript functions from ActionScript</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Understanding _ActionScriptSetFunction"> Understanding ActionScriptSetFunction</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Getting the original size of the SWF"> Getting the original size of the SWF</a>
</li></ul>
</li> <li> <a href="ScaleformTechnicalGuide.html#Working with Widgets"> Working with Widgets</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#Using _GFxObject Subclasses"> Using GFxObject Subclasses</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Widget Instancing"> Widget Instancing</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Widget Initialization and Binding"> Widget Initialization and Binding</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Working with Widget Display Info"> Working with Widget Display Info</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#CLIK Component Event Callbacks"> CLIK Component Event Callbacks</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Removing movies"> Removing movies</a>
</li></ul>
</li> <li> <a href="ScaleformTechnicalGuide.html#MoviePlayer Focus, Priority and Input Handling"> MoviePlayer Focus, Priority and Input Handling</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Loading Images"> Loading Images</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#Swapping Images at Runtime"> Swapping Images at Runtime</a>
</li></ul>
</li> <li> <a href="ScaleformTechnicalGuide.html#UI Sound Themes"> UI Sound Themes</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Localization in Scaleform"> Localization in Scaleform</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Testing and Debugging Scenes"> Testing and Debugging Scenes</a> <ul>
<li> <a href="ScaleformTechnicalGuide.html#Testing in the _GFxPlayer"> Testing in the GFxPlayer</a>
</li> <li> <a href="ScaleformTechnicalGuide.html#Enabling Logging"> Enabling Logging</a>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<p />
<h2><a name="Overview"></a> Overview </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
The Scaleform GFx integration in Unreal Engine 3 enables the use of interfaces and menus built in Adobe Flash Professional to be used as heads-up displays (HUDs) and menus. This document is a technical guide for programmers using the Scaleform GFx system. It will cover the major classes involved in implementing a a HUD or menu as well as explain their place in the process and their use.
<p />
<strong>Disclaimer:</strong>
<p />
Scaleform and GFx are registered trademarks of the Scaleform Corporation. Scaleform GFx © 2010 Scaleform Corporation. All rights reserved..
<p />
Adobe and Flash are either registered trademarks or trademarks of Adobe Systems Incorporated in the United States and/or other countries.
<p />
<h2><a name="GFxUI Components Reference"></a> GFxUI Components Reference </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
The <code>GFxUI</code> components make up the basic system for display Scaleform GFx interfaces. The whole process begins with a new HUD subclass. This HUD class is responsible for setting up a GFxMoviePlayer, which is in turn responsible for playing a GFxMovie. The GFxMovie contains any number of GFxObjects which handle displaying information to and interacting with the player.
<p />
<h3><a name="GFxMovie"></a> GFxMovie </h3>
<p />
The entire Scaleform GFx system revolves around the use of the GFxMovie. This is the actual Swf movie object exported from Flash and imported into the engine that contains the timeline, the ActionScript code, image resources, CLIK objects, etc. The interface the player interacts with is created by playing and manipulating these movies. As such, the majority of this document explains how to perform these actions within the confines of Unreal Engine 3.
<p />
<h3><a name="GFxMoviePlayer Class"></a> GFxMoviePlayer Class </h3>
<p />
The GFxMoviePlayer class is the base class of all classes responsible for initializing and playing a Scaleform GFx movie. This class will be subclassed in order to implement specialized functionality unique to the individual movie for which the player is responsible. The HUD class may have any number of these referenced at any time to play the various elements of the interface for your game.
<p />
<div class="regionhead" onclick="toggleRegion('MovieProps');">
	<div class="regionimage" id="region_MovieProps_image">+</div>GFxMoviePlayer Properties<span style="font-weight:normal;font-style:italic;font-size:10px;"> (click to view)</span>
</div>
<div class="regioncontent" id="region_MovieProps_content" style="display:none;">
<strong>Datastore</strong>
<p /> <ul>
<li> <strong>DataStoreBindings</strong> -
</li> <li> <strong>DataStoreSubscriber</strong> - Reference to the <code>GFxDataStoreSubscriber</code> for this movie player.
</li></ul>
<p />
<strong>Display</strong>
<p /> <ul>
<li> <strong>RenderTexture</strong> - <code>TextureRenderTarget2D</code> to which the movie should be rendered. If <code>None</code>, the movie is rendered to the frame buffer. This can be used to apply a Scaleform interface to a surface in the world.
</li> <li> <strong>bDisplayWithHudOff</strong> - If TRUE, this movie player will render even if <code>bShowHud</code> is FALSE.  Usually set to TRUE for menus, and FALSE for HUDs.
</li> <li> <strong>ExternalTextures</strong> - Array of ExternalTexture bindings that will automatically replaced when the movie player loads a new movie.
</li> <li> <strong>RenderTextureMode</strong> - Rendering modes for the player. <ul>
<li> <strong>RTM_Opaque</strong> - No blending, opaque overlay.
</li> <li> <strong>RTM_Alpha</strong> - Use with BLEND_Translucent, doesn't support add.
</li> <li> <strong>RTM_AlphaComposite</strong> - Use with BLEND_AlphaComposite.
</li></ul>
</li> <li> <strong>bEnableGammaCorrection</strong> - If TRUE, this movie will be gamma corrected before writing to the destination surface.
</li></ul>
<p />
<strong>General</strong>
<p /> <ul>
<li> <strong>MovieInfo</strong> - References the <code>SwfMovie</code> currently being played.
</li> <li> <strong>bMovieIsOpen</strong> - Whether the current movie is open. Set to TRUE when <code>Start()</code> is called, and set to FALSE when <code>Close()</code> is called.
</li> <li> <strong>LocalPlayerOwnerIndex</strong> - The index into the <code>GamePlayers</code> array in the <code>Engine</code> class for the <code>LocalPlayer</code> who owns this movie.
</li> <li> <strong>ExternalInterface</strong> - Reference to an Object that will receive <code>ExternalInterface</code> calls from ActionScript. If <code>None</code>, all <code>ExternalInterface</code> calls will be routed through the movie player itself.
</li> <li> <strong>WidgetBindings</strong> - Array of widget bindings between widget names and the <code>GFxObject</code> subclass of the associated widget.
</li></ul>
<p />
<strong>Input</strong>
<p /> <ul>
<li> <strong>Capturekeys</strong> - Array of key Names that this movie player is listening for, and will capture, i.e. keys that will not be sent on to the game.
</li> <li> <strong>FocusIgnoreKeys</strong> - Array of key Names that will be sent on to the game if this is a focus movie, i.e. all input will be sent to the movie EXCEPT these keys.
</li> <li> <strong>bAllowInput</strong> - If TRUE, this movie player will be allowed to accept input events. Defaults to TRUE.
</li> <li> <strong>bAllowFocus</strong> - If TRUE, this movie player will be allowed to accept focus events. Defaults to TRUE.
</li> <li> <strong>bOnlyOwnerFocusable</strong> - If TRUE, only the input from the <code>LocalPlayerOwner</code> can be directed here.
</li> <li> <strong>bDiscardNonOwnerInput</strong> - If TRUE, any input received from a <code>LocalPlayer</code> that is not the owner of this movie player will be discarded and not acted upon. This should be used in conjunction with <code>bOnlyOwnerFocusable</code> to make movie players that only respond to one player, but consume all input from the other players.
</li> <li> <strong>Priority</strong> - The priority of this movie player. Used to determine render and focus order when multiple movie players are open simultaneously.
</li> <li> <strong>bCaptureInput</strong> - If TRUE, this movie player will capture input.
</li> <li> <strong>bIgnoreMouseInput</strong> - If TRUE, this movie player will ignore mouse input.
</li></ul>
<p />
<strong>Playback</strong>
<p /> <ul>
<li> <strong>bWidgetsInitializedThisFrame</strong> - If TRUE, a widget within this movie player was initialized this frame.  This will cause the <code>PostWidgetInit()</code> event to be fired after the <code>Advance()</code> of the movie is complete.
</li> <li> <strong>bLogUnhandledWidgetInitializations</strong> - If TRUE, widgets that have an initialization callback that are NOT handled by <code>WidgetInitialized()</code> will log out a notification for debugging.
</li> <li> <strong>TimingMode</strong> - Timing modes for playback of the movie. <ul>
<li> <strong>TM_Game</strong> - Movie will be advanced using the game's delta time (i.e. pausing the game pauses the movie).
</li> <li> <strong>TM_Real</strong> - Movie will proceed at normal playback speed, disregarding slomo and pause.
</li></ul>
</li> <li> <strong>bAutoPlay</strong> - If TRUE, current movie will be started and advanced when the movie player is initialized, via <code>Init()</code>.
</li> <li> <strong>bPauseGameWhileActive</strong> - If TRUE, the game will pause while this movie player is open.
</li> <li> <strong>bCloseOnLevelChange</strong> - If TRUE, the movie will be closed on a level change. NOTE: Only movies using the TM_REAL timing mode can stay open during level change.
</li></ul>
<p />
<strong>Sound</strong>
<p /> <ul>
<li> <strong>SoundThemes</strong> - Array of sound theme bindings between sound theme names and actual UISoundThemes.
</li></ul>
</div>
<p />
<div class="regionhead" onclick="toggleRegion('MovieFuncs');">
	<div class="regionimage" id="region_MovieFuncs_image">+</div>GFxMoviePlayer Functions<span style="font-weight:normal;font-style:italic;font-size:10px;"> (click to view)</span>
</div>
<div class="regioncontent" id="region_MovieFuncs_content" style="display:none;">
<strong>ActionScript Accessor</strong>
<p /> <ul>
<li> <strong>GetVariable [path]</strong> - Returns the <code>ASValue</code> value of a GFxObject variable in the current movie. This generic accessor is much slower than the type-specific versions. If you know the type of the variable you are accessing, use one of those instead. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to access.
</li></ul>
</li> <li> <strong>GetVariableBool [path]</strong> - Returns the <code>bool</code> value of a GFxObject variable in the current movie. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to access.
</li></ul>
</li> <li> <strong>GetVariableNumber [path]</strong> - Returns the <code>float</code> value of a GFxObject variable in the current movie. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to access.
</li></ul>
</li> <li> <strong>GetVariableString [path]</strong> - Returns the <code>string</code> value of a GFxObject variable in the current movie. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to access.
</li></ul>
</li> <li> <strong>GetVariableObject [path] [type]</strong> - Returns the specified <code>GFxObject</code> from the current movie. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to access.
</li> <li> <strong>type</strong> - Optional. If specified, the GFxObject will only be returned if it is of this type. The returned value will not be coerced to this type, however. You will need to cast the result if you need it to be of this type.
</li></ul>
</li> <li> <strong>SetVariable [path] [Arg]</strong> - Sets the value of a <code>GFxObject</code> variable. This generic setter is much slower than the type-specific versions. If you know the type of the variable you are setting, use one of those instead. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to set the value of.
</li> <li> <strong>Arg</strong> - The <code>ASValue</code> value to set the <code>GFxObject</code> variable to.
</li></ul>
</li> <li> <strong>SetVariableBool [path] [b]</strong> - Sets the <code>bool</code> value of a <code>GFxObject</code> variable. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to set the value of.
</li> <li> <strong>b</strong> - The <code>bool</code> value to set the <code>GFxObject</code> variable to.
</li></ul>
</li> <li> <strong>SetVariableNumber [path] [f]</strong> - Sets the <code>float</code> value of a <code>GFxObject</code> variable. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to set the value of.
</li> <li> <strong>f</strong> - The <code>float</code> value to set the <code>GFxObject</code> variable to.
</li></ul>
</li> <li> <strong>SetVariableString [path] [s]</strong> - Sets the <code>string</code> value of a <code>GFxObject</code> variable. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to set the value of.
</li> <li> <strong>s</strong> - The <code>string</code> value to set the <code>GFxObject</code> variable to.
</li></ul>
</li> <li> <strong>SetVariableObject [path] [Object]</strong> - Sets the <code>GFxObject</code> value of a <code>GFxObject</code> variable. <ul>
<li> <strong>path</strong> - The path in the movie of the GFxObject to set the value of.
</li> <li> <strong>Object</strong> - The <code>GFxObject</code> value to set the <code>GFxObject</code> variable to.
</li></ul>
</li> <li> <strong>GetVariableArray [path] [index] [arg]</strong> -
</li> <li> <strong>GetVariableIntArray [path] [index] [arg]</strong> -
</li> <li> <strong>GetVariableFloatArray [path] [index] [arg]</strong> -
</li> <li> <strong>GetVariableStringArray [path] [index] [arg]</strong> -
</li> <li> <strong>SetVariableArray [path] [index] [Arg]</strong> -
</li> <li> <strong>SetVariableIntArray [path] [index] [Arg]</strong> -
</li> <li> <strong>SetVariableFloatArray [path] [index] [Arg]</strong> -
</li> <li> <strong>SetVariableStringArray [path] [index] [Arg]</strong> -
</li> <li> <strong>CreateObject [ASClass] [type]</strong> - Creates and returns a new <code>GFxObject</code> of a specific ActionScript class. <ul>
<li> <strong>ASClass</strong> - A string specifying the ActionScript class of the object to create. <strong>Note:</strong> That the ASClass specified must be available in the movie you are trying to create it in!
</li> <li> <strong>type</strong> - Optional. If specified, the newly created object will be of this type.
</li></ul>
</li> <li> <strong>CreateArray</strong> - Creates and returns an array <code>GFxObject</code>.
</li> <li> <strong>ActionScriptSetFunction [Object] [Member]</strong> - Sets a function property for the specified <code>GFxObject</code> in ActionScript to an UnrealScript delegate, using the delegate from the UnrealScript function calling this function. This is a useful method for getting callbacks from ActionScript into UnrealScript. <ul>
<li> <strong>Object</strong> - The <code>GFxObject</code> to set the function for.
</li> <li> <strong>Member</strong> - The name of the function to set.
</li></ul>
</li></ul>
<p />
<strong>ActionScript Interfaces</strong>
<p /> <ul>
<li> <strong>Invoke [method] [args]</strong> - Calls an ActionScript function on the movie, with the values from the args array as its parameters. This is slower than creating a wrapper function to call the ActionScript method using one of the ActionScript*() methods, but does not require a subclass to implement. Use this for one-off functions, or functions with variable length arguments. <ul>
<li> <strong>method</strong> - A string specifying the name of the function to invoke.
</li> <li> <strong>args</strong> - An array of <code>ASValue</code> parameters to pass to the function being invoked.
</li></ul>
</li> <li> <strong>ActionScriptVoid [path]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function with no return value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>path</strong> - The path to the function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptInt [path]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns an <code>int</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>path</strong> - The path to the function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptFloat [path]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns a <code>float</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>path</strong> - The path to the function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptString [path]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns a <code>string</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>path</strong> - The path to the function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptObject [path]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns a <code>GFxObject</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>path</strong> - The path to the function to invoke in the movie.
</li></ul>
</li></ul>
<p />
<strong>General</strong>
<p /> <ul>
<li> <strong>Start [StartPaused]</strong> - Start playing the movie and returns whether loading the movie was successful, i.e. returns FALSE if there were load errors. Can be overridden to perform other setup, but be sure to call <code>Super.Start()</code> first. <ul>
<li> <strong>StartPaused</strong> - Optional. If TRUE, the movie will be loaded and started, but paused. Defaults to FALSE.
</li></ul>
</li> <li> <strong>Advance [time]</strong> - Advances the movie by the specified time. After the movie is started via <code>Start()</code>, Advance(0.f) can be called to initialize all the objects on the first frame without actually advancing the movie. <ul>
<li> <strong>time</strong> - The amount of time in seconds to advance the movie.
</li></ul>
</li> <li> <strong>PostAdvance [DeltaTime]</strong> - Called after the movie is advanced to handle things like calling the <code>OnPostAdvance()</code> delegate, if specified. <ul>
<li> <strong>DeltaTime</strong> - The amount of time in seconds that the movie was advanced during the previous call to <code>Advance()</code>.
</li></ul>
</li> <li> <strong>OnPostAdvance [DeltaTime]</strong> - Delegate that is called each time the <code>PostAdvance()</code> function is executed. <ul>
<li> <strong>DeltaTime</strong> - The amount of time in seconds that the movie was advanced during the previous call to <code>Advance()</code>.
</li></ul>
</li> <li> <strong>SetPause [bPausePlayback]</strong> - Pauses or unpauses playback of the movie. <ul>
<li> <strong>bPausePlayback</strong> - Optional. If TRUE, the movie will be paused. Otherwise, the movie will be unpaused. Defaults to TRUE.
</li></ul>
</li> <li> <strong>Close [Unload]</strong> - Closes the current movie. <ul>
<li> <strong>Unload</strong> - Optional. If TRUE, the movie will be unloaded as well. Otherwise it will be kept in memory for future use. Defaults to TRUE.
</li></ul>
</li> <li> <strong>OnClose</strong> - Event called by the engine when a movie is closed to allow for cleanup. Subclasses should override this function.
</li> <li> <strong>ConditionalClearPause</strong> - Unpauses the game when closing the movie if the movie player is set to pause the game while the movie is open.
</li> <li> <strong>SetMovieInfo [data]</strong> - Sets the SwfMovie to be played by this movie player. <ul>
<li> <strong>data</strong> - The new SwfMovie to be played.
</li></ul>
</li> <li> <strong>SetTimingMode [mode]</strong> - Sets the timing mode of the movie to either advance with game time (respecting game pause and time dilation), or real time (disregards game pause and time dilation) <ul>
<li> <strong>mode</strong> - The new <code>GFxTimingMode</code> to use. <ul>
<li> <em>TM_Game</em> - Movie will be advanced using the game's delta time (i.e. pausing the game pauses the movie).
</li> <li> <em>TM_Real</em> - Movie will proceed at normal playback speed, disregarding slomo and pause.
</li></ul>
</li></ul>
</li> <li> <strong>SetExternalInterface [h]</strong> - Set a handler for ActionScript <code>ExternalInterface</code> calls for the movie being played. <ul>
<li> <strong>h</strong> - The Object to use as the <code>ExternalInterface</code> handler. If <code>None</code>, calls will be processed by this <code>GFxMoviePlayer</code>.
</li></ul>
</li> <li> <strong>SetExternalTexture [resource] [texture]</strong> - Specifies a resource (linkage identifier in the movie) to be replaced by the specified texture. <ul>
<li> <strong>resource</strong> - The linkage identifier in the movie to be replaced.
</li> <li> <strong>texture</strong> - The Texture to use.
</li></ul>
</li> <li> <strong>RefreshDataStoreBindings</strong> -
</li> <li> <strong>PublishDataStoreValues</strong> - Saves all the Datastore values of the <code>DataStoreSubscriber</code>.
</li> <li> <strong>SetPriority [NewPriority]</strong> - Sets the priority of the movie and updates the order of all movies using the new priority value. Used to determine the order for rendering and focus when multiple movies are open. <ul>
<li> <strong>NewPriority</strong> - The new priority to set the movie to.
</li></ul>
</li></ul>
<p />
<strong>Input</strong>
<p /> <ul>
<li> <strong>SetMovieCanRecieveFocus [bCanReceiveFocus]</strong> - Sets whether or not a movie is allowed to receive focus. <ul>
<li> <strong>bCanReceiveFocus</strong> - If TRUE, the movie will be allowed to receive focus.
</li></ul>
</li> <li> <strong>SetCanReceiveInput [bCanReceiveInput]</strong> - Sets whether or not a movie is allowed to receive input. <ul>
<li> <strong>bCanReceiveInput</strong> - If TRUE, the movie will be allowed to receive input.
</li></ul>
</li> <li> <strong>AddCaptureKey [key]</strong> - Adds a key to the list of keys that get eaten by the movie being played, and not passed down to the game. <ul>
<li> <strong>key</strong> - The Name of the key to add as a captured key.
</li></ul>
</li> <li> <strong>ClearCapturekeys</strong> - Clears the list of captured keys.
</li> <li> <strong>AddFocusIgnoreKey [key]</strong> - Adds a key to the FocusIgnore list, which prevents key presses from being sent to the movie if this is the focus movie. <ul>
<li> <strong>key</strong> - The Name of the key to be added as a FocusIgnore key.
</li></ul>
</li> <li> <strong>ClearFocusIgnoreKeys</strong> - Clears the list of FocusIgnore keys.
</li> <li> <strong>FlushPlayerInput [capturekeysonly]</strong> - Clears out all pressed keys from the player's input. <ul>
<li> <strong>capturekeysonly</strong> - If TRUE, only keys in the captured keys list are cleared from the player's input.
</li></ul>
</li> <li> <strong>FilterButtonInput [ControllerId] [ButtonName] [InputEvent]</strong> - Function stub that allows filtering of input keys. Return TRUE to trap the input, FALSE to let it pass through to GFx. Subclasses should override this function to do custom input filtering. <ul>
<li> <strong>ControllerId</strong> - The ID of the controller responsible for the input.
</li> <li> <strong>ButtonName</strong> - The Name of the button
</li> <li> <strong>InputEvent</strong> - The EInputEvent type of the input. <ul>
<li> <em>IE_Pressed</em> - A button or key was pressed.
</li> <li> <em>IE_Released</em> - A button or key was released.
</li> <li> <em>IE_Repeat</em> - A button or key is being held.
</li> <li> <em>IE_DoubleClick</em> - A button or key was pressed twice in succession.
</li> <li> <em>IE_Axis</em> - The mouse or joystick was moved.
</li> <li> <em>IE_MAX</em> -
</li></ul>
</li></ul>
</li></ul>
<p />
<strong>Viewport</strong>
<p /> <ul>
<li> <strong>GetGameViewportClient</strong> - Returns a reference to the current <code>GameViewportClient</code>.
</li> <li> <strong>SetViewport [x] [y] [width] [height]</strong> - Sets the viewport location and size for the movie being played. <ul>
<li> <strong>[x/y]</strong> - The horizontal and vertical location in pixels to place the movie in the viewport.
</li> <li> <strong>[width/height]</strong> - The width and height at which to display the movie.
</li></ul>
</li> <li> <strong>SetViewScaleMode [SM]</strong> - Sets the scale mode used by the movie <ul>
<li> <strong>SM</strong> - The <code>GFxScaleMode</code> scaling mode to use. <ul>
<li> <em>SM_NoScale</em> - No scaling is applied to the movie.
</li> <li> <em>SM_ShowAll</em> - The movie is scaled to fit completely within the viewport, keeping the aspect ratio.
</li> <li> <em>SM_ExactFit</em> - The movie is scaled to the exact dimensions of the viewport, with a border applied.
</li> <li> <em>SM_NoBorder</em> - The movie is scaled to the dimensions of the viewport, with no border applied.
</li></ul>
</li></ul>
</li> <li> <strong>SetAlignment [a]</strong> - Sets the alignment mode to use for positioning the movie in the viewport. <ul>
<li> <strong>a</strong> - The <code>GFxAlign</code> alignment mode to use. <ul>
<li> <em>Align_Center</em> - Centers the movie horizontally and vertically in the viewport.
</li> <li> <em>Align_TopCenter</em> - Centers the movie horizontally aligned to the top of the viewport.
</li> <li> <em>Align_BottomCenter</em> - Centers the movie horizontally aligned to the bottom of the viewport.
</li> <li> <em>Align_CenterLeft</em> - Centers the movie vertically aligned to the left of the viewport.
</li> <li> <em>Align_CenterRight</em> - Centers the movie vertically aligned to the right of the viewport.
</li> <li> <em>Align_TopLeft</em> - Aligns the movie to the top-left corner of the viewport.
</li> <li> <em>Align_TopRight</em> - Aligns the movie to the top-right corner of the viewport.
</li> <li> <em>Align_BottomLeft</em> - Aligns the movie to the bottom-left corner of the viewport.
</li> <li> <em>Align_BottomRight</em> - Aligns the movie to the bottom-right corner of the viewport.
</li></ul>
</li></ul>
</li> <li> <strong>GetVisibleFrameRect [x0] [y0] [x1] [y1]</strong> - Outputs the coordinates of the top-left and bottom-right corners of the current movie. <ul>
<li> <strong>[x/y]0</strong> - Out. Outputs the horizontal and vertical position in pixels of the top-left corner of the movie.
</li> <li> <strong>[x/y]1</strong> - Out. Outputs the horizontal and vertical position in pixels of the bottom-right corner of the movie.
</li></ul>
</li> <li> <strong>SetView3D [matView]</strong> -
</li> <li> <strong>SetPerspective3D [matPersp]</strong> -
</li></ul>
<p />
<strong>Widget Initialization</strong>
<p /> <ul>
<li> <strong>WidgetInitialized [WidgetName] [WidgetPath] [Widget]</strong> - Event stub called by the engine when a CLIK widget with <code>enableInitCallback</code> set to TRUE is initialized. Returns TRUE if the widget was handled, FALSE if not. Subclasses should override this function. <ul>
<li> <strong>WidgetName</strong> - The name of the widget that was initialized.
</li> <li> <strong>WidgetPath</strong> - The path to the widget that was initialized.
</li> <li> <strong>Widget</strong> - A reference to the <code>GFxObject</code> widget that was initialized.
</li></ul>
</li> <li> <strong>WidgetUnloaded [WidgetName] [WidgetPath] [Widget]</strong> - Event stub called by the engine when a CLIK widget with <code>enableInitCallback</code> set to TRUE is unloaded. Returns TRUE if the widget was handled, FALSE if not. Subclasses should override this function. <ul>
<li> <strong>WidgetName</strong> - The name of the widget that was unloaded.
</li> <li> <strong>WidgetPath</strong> - The path to the widget that was unloaded.
</li> <li> <strong>Widget</strong> - A reference to the <code>GFxObject</code> widget that was unloaded.
</li></ul>
</li> <li> <strong>PostWidgetInit</strong> - Event stub called by the engine when at least one CLIK widget with <code>enableInitCallback</code> set to TRUE has been initialized in a frame. Subclasses should override this function.
</li> <li> <strong>SetWidgetPathBinding [WidgetToBind] [Path]</strong> - Sets a widget to handle WidgetInitialized() callbacks for a given widget path. Used when you want a specific widget within the movie to handle <code>WidgetInitialized()</code> calls for its own children. The most derived path handler will be called for any given widget. <ul>
<li> <strong>WidgetToBind</strong> - The <code>GFxObject</code> Widget to bind to the path. If None the binding for the current Widget to that path will be removed.
</li> <li> <strong>Path</strong> - The path to bind the <code>GFxObject</code> Widget to.
</li></ul>
</li> <li> <strong>Init [LocPlay]</strong> - Handles the setting up of the <code>LocalPlayerIndex</code>, as well as automatically starting/advancing the movie if desired. This should be called when a new <code>GFxMoviePlayer</code> is initialized. <ul>
<li> <strong>LocPlay</strong> - The index in the <code>GamePlayers</code> array for the <code>LocalPlayer</code> that owns the movie player.
</li></ul>
</li> <li> <strong>GetLP</strong> - Returns the <code>LocalPlayer</code> that owns the movie player.
</li> <li> <strong>GetPC</strong> - Returns the <code>PlayerController</code> that owns the movie player.
</li> <li> <strong>ConsoleCommand [Command]</strong> - Executes a console command through the <code>PlayerController</code> that owns the movie. <ul>
<li> <strong>Command</strong> - The console command to execute.
</li></ul>
</li></ul>
</div>
<p />
<h4><a name="External Textures"></a> External Textures </h4>
<p />
The ExternalTexture struct stores a mapping between a movie's image resource ("Linkage" identifier on an image resource in the movie) and an Unreal texture resource.  This allows runtime remapping of the images used by the movie.  Any texture with a linkage identifier can be replaced at runtime using <code>SetExternalTexture()</code>.
<p />
See <a href="#Swapping Images at Runtime">Swapping Images at Runtime</a> for more information.
<p />
<strong>Members</strong>
<p /> <ul>
<li> <strong>Resource</strong> - The linkage identifier of the texture.
</li> <li> <strong>Texture</strong> - The texture mapped to the linkage identifier.
</li></ul>
<p />
<h4><a name="Sound Theme Bindings"></a> Sound Theme Bindings </h4>
<p />
The SoundThemeBinding struct binds a sound theme name to an actual UISoundTheme to handle sound events from objects in this movie.  Sound events can be fired by CLIK widgets or manually by the artist.  Each event contains a theme name, and an event to play.  This mapping binds the theme names specified by the artist to a UISoundTheme asset, which then binds event names to various sound cues or actions.
<p />
See <a href="#UI Sound Themes">UI Sound Themes</a> for more information.
<p />
<strong>Members</strong>
<p /> <ul>
<li> <strong>ThemeName</strong> - Name of the sound theme, specified by the artist in the movie.
</li> <li> <strong>Theme</strong> - Sound theme to handle sound events for the <code>ThemeName</code>.
</li></ul>
<p />
<h4><a name="Widget Bindings"></a> Widget Bindings </h4>
<p />
The GFxWidgetBinding struct associates a CLIK widget instance in a movie with a particular UnrealScript subclass of GFxObject, add the widget's Flash name here, and specify the class. This will cause the GFxObject parameter of WidgetInitialized() to be created as the appropriate subclass.
<p />
See <a href="#Widget Initialization and Binding">Widget Initialization and Binding</a> for more information.
<p />
<strong>Members</strong>
<p /> <ul>
<li> <strong>WidgetName</strong> - The name of the Widget in the movie.
</li> <li> <strong>WidgetClass</strong> - The GFxObject subclass to link to the <code>WidgetName</code>.
</li></ul>
<p />
<h3><a name="GFxObject Class"></a> GFxObject Class </h3>
<p />
The GFxObject class represents an element in a GFxMovie. This can technically be anything from a variable object to a function object to a displayable object, such as graphics or CLIK components.
<p />
<div class="regionhead" onclick="toggleRegion('ObjectProps');">
	<div class="regionimage" id="region_ObjectProps_image">+</div>GFxObject Properties<span style="font-weight:normal;font-style:italic;font-size:10px;"> (click to view)</span>
</div>
<div class="regioncontent" id="region_ObjectProps_content" style="display:none;"> <ul>
<li> <strong>Value</strong> - An array that stores reference information for the GFx-side <code>GFxValue</code> that this <code>GFxObject</code> refers to.
</li> <li> <strong>SubWidgetBindings</strong> - Array of <code>GFxWidgetBinding</code> for widgets that are forwarded to this widget for their <code>WidgetInitialized()</code> callback.  See GFxMoviePlayer's <code>WidgetBindings</code> for details.
</li></ul>
</div>
<p />
<div class="regionhead" onclick="toggleRegion('ObjectFuncs');">
	<div class="regionimage" id="region_ObjectFuncs_image">+</div>GFxObject Functions<span style="font-weight:normal;font-style:italic;font-size:10px;"> (click to view)</span>
</div>
<div class="regioncontent" id="region_ObjectFuncs_content" style="display:none;">
<strong>Accessor</strong>
<p /> <ul>
<li> <strong>Get [Member]</strong> - Returns the <code>ASValue</code> value of a variable. This generic accessor is much slower than the type-specific versions. If you know the type of the variable you are accessing, use one of those instead. <ul>
<li> <strong>Member</strong> - The name of the variable to access.
</li></ul>
</li> <li> <strong>GetBool [Member]</strong> - Returns the <code>bool</code> value of a variable. <ul>
<li> <strong>Member</strong> - The name of the variable to access.
</li></ul>
</li> <li> <strong>GetFloat [Member]</strong> - Returns the <code>float</code> value of a variable. <ul>
<li> <strong>Member</strong> - The name of the variable to access.
</li></ul>
</li> <li> <strong>GetString [Member]</strong> - Returns the <code>string</code> value of a variable. <ul>
<li> <strong>Member</strong> - The name of the variable to access.
</li></ul>
</li> <li> <strong>GetObject [Member] [type]</strong> - Returns the specified <code>GFxObject</code>. <ul>
<li> <strong>Member</strong> - The name of the <code>GFxObject</code> to access.
</li> <li> <strong>type</strong> - Optional. If specified, the GFxObject will only be returned if it is of this type. The returned value will not be coerced to this type, however. You will need to cast the result if you need it to be of this type.
</li></ul>
</li> <li> <strong>Set [Member] [Arg]</strong> - Sets the value of a variable. This generic setter is much slower than the type-specific versions. If you know the type of the variable you are setting, use one of those instead. <ul>
<li> <strong>Member</strong> - The name of the variable to set the value of.
</li> <li> <strong>Arg</strong> - The <code>ASValue</code> value to set the variable to.
</li></ul>
</li> <li> <strong>SetBool [Member] [b]</strong> - Sets the value of a <code>bool</code> variable. <ul>
<li> <strong>Member</strong> - The name of the variable to set the value of.
</li> <li> <strong>b</strong> - The <code>bool</code> value to set the variable to.
</li></ul>
</li> <li> <strong>SetFloat [Member] f]</strong> - Sets the value of a <code>float</code> variable. <ul>
<li> <strong>Member</strong> - The name of the variable to set the value of.
</li> <li> <strong>f</strong> - The <code>float</code> value to set the variable to.
</li></ul>
</li> <li> <strong>SetString [Member] [s] [InContext]</strong> - Sets the value of a <code>string</code> variable. <ul>
<li> <strong>Member</strong> - The name of the variable to set the value of.
</li> <li> <strong>s</strong> - The <code>string</code> value to set the variable to.
</li> <li> <strong>InContext</strong> - The TranslationContext to use when resolving any tags encountered in the text.
</li></ul>
</li> <li> <strong>SetObject [Member] [val]</strong> - Sets the value of a <code>GFxObject</code> variable. <ul>
<li> <strong>Member</strong> - The name of the variable to set the value of.
</li> <li> <strong>val</strong> - The <code>GFxObject</code> value to set the variable to.
</li></ul>
</li> <li> <strong>SetFunction [Member] [context] [fname]</strong> -
</li> <li> <strong>TranslateString [StringToTranslate] [InContext]</strong> - Translate a string for handling markup. <ul>
<li> <strong>StringToTranslate</strong> - The text to translate.
</li> <li> <strong>TranslateContext</strong> - The TranslationContext to use when resolving any tags encountered in the text.
</li></ul>
</li></ul>
<p />
<strong>Object Interface</strong>
<p /> <ul>
<li> <strong>GetDisplayInfo</strong> - Returns the <code>ASDisplayInfo</code> display info properties of the <code>GFxObject</code>.
</li> <li> <strong>GetPosition [x] [y]</strong> - Outputs the position of the <code>GFxObject</code>. <ul>
<li> <strong>x</strong> - Out. Outputs the horizontal position.
</li> <li> <strong>y</strong> - Out. Outputs the vertical position.
</li></ul>
</li> <li> <strong>GetColorTransform</strong> - Returns the <code>ASColorTransform</code> color transform of the <code>GFxObject</code>.
</li> <li> <strong>GetDisplayMatrix</strong> - Returns the transform display matrix of the <code>GFxObject</code>.
</li> <li> <strong>SetDisplayInfo [d]</strong> - Sets the display info properties of the <code>GFxObject</code>. <ul>
<li> <strong>d</strong> - The <code>ASDisplayInfo</code> containing the new display info properties.
</li></ul>
</li> <li> <strong>SetPosition [x] [y]</strong> - Sets the position of the <code>GFxObject</code>. <ul>
<li> <strong>x</strong> - The new horizontal position.
</li> <li> <strong>y</strong> - The new vertical position.
</li></ul>
</li> <li> <strong>SetColorTransform [cxform]</strong> - Sets the color transform of the <code>GFxObject</code>. <ul>
<li> <strong>cxform</strong> - The <code>ASColorTransform</code> containing the new color transform.
</li></ul>
</li> <li> <strong>SetDisplayMatrix [m]</strong> - Sets the display transform matrix of the <code>GFxObject</code>. <ul>
<li> <strong>m</strong> - The new transform matrix.
</li></ul>
</li> <li> <strong>SetDisplayMatrix3D [m]</strong> -
</li> <li> <strong>SetVisible [visible]</strong> - Sets the visibility of the <code>GFxObject</code>. <ul>
<li> <strong>visible</strong> - If TRUE, the <code>GFxObject</code> will be made visible. Otherwise, it will be hidden.
</li></ul>
</li> <li> <strong>GetText</strong> - Returns the text of the text field of this <code>GFxObject</code>.
</li> <li> <strong>SetText [text] [InContext]</strong> - Sets the text field of this <code>GFxObject</code>. <ul>
<li> <strong>text</strong> - The new text to set.
</li> <li> <strong>InContext</strong> - The TranslationContext to use when resolving any tags encountered in the text.
</li></ul>
</li></ul>
<p />
<strong>Array Accessor</strong>
<p /> <ul>
<li> <strong>GetElement [index]</strong> -
</li> <li> <strong>GetElementObject [index] [type]</strong> -
</li> <li> <strong>GetElementBool [index]</strong> -
</li> <li> <strong>GetElementFloat [index]</strong> -
</li> <li> <strong>GetElementString [index]</strong> -
</li> <li> <strong>SetElement [index] [Arg]</strong> -
</li> <li> <strong>SetElementObject [index] [val]</strong> -
</li> <li> <strong>SetElementBool [index] [b]</strong> -
</li> <li> <strong>SetElementFloat [index] [f]</strong> -
</li> <li> <strong>SetElementString [index] [s]</strong> -
</li></ul>
<p />
<strong>Array Object Interface</strong>
<p /> <ul>
<li> <strong>GetElementDisplayInfo [index]</strong> -
</li> <li> <strong>GetElementDisplayMatrix [index]</strong> -
</li> <li> <strong>SetElementDisplayInfo [index] [d]</strong> -
</li> <li> <strong>SetElementDisplayMatrix [index] [m]</strong> -
</li> <li> <strong>SetElementVisible [index] [visible]</strong> -
</li> <li> <strong>SetElementPosition [index] [x] [y]</strong> -
</li> <li> <strong>SetElementColorTransform [index] [cxform]</strong> -
</li></ul>
<p />
<strong>Array Member Accessor</strong>
<p /> <ul>
<li> <strong>GetElementMember [index] [Member]</strong> -
</li> <li> <strong>GetElementMemberObject [index] [Member] [type]</strong> -
</li> <li> <strong>GetElementMemberBool [index] [Member]</strong> -
</li> <li> <strong>GetElementMemberFloat [index] [Member]</strong> -
</li> <li> <strong>GetElementMemberString [index] [Member]</strong> -
</li> <li> <strong>SetElementMember [index] [Member] [arg]</strong> -
</li> <li> <strong>SetElementMemberObject [index] [Member] [val]</strong> -
</li> <li> <strong>SetElementMemberBool [index] [Member] [b]</strong> -
</li> <li> <strong>SetElementMemberFloat [index] [Member] [f]</strong> -
</li> <li> <strong>SetElementMemberString [index] [Member] [s]</strong> -
</li></ul>
<p />
<strong>Function Property</strong>
<p /> <ul>
<li> <strong>ActionScriptSetFunction [Member]</strong> - Sets a function property for this <code>GFxObject</code> in ActionScript to an UnrealScript delegate, using the delegate from the UnrealScript function calling this function. This is a useful method for getting callbacks from ActionScript into UnrealScript. <ul>
<li> <strong>Member</strong> - The name of the function to set.
</li></ul>
</li> <li> <strong>ActionScriptSetFunctionOn [target] [Member]</strong> - Sets a function property for the specified <code>GFxObject</code> in ActionScript to an UnrealScript delegate, using the delegate from the UnrealScript function calling this function. This is a useful method for getting callbacks from ActionScript into UnrealScript. <ul>
<li> <strong>target</strong> - The <code>GFxObject</code> to set the function for.
</li> <li> <strong>Member</strong> - The name of the function to set.
</li></ul>
</li></ul>
<p />
<strong>ActionScript Interface</strong>
<p /> <ul>
<li> <strong>Invoke [Member] [args]</strong> - Calls an ActionScript function on the movie, with the values from the args array as its parameters. This is slower than creating a wrapper function to call the ActionScript method using one of the ActionScript*() methods, but does not require a subclass to implement. Use this for one-off functions, or functions with variable length arguments. <ul>
<li> <strong>Member</strong> - A string specifying the name of the function to invoke.
</li> <li> <strong>args</strong> - An array of <code>ASValue</code> parameters to pass to the function being invoked.
</li></ul>
</li> <li> <strong>ActionScriptVoid [method]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function with no return value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>method</strong> - The function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptInt [method]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns an <code>int</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>method</strong> - The function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptFloat [method]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns a <code>float</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>method</strong> - The function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptString [method]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns a <code>string</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>method</strong> - The function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptObject [path]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns a <code>GFxObject</code> value, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>path</strong> - The path to the function to invoke in the movie.
</li></ul>
</li> <li> <strong>ActionScriptArray [path]</strong> - When called from within a UnrealScript function, invokes the specified ActionScript function that returns an array of <code>GFxObject</code> values, with the parameters of the wrapping UnrealScript function. This is the preferred method for calling ActionScript functions from UnrealScript, as it is faster than Invoke, with less overhead. <ul>
<li> <strong>path</strong> - The path to the function to invoke in the movie.
</li></ul>
</li></ul>
<p />
<strong>Movie Control</strong>
<p /> <ul>
<li> <strong>GotoAndPlay [frame]</strong> - Skips to the specified frame and begins play from there. <ul>
<li> <strong>frame</strong> - The (case-sensitive) frame label of the frame to skip to.
</li></ul>
</li> <li> <strong>GotoAndPlayI [frame]</strong> - Skips to the specified frame and begins play from there. <ul>
<li> <strong>frame</strong> - The number of the frame to skip to.
</li></ul>
</li> <li> <strong>GotoAndStop [frame]</strong> - Skips to the specified frame and stops there. <ul>
<li> <strong>frame</strong> - The (case-sensitive) frame label of the frame to skip to.
</li></ul>
</li> <li> <strong>GotoAndStopI [frame]</strong> - Skips to the specified frame and stops there. <ul>
<li> <strong>frame</strong> - The number of the frame to skip to.
</li></ul>
</li> <li> <strong>CreateEmptyMovieClip [instancename] [depth] [type]</strong> - Creates an empty MovieClip in the movie. This can then be manipulated like any other MovieClip using the above functions. <ul>
<li> <strong>instancename</strong> -
</li> <li> <strong>depth</strong> -
</li> <li> <strong>type</strong> -
</li></ul>
</li> <li> <strong>AttachMovie [symbolname] [instancename] [depth] [type]</strong> - Attaches a symbol to specified movie instance. If no instance is found in this object's scope with the InstanceName, a new instance is created and returned. <ul>
<li> <strong>symbolname</strong> -
</li> <li> <strong>instancename</strong> -
</li> <li> <strong>depth</strong> -
</li> <li> <strong>type</strong> -
</li></ul>
</li></ul>
<p />
<strong>Widget Initialization</strong> -
<p /> <ul>
<li> <strong>WidgetInitialized [WidgetName] [WidgetPath] [Widget]</strong> - Event stub called by the engine when a child widget with <code>enableInitCallback</code> set to TRUE is initialized within the path bound to this widget via <code>GFxMoviePlayer::SetWidgetPathBinding()</code>. Allows for <code>GFxObject</code> subclasses that encapsulate functionality to handle their own initialization for child widgets, instead of the GFxMoviePlayer. Returns TRUE if the widget was handled, FALSE if not. Subclasses should override this function. <ul>
<li> <strong>WidgetName</strong> - The name of the widget that was initialized.
</li> <li> <strong>WidgetPath</strong> - The path to the widget that was initialized.
</li> <li> <strong>Widget</strong> - A reference to the <code>GFxObject</code> widget that was initialized.
</li></ul>
</li> <li> <strong>WidgetUnloaded [WidgetName] [WidgetPath] [Widget]</strong> - Event stub called by the engine when a child widget with <code>enableInitCallback</code> set to TRUE is unloaded within the path bound to this widget via <code>GFxMoviePlayer::SetWidgetPathBinding()</code>. Returns TRUE if the widget was handled, FALSE if not. Subclasses should override this function. <ul>
<li> <strong>WidgetName</strong> - The name of the widget that was unloaded.
</li> <li> <strong>WidgetPath</strong> - The path to the widget that was unloaded.
</li> <li> <strong>Widget</strong> - A reference to the <code>GFxObject</code> widget that was unloaded.
</li></ul>
</li></ul>
</div>
<p />
<h4><a name="Display Info"></a> Display Info </h4>
<p />
The <code>ASDIsplayInfo</code> struct stores properties of display objects for easy and quick manipulation at runtime using. The display info for any GFxObject can be obtained, modified, and then re-applied to the object using the <code>Object Interface</code> functions described above.
<p />
For more information on working with display info, see the <a href="#Working with Widget Display Info">Working with Widget Display Info</a> section.
<p />
<strong>Members</strong>
<p /> <ul>
<li> <strong>[X/Y/Z]</strong> - The position of the <code>GFxObject</code>.
</li> <li> <strong>Rotation</strong> - The rotation of the <code>GFxObject</code> around the Z-axis.
</li> <li> <strong>[X/Y]Rotation</strong> - The rotation of the <code>GFxObject</code> around the horizontal and vertical (X and Y) axes.
</li> <li> <strong>[X/Y/Z]Scale</strong> - The scale of the <code>GFxObject</code>.
</li> <li> <strong>Alpha</strong> - The opacity in the range of [0, 1] of the <code>GFxObject</code>.
</li> <li> <strong>Visible</strong> - If TRUE, the <code>GFxObject</code> is visible. Otherwise, it is hidden.
</li> <li> <strong>has[X/Y/Z]</strong> - TRUE if the <code>GFxObject</code> has X, Y, and/or Z position information.
</li> <li> <strong>hasRotation</strong> - TRUE is the <code>GFxObject</code> has rotation information.
</li> <li> <strong>has[X/Y]Rotation</strong> - TRUE is the <code>GFxObject</code> has X and/or Y rotation information.
</li> <li> <strong>has[X/Y/Z]Scale</strong> - TRUE is the <code>GFxObject</code> has X, Y, and/or Z scale information.
</li> <li> <strong>hasAlpha</strong> - TRUE is the <code>GFxObject</code> has alpha information.
</li> <li> <strong>hasVisible</strong> - TRUE is the <code>GFxObject</code> has visibility information.
</li></ul>
<p />
<h4><a name="Color Transform"></a> Color Transform </h4>
<p />
The <code>ASColorTransform</code> struct stores color transformation information for manipulation using the <code>Object Interface</code> functions described above. The color transformation information is used to adjust the color values in display objects, such as text or images.
<p />
<strong>Members</strong>
<p /> <ul>
<li> <strong>multiply</strong> - A <code>LinearColor</code> that is multiplied by the original color of the display object.
</li> <li> <strong>add</strong> - A <code>LinearColor</code> that is added to the display object's color after being multiplied.
</li></ul>
<p />
<h2><a name="UnrealScript and _ActionScript"></a> UnrealScript and ActionScript </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
The main concepts and techniques used to communicate back and forth between UnrealScript and ActionScript are detailed below.
<p />
<h3><a name="Call _ActionScript functions from _UnrealScript"></a> Call ActionScript functions from UnrealScript </h3>
<p />
There are multiple ways to call ActionScript functions from UnrealScript, but the two preferred methods are outlined below:
<p />
<strong>Method 1:  Wrapped UnrealScript function</strong>
<p />
This method is the preferred method of calling ActionScript functions from UnrealScript.  To make the call, you "wrap" the ActionScript function call with an UnrealScript function with the same parameters and return value.  Under the hood, the Scaleform GFx ActionScript functions (<em>ActionScriptVoid</em>, <em>ActionScriptInt</em>, <em>ActionScriptFloat</em>, <em>ActionScriptString</em>, <em>ActionScriptWidget</em>, each named for their respective return type) look at their calling function's parameter list, and pass those parameters on to the ActionScript runtime.  So, for example, if you wanted to call the following ActionScript function:
<p />
<div class="codesnippet">
<pre>
public function MyActionScriptFunc(param1:String,param2:Object):Void
{
     // Do something awesome!
}
</pre>
</div>
<p />
From UnrealScript, you would create the following function:
<p />
<div class="codesnippet">
<pre>
function CallMyActionScriptFunc(string Param1, GFxObject Param2)
{
     ActionScriptVoid(&#34;MyActionScriptFunc&#34;);
}
</pre>
</div>
<p />
When called, the integration code will check the parameter list of <em>CallMyActionScriptFunc</em>, and convert those parameters to their Scaleform equivalents, and call the function in ActionScript. For ActionScript functions with return types, the other ActionScript* methods in GFxObject can be used. The return values for these functions will be the return values from ActionScript.
<p />
<strong>Method 2:  Using Invoke</strong>
<p />
This method requires more overhead with memory, because of the structs that must be created to pass in as parameters and return values. It also requires more tedious code to set up. Finally, you can't pass <em>GFxObject</em> parameters back and forth to ActionScript. Since we can't use the example above because of the <em>GFxObject</em> parameter, we'll use a new ActionScript function for this example:
<p />
<div class="codesnippet">
<pre>
public function MyActionScriptFunc(param1:String,param2:Number):Bool
{
     // Do else something awesome!
     return TRUE;
}
</pre>
</div>
<p />
The corresponding UnrealScript to call this function via the <em>Invoke</em> method would be:
<p />
<div class="codesnippet">
<pre>
function bool MyFunction()
{
     local ASValue RetVal;
     local array&#60;ASValue&#62; Parms;

     Parms&#91;0].Type &#61; AS&#95;String;
     Parms&#91;0].s &#61; Param1;

     Parms&#91;1].Type &#61; AS&#95;Number;
     Parms&#91;1].n &#61; Param2;

     RetVal &#61; Invoke(&#34;MyActionScriptFunc&#34;, Parms);

     return RetVal.b;
}
</pre>
</div>
<p />
While this method is more tedious, it doesn't strictly require a new function definition to call the ActionScript method, so it can be useful for one-off occasions when you don't wish to subclass <em>GFxObject</em> just to add a function. Also, it is the only method to call ActionScript functions with variable parameter lengths.
<p />
<h3><a name="Calling _UnrealScript functions from _ActionScript"></a> Calling UnrealScript functions from ActionScript </h3>
<p />
<strong><em>Simple Method</em></strong>: Useful for event notifications and other one-off situations.
Calling UnrealScript functions from ActionScript is much simpler than the converse.  From ActionScript, simply use the <em>ExternalInterface's Call</em> method with the name of the function you want to call in UnrealScript, and all the parameters you wish to pass.  These parameters will be converted to their UnrealScript equivalents by the engine.  The function will be looked up by name on the corresponding <em>GFxMoviePlayer</em> instance.  For example, in ActionScript:
<p />
<div class="codesnippet">
<pre>
import flash.external.ExternalInterface;
// ...
ExternalInterface.call(&#34;MyUnrealScriptFunction&#34;, param1, param2, param3);
</pre>
</div>
<p />
The above code would then look for a function called "MyUnrealScriptFunction" in the current <em>GFxMoviePlayer</em> instance in Unreal, convert the parameters to the parameters of that function in UnrealScript, and call the function. Note that the UnrealScript function's parameter list is authoritative in this case, so if the parameters passed from ActionScript cannot be cast to the UnrealScript function's parameter types, they will be NULL or their default value, as appropriate.
<p />
<strong><em>Intermediate Method</em></strong>: Useful for hooking function calls in ActionScript.
Any ActionScript function can be forced to callback to an UnrealScript delegate. To do this, you use the <em>ActionScriptSetFunction()</em> function wrapper. As an example, say that you want any ActionScript calls to the function <em>DoFancyThings()</em> in the movie root to call a delegate in UnrealScript, you could set that up with the following code in <em>GFxMoviePlayer</em>:
<p />
<div class="codesnippet">
<pre>
class MyDerivedGFxMoviePlayer extends GFxMoviePlayer;

// Called from elsewhere in script to initialize the movie
event InitializeMoviePlayer()
{
     // Sets up our delegate to be called from ActionScript
     SetupASDelegate(DoFancyThings);
}

// ...

delegate FancyThingsDelegate();

function DoFancyThings()
{
     // Code goes here...
}

function SetupASDelegate(delegate&#60;FancyThingsDelegate&#62; d)
{
     local GFxObject RootObj;

     RootObj &#61; GetVariableObject(&#34;&#95;root&#34;);
     ActionScriptSetFunction(RootObj, &#34;DoFancyThings&#34;);
}
</pre>
</div>
<p />
With the above code, after <em>SetupASDelegate()</em> is called from <em>InitializeMoviePlayer()</em>, all ActionScript calls to <em>DoFancyThings()</em> will be routed to the UnrealScript function <em>DoFancyThings()</em>. The parameters will be auto-converted from ActionScript types to Unreal types, as defined by the delegate, so the programmer is responsible for making sure they match.
<p />
Note that as with other ActionScript wrapper functions, <em>ActionScriptSetFunction()</em> grabs the delegate information from the calling function's parameters, in this case <em>SetupASDelegate()</em>. The calling function can have other parameters besides the delegate, but the first delegate encountered in the parameter list will be used as the callback.
<p />
Furthermore, in the above example, we set the function on the root of the movie. This can just as easily be any other object within the movie. There are also equivalent functions in <em>GFxObject</em> that set function delegates directly on the ActionScript object they reference. They operate in the same manner, only without the need to specify an object explicitly in the <em>ActionScriptSetFunction()</em> call.
<p />
<!--  -->
<p />
<h3><a name="Understanding _ActionScriptSetFunction"></a> Understanding ActionScriptSetFunction </h3>
ActionScriptSetFunction allows you to execute an UnrealScript function when an ActionScript function is called in the Flash file.
<p />
<strong>Example:</strong> In our hypothetical Flash file, we call a function in ActionScript called <strong>MyASFunction()</strong>, but the actual function does not exist in ActionScript, and we want to instead fire off an UnrealScript function called <strong>DoThis()</strong> whenever this function is called on in the Flash file.
<p />
<strong>Uses:</strong> This has many uses. One good use would be when you are sharing the same Flash file between many views, but want each view to handle a specific situation differently. You can then write a <strong>DoThis()</strong> function for each view in UnrealScript that does something different, without making a unique Flash file for each view. And thus, any time <strong>MyASFunction()</strong> gets called in the shared Flash file, it will execute a unique <strong>DoThis()</strong> function in UnrealScript depending upon which view you are on.
<p />
<h4><a name="Step 1"></a><a name=" Step 1"></a>  Step 1 </h4>
Define the delegate.
<p />
<div class="codesnippet">
<pre>
delegate int MyDelegate(bool bTrue);
</pre>
</div>
<p />
<h4><a name="Step 2"></a><a name=" Step 2"></a>  Step 2 </h4>
Create the <strong>DoThis()</strong> function in UnrealScript. Its parameters and return type must match the delegate definition from Step 1. This is the function that will be executed, whenever <strong>MyASFunction()</strong> is called in ActionScript.
<p />
<div class="codesnippet">
<pre>
function int DoThis(bool bTrue)
{
  local int myNum;

  myNum &#61; 5;
  `log(&#34;Do this UnrealScript function? &#34; &#64; bTrue);
  return myNum;
}
</pre>
</div>
<p />
<h4><a name="Step 3"></a><a name=" Step 3"></a>  Step 3 </h4>
Next, create the UnrealScript function that does the swapping magic. This function expects the delegate we wrote in Steps 1 and 2 as a parameter. It then caches a refernce to _global, which encompasses the entire movie, including _root. Then, it uses ActionScriptSetFunction to specify that any time <strong>MyASFunction()</strong> is called in the Flash file, to instead execute the delegate we passed it, in this case - <strong>DoThis()</strong>.
<p />
<div class="codesnippet">
<pre>
function SetMyDelegate( delegate&#60;MyDelegate&#62; InDelegate)
{
  local GFxObject &#95;global;

  &#95;global &#61; GetVariableObject(&#34;&#95;global&#34;);
  ActionScriptSetFunction(&#95;global, &#34;MyASFunction&#34;);
}
</pre>
</div>
<p />
<h4><a name="Step 4"></a><a name=" Step 4"></a>  Step 4 </h4>
Now we simply need to execute the <strong>SetMyDelegate</strong> function, and pass it the <strong>DoThis()</strong> function.
<p />
<p />
<div class="codesnippet">
<pre>
SetMyDelegate(none); // clear it first
SetMyDelegate(DoThis);
</pre>
</div>
<p />
<h4><a name="Step 5"></a><a name=" Step 5"></a>  Step 5 </h4>
Finally, in ActionScript, call the <strong>MyASFunction</strong> somehow.
<p />
<div class="codetitlebar">
ActionScript 2.0
</div>
<div class="codesnippet">
<pre>
// MyASFunction() does not actually exist in ActionScript.
// Calling it here will instead execute the DoThis() function
// found in UnrealScript.

MyASFunction(true);
</pre>
</div>
<p />
The result should be that, whenever <strong>MyASFunction()</strong> is called in the Flash file, the Unreal log will print out:
<p />
<div class="codesnippet">
Do this UnrealScript function? True
</div>
<p />
<h3><a name="Getting the original size of the SWF"></a> Getting the original size of the SWF </h3>
A code snippet which shows how you would get the original size of the SWF file in Unrealscript.
<p />
<div class="codetitlebar">
Unrealscript
</div>
<div class="codesnippet">
<pre>
var GFxObject HudMovieSize;

simulated function PostBeginPlay()
{
  Super.PostBeginPlay();
  CreateHUDMovie();

  HudMovieSize &#61; HudMovie.GetVariableObject(&#34;Stage.originalRect&#34;);
  `log(&#34;Movie Dimensions: &#34; &#64; int(HudMovieSize.GetFloat(&#34;width&#34;)) &#64; &#34;x&#34; &#64; int(HudMovieSize.GetFloat(&#34;height&#34;)));
}
</pre>
</div>
<p />
<h2><a name="Working with Widgets"></a> Working with Widgets </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
<h3><a name="Using _GFxObject Subclasses"></a> Using GFxObject Subclasses </h3>
<p />
Standard practice for complex widgets that need code-driven interaction is to make a subclass of <em>GFxObject</em> in UnrealScript to encapsulate the desired functionality, wrap calls into ActionScript functions, and add state tracking / animation playing information specific to the movie clip. To do this, simply subclass <em>GFxObject</em>, and add in your functionality.
<p />
This allows you to add ActionScript function calls using the preferred UnrealScript wrapper method (Method 1, as mentioned above in <em>"Call an ActionScript function from UnrealScript"</em>), as well as make helper functions containing timeline commands, like <em>GotoAndPlay()</em>, for movie clip control.
<p />
In order to get a reference to an ActionScript widget using your new subclass, you can use either of the two methods outlined below.
<p />
<strong>Method 1: Using</strong> <strong><em>GetObject()</em></strong>
The simplest way to get a widget reference of your desired subclass is to specify a class as the second parameter of <em>GetVariableObject()</em> (if called from a GFxMoviePlayer) or <em>GetObject()</em> (if called from a GFxObject). This causes the reference returned to be a newly constructed instance of the specified class. Unfortunately, since this is an optional parameter, and not the first parameter in the function, the return type is not coerced, and therefore must be manually cast, as below:
<p />
<div class="codesnippet">
<pre>
local MyGFxObjectSubclass Widget;
Widget &#61; MyGFxObjectSubclass( GetVariableObject(&#34;MyGFxObjectName&#34;, class&#39;MyGFxObjectSubclass&#39; );
</pre>
</div>
<p />
<strong>Method 2: Using</strong> <strong><em>WidgetBindings</em></strong> or <strong><em>SubWidgetBindings</em></strong>
Widgets that have <em>WidgetInitialized()</em> callbacks can be added to the <em>GFxMoviePlayer's WidgetBindings</em> array if they are handled by the movie player itself, or by <em>GFxObject's SubWidgetBindings</em> array if they are forwarded to a GFxObject via <em>SetWidgetPathBinding()</em>. When <em>WidgetInitialized()</em> gets called for that widget, it will have a class passed in of the appropriate subclass of <em>GFxObject</em>, as specified in the <em>WidgetBindings / SubWidgetBindings</em>  array. For details on this, see the "Use <em>WidgetInitialized()</em> and WidgetBindings for initialization and binding" section below.
<p />
<h3><a name="Widget Instancing"></a> Widget Instancing </h3>
<p />
To instance a widget from UnrealScript, simply call <em>GFxObject's AttachMovie()</em> with a symbol name, and an instance name. Note that the movie clip symbol must be in the library to be instanced! If you have another clip in the scene of the same type you wish to create, however, this will always be the case. Use the following code as a template. In this example, we create a new button with an instance name of "mc_MyNewButton" by creating a new instance of the button symbol called "btn":
<p />
<div class="codesnippet">
<pre>
function MyUnrealScriptFunction()
{
     local GFxObject MyNewWidget;

     MyNewWidget &#61; GetVariableObject(&#34;&#95;root&#34;).AttachMovie(&#34;btn&#34;, &#34;mc&#95;MyNewButton&#34;);
}
</pre>
</div>
<p />
Note that in this case, we create the button relative to the root of the movie. Since <em>AttachMovie()</em> is a function of <em>GFxObject</em>, however, you can create the new movie clip instance as a child of whatever you would like (the <em>GFxObject</em> that you called <em>AttachMovie()</em> from will be the new object's parent).  The object can then be manipulated the same as any other <em>GFxObject</em>.
<p />
<a name="WidgetInitialization"></a>
<h3><a name="Widget Initialization and Binding"></a> Widget Initialization and Binding </h3>
<p />
Often, it is useful to have a callback when certain widgets are initialized on the timeline.  This is especially important when widgets do not exist on the first frame!  Since ActionScript has no knowledge or a widget until its first appearance on the timeline, we have added a <em>WidgetInitialized()</em> callback that gets fired when ActionScript creates a widget.
<p /> <ul>
<li> The <em>WidgetInitialized()</em> is only called for CLIK widgets that have <em>enableInitCallback</em> set to true!  This is to cut down on the ActionScript to engine calls, as not all widgets (such as those which are decorative or rarely changed by code) will need this functionality.  The call can be manually added though, see "Exceptions" below for details on how to add this.
</li> <li> To set up the callback in ActionScript, first select the widget that you would like the callback for.  It is recommended that if you have a widget that contains several smaller widgets, that you set the callback on the parent widget, then manually operate and store references to the child widgets within the parent widget's scope.  This is because <em>WidgetInitialized()</em> passes in the name of the widget, which could be shared across different clips in the movie, and so two separate widgets may end up sharing the same name in the <em>WidgetInitialized()</em> callback.  Widgets can also be differentiated from one another with the path, which gets passed into <em>WidgetInitialized()</em> along with the name.
</li> <li> With the widget selected, look for the <em>enableInitCallback</em> variable in the Component Inspector, and set it to true.
</li></ul>
<p />
<img alt="compinsp.jpg" src="rsrc/Three/ScaleformTechnicalGuide/compinsp.jpg" />
<p />
<strong><em>NOTE:</em></strong>  <em>If you don't have the Component Inspector in your current layout, you can bring it up by selecting "Component Inspector" from the Window menu, or by hitting Shift + F7</em>
<p /> <ul>
<li> Save the FLA, and publish the SWF (File-&gt;Publish or Shift + F12), and import it into the engine as normal.
</li></ul>
Now, any time the widget that you marked is created in a movie, UnrealScript will receive a call to the containing <em>GFxMoviePlayer's WidgetInitialized()</em> event, with the name of the widget, the full path of the widget, and a <em>GFxObject</em> pointing to the widget.
<p />
Sometimes in order to encapsulate functionality, it is useful to have the reference created and passed into <em>WidgetInitialized()</em> be a subclass of <em>GFxObject</em> instead of a normal <em>GFxObject</em>.  For instance, if you know you have a special "scoreboard item" widget that contains a label, an image, and some other data, you can subclass <em>GFxObject</em> and encapsulate functionality for changing the label and image of the widget via UnrealScript functions.  To bind certain widget names to specific <em>GFxObject</em> subclasses, use the <em>WidgetBindings</em> in <em>GFxMoviePlayer</em> if the widget is handled via your movie player's <em>WidgetInitialized()</em> function.  If, for example, you want to have all <em>WidgetInitialized()</em> calls with the name 'MyScoreboardWidget' pass in a reference to a constructed <em>ScoreboardWidget</em> UnrealScript class (which derives from <em>GFxObject</em>), you can add an entry to the <em>WidgetBindings</em> in the _GFxMoviePlayer_'s default properties, as below:
<p />
<div class="codesnippet">
<pre>
class ScoreboardGFxMoviePlayer extends GFxMoviePlayer;

// ...

defaultproperties
{
     WidgetBindings(0)&#61;{(WidgetName&#61;MyScoreboardWidget,WidgetClass&#61;class&#39;ScoreboardWidget&#39;)}
}
</pre>
</div>
<p />
In cases where functionality for major container widgets is compartmentalized by subclassing a widget, such as a menu panel or a scoreboard widget, it may also be useful to forward <em>WidgetInitialized()</em> calls to that widget for all of its children. In the above example, for instance, it would be useful to let <em>ScoreboardWidget</em> receive all the <em>WidgetInitialized()</em> calls for all of its child elements, such as the player name labels, icons, etc. To do this, you can use <em>GFxMoviePlayer::SetWidgetPathBinding(GFxObject WidgetToBind, name Path)</em>. When you pass a widget and a path, any widgets that have initialization callbacks that are within that path will be forwarded to the specified widget.  Note that the class for any of these forwarded widgets will be defined in the <em>SubWidgetBindings</em> array of the <em>GFxObject</em> that handles their initialization.  This array has the exact same format as <em>GFxMoviePlayer's WidgetBindings</em> array, but works for widgets initialized via forwarding.
<p />
In the above example, you could override <em>ScoreboardGFxMoviePlayer's WidgetInitialized()</em> function to set up path forwarding, such that when <em>MyScoreboardWidget</em> is initialized, all of its children's <em>WidgetInitialized()</em> calls will be forwarded to it. Here's the example code to set that up:
<p />
<div class="codesnippet">
<pre>
class ScoreboardGFxMoviePlayer extends GFxMoviePlayer;

/&#42;&#42; Reference to our scoreboard GFx widget, so we can send all its children&#39;s initializations to it. &#42;/
var ScoreboardWidget MyScoreboard;

event bool WidgetInitialized(name WidgetName, name WidgetPath, GFxObject Widget)
{
     if( WidgetName &#61;&#61; &#39;MyScoreboardWidget&#39; )
     {
          MyScoreboard &#61; Widget;
          SetWidgetPathBinding(MyScoreboard, WidgetPath);

          return TRUE;
     }

     return FALSE;
}

defaultproperties
{
     WidgetBindings(0)&#61;{(WidgetName&#61;MyScoreboardWidget,WidgetClass&#61;class&#39;ScoreboardWidget&#39;)}
}
</pre>
</div>
<p />
In the above example, all future widgets that have <em>enableInitCallback</em> set to TRUE in the Component Inspector will be routed to <em>MyScoreboard's WidgetInitialized()</em> event to be handled. To remove the binding for a given path, simply call <em>SetWidgetPathBinding()</em> again with None as the first parameter.
<p />
<strong><em>NOTE:</em></strong> It is sometimes useful to log out whether or not widgets were processed by <em>WidgetInitialized()</em> so that widgets erroneously marked with <em>enableInitCallback</em> but not handled by UnrealScript can disable the callback. To search for such widgets, set <em>GFxMoviePlayer's bLogUnhandledWidgetInitializations</em> to true. This will log out any widgets (as well as their full paths) that have <em>enableInitCallback</em> set to true, but for which <em>WidgetInitialized()</em> on either the movie or the widget bound to their path returns false. Note that this means to use this debugging, you should be sure to return TRUE in <em>WidgetInitialized()</em> any time you handle a widget!
<p />
<strong><em>Exceptions to CLIK widget requirement:</em></strong> It is possible to use the <em>WidgetInitialized()</em> interface on non-CLIK widgets by writing some custom ActionScript.  The <em>WidgetInitialized</em> callback is implemented through hooking into the CLIK_loadCallback function, so if you have a non-CLIK widget that you would like to have call <em>WidgetInitialized()</em>, add the following lines of ActionScript to the widget:
<p />
<div class="codesnippet">
<pre>
if( &#95;global.CLIK&#95;loadCallback )
{
     &#95;global.CLIK&#95;loadCallback(this.&#95;name, targetPath(this), this);
}
</pre>
</div>
<p />
<h3><a name="Working with Widget Display Info"></a> Working with Widget Display Info </h3>
<p />
The quickest (and best for performance) method of manipulating a <em>GFxObject_'s properties, such as location and visibility, is using the _DisplayInfo</em> method.  A quick example below should be enough to get you started:
<p />
<div class="codesnippet">
<pre>
var GFxObject MyGFxWidget;  // Assume this gets set somewhere

function MyFunction()
{
    local ASDisplayInfo DI;

    DI &#61; MyGFxWidget.GetDisplayInfo();
    `log(&#34;MyGFxWidget is at (&#34; $ DI.x $ &#34;, &#34; $ DI.y $ &#34;)&#34;);

    // Set some new properties for the widget
    DI.x &#61; 200;
    DI.y &#61; 200;
    DI.Visible &#61; true;
    MyGFxWidget.SetDisplayInfo(DI);
}
</pre>
</div>
<p />
<h3><a name="CLIK Component Event Callbacks"></a> CLIK Component Event Callbacks </h3>
<p />
To set up an UnrealScript function to get called when a CLIK component event happens, do the following:
<p />
Get a reference to the CLIK widget you want to set the delegate on, either via the <em>WidgetInitialized()</em>, or via <em>GetObject()</em>.  NOTE:  This reference must be a <em>GFxCLIKWidget</em>.  You can specify the subclass for the widget either by using <em>WidgetBindings</em> if you're getting the reference via <em>WidgetInitialized()</em>, or by specifying the class in <em>GetWidget(), e.g. GFxCLIKWidget( GetWidget("MyWidgetName", class'GFxCLIKWidget') )</em>.
To add a callback, call <em>AddEventListener(name type, delegate<EventListener> listener)</em> on the reference to the CLIK widget.  Note that <em>type</em> here must be in the form of 'CLIK_' followed by the CLIK event name (case sensitive!).  For example, to hook into the "press" event, you would pass in 'CLIK_press' as the <em>type</em>.  A full listing of CLIK events are in //depot/UnrealEngine3/Development/Flash/CLIK/gfx/events/EventTypes.as.
<p />
<div class="codesnippet">
<pre>
function SetupCallback()
{
     local GFxCLIKWidget MyWidget;

     MyWidget &#61; GFxCLIKWidget( GetObject(&#34;MyWidgetID&#34;, class&#39;GFxCLIKWidget&#39;) );
     MyWidget.AddEventListener(&#39;CLIK&#95;press&#39;, OnClickHandler);
}

function OnClickHandler(GFxCLIKWidget.EventData params)
{
     // Do something...
}
</pre>
</div>
<p />
<h3><a name="Removing movies"></a> Removing movies </h3>
One option is to simply replace the movie clip with a blank movie clip.
<p />
<div class="codesnippet">
<pre>
var GFxObject RootMC

// cache the &#95;root timeline.

RootMC &#61; GetVariableObject(&#34;&#95;root&#34;);

// create a new movie clip at depth 0
// called &#39;InstanceName&#39; on the &#95;root timeline,
// using a symbol from the library that has
// the linkage ID of &#39;LinkageID&#39;.

RootMC.AttachMovie(&#34;LinkageID&#34;, &#34;InstanceName&#34;, 0);

// replace the &#39;InstanceName&#39; movie clip with an empty movie clip at depth 0.

RootMC.CreateEmptyMovieClip(&#34;InstanceName&#34;, 0);
</pre>
</div>
<p />
The other method requires an Invoke which can then remove movie clips you no longer need.
<p />
<div class="codesnippet">
<pre>
var GFxObject RoomMC, MyMovieClip;
var array&#60;ASValue&#62; args;
var ASValue asval;

// Attach the movie clip to the &#95;root

RootMC &#61; GetVariableObject(&#34;&#95;root&#34;);
MyMovieClip &#61; RootMC.AttachMovie(&#34;LinkageID&#34;, &#34;InstanceName&#34;);

// Remove the movie clip

asval.Type &#61; AS&#95;Boolean;
asval.b &#61; TRUE;
args&#91;0] &#61; asval;

MyMovieClip.Invoke(&#34;removeMovieClip&#34;, args);
</pre>
</div>
<p />
<h2><a name="MoviePlayer Focus, Priority and Input Handling"></a> MoviePlayer Focus, Priority and Input Handling </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
If your movie needs to receive controller/keyboard input, make sure you give focus to a CLIK widget when your movie starts. The initial setting of focus is responsible for initializing the input system. Do not use Key.onPress in parallel with CLIK's input system, otherwise messages will be sent to both CLIK and your movie.
<p />
Only one movie player per LocalPlayer has focus (This is stored in the PlayerStates array in FGFxEngine). Focus for a LocalPlayer is determined based on three variables:
<p /> <ul>
<li> bAllowFocus - Whether or not a movie player is focusable
</li> <li> bOnlyOwnerFocusable - Whether or not a movie player is focusable by LocalPlayers other than the owner of the movie
</li> <li> Priority - The priority of the movie player, higher priority takes precedence over lower priority in both render and focus.
</li></ul>
<p />
A LocalPlayer's focused movie player is the one with the highest priority that is focusable where focusable is (bAllowFocus <code>= true &amp;&amp; (Owner =</code> Me || &#33;bOnlyOwnerFocusable)). In the case of a tie on priority the most recently created movie player will win. Unless you can guarantee construction order, it is suggested to avoid colliding priority values.
<p />
When input is received, the system will attempt to give the input to the focused movie for the LocalPlayer that created the input. This all happens in:
<p />
<div class="codesnippet">
<pre>
UBOOL FGFxEngine::InputKey(INT ControllerId, FName ukey, EInputEvent uevent) which will call into
UBOOL FGFxEngine::InputKey(INT ControllerId, FGFxMovie&#42; pFocusMovie, FName ukey, EInputEvent uevent) and
UBOOL FGFxEngine::InputAxis(INT ControllerId, FName key, Float delta, Float DeltaTime, UBOOL bGamepad) in GFxUIEngine.ccp.
</pre>
</div>
<p />
If the focused movie is able to receive input (bAllowInput == true) and is not ignoring that input (pFocusIgnoreKeys does not contains the specific input) then the movie will be given the opportunity to handle the input and it will be passed to it.
<p />
If the movie did not receive the input, or if it did receive it and did not decide to capture the input (CaptureInput &#33;= true and IsKeyCaptured for the input returns false), or consume/reject the input for any reason (there are many... it could be that the focused movie is being GC'd, the movie consumes all input from non-owner controllers, or the unrealscript backing class for the movieplayer decided to eat the input, etc.)  then it will also be passed to all texturemovies for potential usage.
<p />
Mouse input is handled slightly differently in that if it is not rejected for any reason on the focused movie (see UBOOL FGFxEngine::InputKey(INT ControllerId, FGFxMovie* pFocusMovie, FName ukey, EInputEvent uevent)) then every other movie should receive it.
<p />
<h2><a name="Loading Images"></a> Loading Images </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
UILoaders are CLIK widgets that provide an easy interface for loading textures from Unreal packages. The texture to load can be set either via ActionScript, or by UnrealScript at runtime. In both cases, the reference syntax is the same.
<p />
To load the texture Texture2D'MyPackage.MyGroup.MyTexture', for example, you would set the "source" variable of the UILoader to "img://MyPackage.MyGroup.MyTexture" for bilinear sample scaling, or "imgps://MyPackage.MyGroup.MyTexture" for point sampling.
<p />
<img alt="uiloader.jpg" src="rsrc/Three/ScaleformTechnicalGuide/uiloader.jpg" />
<p />
At runtime, the <em>SetString()</em> method can be used to load in a new image, as in the following code:
<p />
<div class="codesnippet">
<pre>
local GFxObject MyImageLoader;

MyImageLoader &#61; GetObject(&#34;MyImageLoader&#95;mc&#34;);
MyImageLoader.SetString(&#34;source&#34;, &#34;img://MyPackage.MyGroup.MyTexture&#34;);
</pre>
</div>
<p />
<strong><em>NOTE:</em></strong> Since the texture is referenced by a string name instead of an asset reference, be careful when using this. The texture should be in an always cooked package, or a reference to the texture should be added to the <em>GFxMovie's UserReferences</em> to ensure that the texture is loaded on consoles.
<p />
Also, to ensure that the texture scales to the UILoader properly, be sure to set <em>maintainAspectRatio</em> to false in the Component Inspector. Otherwise, Scaleform GFx will try to maintain the aspect ratio of the texture being loaded in.
<p />
<h3><a name="Swapping Images at Runtime"></a> Swapping Images at Runtime </h3>
<p />
At runtime, to swap the image out, use the <em>SetExternalTexture(string Resource, Texture TextureToUse)</em> function in <em>GFxMoviePlayer</em>.  This will swap any image that uses your exported reference as its texture.  <strong><em>NOTE</em></strong>:  This function can only be called after <em>Advance()</em> has been called on the <em>GFxMoviePlayer</em> for the first time!
<p />
<h2><a name="UI Sound Themes"></a> UI Sound Themes </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
UI sound themes (see Engine's <em>UISoundTheme</em> class) provide a quick and easy method for associating sounds with events in your UI.  The class itself provides a simple mapping of event names to SoundCues that should be played when those events occur in ActionScript.
<p />
<strong>Creating a new UISoundTheme:</strong> <ul>
<li> Open UnrealEd, and click on the Actor Classes browser (View -&gt; Browsers -&gt; Actor Classes)
</li> <li> Uncheck both the "Use 'Actor' As Parent" and "Placeable Classes Only" boxes
</li> <li> Locate <em>UISoundTheme</em> in the list, right-click, and select "Create Archetype..."
</li></ul>
<p />
<img alt="SoundThemeArchetype.jpg" src="rsrc/Three/ScaleformTechnicalGuide/SoundThemeArchetype.jpg" />
<p /> <ul>
<li> Select a location for your UISoundTheme to reside, and click OK in the dialog window that pops up
</li></ul>
<p />
Now that you have a new sound theme, you need to associate events with SoundCues to play.  A full listing of the events that are fired off by CLIK widgets is available in the EventTypes.as ActionScript file, located at //UnrealEngine3/Development/Flash/CLIK/gfx/events/EventTypes.as .  To associate an event with a SoundCue, simply add an entry to the Sound Event Bindings array (click the + icon), and type the event name in the Sound Event Name field, and the SoundCue that you would like to play in the Sound To Play field, as seen below.
<p />
<img alt="SoundThemeProps.jpg" src="rsrc/Three/ScaleformTechnicalGuide/SoundThemeProps.jpg" />
<p />
Now that you have a new sound theme, you need to bind it to your <em>GFxMoviePlayer</em>.  To do this, in UnrealScript, you can either specify the sound theme binding in the default properties of the class as below, or simply add a new binding to the <em>SoundThemes</em> array.
<p />
<div class="codesnippet">
<pre>
class MyGFxMoviePlayer extends GFxMoviePlayer;

defaultproperties
{
     SoundThemes(0)&#61;(ThemeName&#61;default,Theme&#61;UISoundTheme&#39;MyPackage.MyUISoundTheme&#39;)
}
</pre>
</div>
<p />
<strong><em>Advanced</em></strong>  Using multiple sound themes in the same SWF
<p />
Up until this point, we haven't mentiond the "ThemeName" variable in the <em>SoundThemeBinding</em> struct.  In the <em>SoundMap</em> inspectable property of CLIK widgets, there is an entry for "theme," which defaults to "default."  However, this can be set to any name that you want.  When the engine looks for a sound to play, it first tries to find the associated sound theme based on this "theme" identifier, and then it plays the SoundCue associated with the event in that theme.  This allows you the flexibility to have any widget in your SWF to use any sound theme it wants.
<p />
For instance, if you had two buttons, and you wanted to have one make a beep noise when the "press" event is fired, and one to make a horn noise, you could make two different <em>UISoundThemes</em>:  one which binds "press" to a beep sound cue, and one which binds it to a horn.  Then, you can change the "theme" entry in the widgets' inspectable properties to be "beep" and "horn" respectively.  When setting your default sound themes for the player, add a theme for both beep and horn, as below:
<p />
<div class="codesnippet">
<pre>
class MyGFxMoviePlayer extends GFxMoviePlayer;

defaultproperties
{
     SoundThemes(0)&#61;(ThemeName&#61;beep,Theme&#61;UISoundTheme&#39;MyPackage.BeepSoundTheme&#39;)
     SoundThemes(1)&#61;(ThemeName&#61;horn,Theme&#61;UISoundTheme&#39;MyPackage.HornSoundTheme&#39;)
}
</pre>
</div>
<p />
<strong><em>Advanced</em></strong>  Firing events off manually from ActionScript
<p />
Sound events are not only for CLIK widgets...sound events can be fired off arbitrarily from ActionScript using the following code:
<p />
<div class="codesnippet">
<pre>
if( &#95;global.gfxProcessSound )
{
     &#95;global.gfxProcessSound(this, &#34;SoundThemeName&#34;, &#34;SoundEventName&#34;);
}
</pre>
</div>
<p />
<h2><a name="Localization in Scaleform"></a> Localization in Scaleform </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
For localization, our current best practice is to leverage the <em>WidgetInitialized()</em> callback system to replace string content with their localized equivalents.  There are two major justifications for this:
<p /> <ul>
<li> It allows the artist to put whatever placeholder text they would like in the actual movie, which helps them with formatting and style.
</li> <li> It allows all strings to be searched for in code, which aids in tracking down potential bugs and problems.
</li></ul>
<p />
To localize strings, simply have a string variable in your GFxMoviePlayer class, and include the keyword "localized".  This will attempt to look up the string in the localization file corresponding to the script package that the class resides in.
<p />
<div class="codetitlebar">
MyGFxMoviePlayer.uc
</div>
<div class="codesnippet">
<pre>
class MyGFxMoviePlayer extends GFxMoviePlayer;

var localized string MyTitleString;

var transient GFxObject lbl&#95;Title;

event bool WidgetInitialized(name WidgetName, name WidgetPath, GFxObject Widget)
{
  if (WidgetName &#61;&#61; &#39;TitleLabel&#39;)
  {
    lbl&#95;Title &#61; Widget;
    lbl&#95;Title.SetText(MyTitleString);

    return true;
  }

  return false;
}
</pre>
</div>
<p />
In your localization file, you can then create a section for your class, and an entry for the localized string, like below:
<p />
<div class="codesnippet">
<pre>
&#91;MyGFxMoviePlayer]
MyTitleString&#61;My title is awesome!
</pre>
</div>
<p />
<h2><a name="Testing and Debugging Scenes"></a> Testing and Debugging Scenes </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
Debugging with Scaleform can be a test of wills at times. Many errors such as misspellings and typos in ActionScript which don't throw compile time warnings, fail silently so bugs can be near impossible to track down. Other aspects, such as handling focus within scenes, are really hard to debug because there really are not any debugging tools for those aspects.
<p />
<h3><a name="Testing in the _GFxPlayer"></a> Testing in the GFxPlayer </h3>
<p />
In order to reduce iteration and testing time because of how long it takes to Publish -&gt; Import -&gt; Boot Game -&gt; Test, often we set up dummy data in the ActionScript code to test.  To prevent this from executing in game, in ActionScript you can use
<p />
<div class="codesnippet">
<pre>
if( &#95;global.gfxPlayer )
{
    // debugging code here.
}
</pre>
</div>
<p />
This make sure the code only gets run in the external GFxPlayer, and not the game, so that you don't have to worry about fake data appearing in the game.  One of the biggest lessons we learned is that where you can, you should always test your content in Flash and get it working there before bringing it into engine, because you'll save so much iteration time.  That's part of the motivation for our newer scenes being set up with the gears.view.Foo class.  That base location is where we put in the Flash-only debug data so we can test the scene before bringing it in engine.  This allows for easy simulation of data being sent from the game, as that is the class we typically hook and send all the data to for processing.
<p />
This will also allow your UI Artist to be able to see what the scene will look like with dummy content in it.
<p />
<h3><a name="Enabling Logging"></a> Enabling Logging </h3>
<p />
Logging from Scaleform GFx is turned on by default in the PC library, but not the console libraries. Logging is sent through the <em>DevGFxUI</em> logging channel, which is suppressed by default. To enable, comment out (using a semi-colon) the line "Suppress=<i>DevGFxUI</i>" in your game's Engine.ini file (e.g. UDKEngine.ini).
<p />
Note that ActionScript <em>Trace()</em> logging is also routed through this channel, so it must be unsuppressed to see any ActionScript logging that you may be doing.
<p />
</noautolink>
<p />
<p />
<style type="text/css">
<!--
	.code_heading
	{
		padding-left:16px;
		font:bold 12px arial;
	}
	.code_heading_toggle
	{
		background:url("http://www.sectionj.net/expand_plus.png") no-repeat scroll 3px 3px transparent;
		padding-left:16px;
		cursor:pointer;
		font:bold 12px arial;
	}
	.code_block
	{
		margin-left:16px;
		margin-right:16px;
		background:#d8d8d8;
		padding:1px 10px;
		font:12px courier; <dl>
 <dd>
 <dl>
<dt> -moz-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> -webkit-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> box-shadow</dt><dd> 2px 2px 5px #606060;	}	.code_block_toggle	{		margin-left:16px;		margin-right:16px;		display:none;		background:#d8d8d8;		padding:1px 10px;		font:12px courier;
</dd> <dt> -moz-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> -webkit-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> box-shadow</dt><dd> 2px 2px 5px #606060;	}	.code_block_more	{		margin-left:16px;		margin-right:16px;		cursor:pointer;		display:block;		background:#d8d8d8;		padding:10px;		font:12px arial;
</dd> <dt> -moz-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> -webkit-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> box-shadow</dt><dd> 2px 2px 5px #606060;	}	.clicktext	{
</dd> <dt> font-weight</dt><dd> normal;
</dd> <dt> font-style</dt><dd> italic;
</dd> <dt> font-size</dt><dd> 10px;	}	.thumbnail	{		width:240px;		border:2px solid #202020;
</dd> <dt> -moz-box-shadow</dt><dd> 3px 3px 5px #606060;
</dd> <dt> -webkit-box-shadow</dt><dd> 3px 3px 5px #606060;
</dd> <dt> box-shadow</dt><dd> 3px 3px 5px #606060;	}	.regionhead	{		background:#b0b0b0;		cursor:pointer;		padding:5px;		font:bold 12px arial;		border:1px solid #a0a0a0;
</dd> <dt> minimum-width</dt><dd> 700px;	}	.regionimage	{		margin-right:5px;		display:inline-block;	    width:10px;		height:10px;		font-size:10px;		font-weight:normal;	}	.regioncontent	{		border:1px solid #a0a0a0;		padding:10px;		display:none;	}	.tabs	{		width:100%;		height:27px;		border-bottom:1px solid #606060;		list-style:none;		padding:0px;		margin:0px;	}	.tabs li	{		padding:3px 12px;		float:left;		margin:0px;		border:1px solid #606060;
</dd> <dt> -moz-border-radius</dt><dd> 5px 5px 0px 0px;
</dd> <dt> -webkit-border-radius</dt><dd> 5px 5px 0px 0px;		cursor:pointer;		background:#d0d0d0;	}	.tabcontent	{		border:1px solid #606060;		display:none;		padding:10px;		min-height:250px;
</dd> <dt> -moz-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> -webkit-box-shadow</dt><dd> 2px 2px 5px #606060;
</dd> <dt> box-shadow</dt><dd> 2px 2px 5px #606060;	}
</dd></dl>
</dd></dl>
-->
</style>
<p />
<script type="text/javascript">
	function toggleRegion(id)
	{
		var content = document.getElementById("region_" + id + "_content");
		var head= document.getElementById("region_" + id + "_image");

		//var plusImage = "url(/pub/images/expand_plus.png)";
		//var minusImage = "url(/pub/images/expand_minus.png)";

		if(content.style.display == "block")
		{
		     //head.style.backgroundImage = plusImage;
		     head.innerHTML = "+";
		     content.style.display = "none";
		}
		else
		{
		     //head.style.backgroundImage = minusImage;
		     head.innerHTML = "-";
		     content.style.display = "block";
		}
	}
</script>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
