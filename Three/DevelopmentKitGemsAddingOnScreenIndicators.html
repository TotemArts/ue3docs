<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | DevelopmentKitGemsAddingOnScreenIndicators    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">DevelopmentKitGemsAddingOnScreenIndicators  </b></div>
<div id="tooltext">
<a href="DevelopmentKitGemsAddingOnScreenIndicatorsJP.html" class="twikiLink">日本語訳</a><br><a href="DevelopmentKitGemsAddingOnScreenIndicatorsCH.html" class="twikiLink">中国翻译</a><br><a href="DevelopmentKitGemsAddingOnScreenIndicatorsKR.html" class="twikiLink">한국어</a><br>

<!-- Three/DevelopmentKitGemsAddingOnScreenIndicators -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="DevelopmentKitGems.html" class="twikiLink">Unreal Development Kit Gems</a></b> &gt; Adding on screen indicators
</div>
<hr size="1" noshade="noshade">
<p />
<h1><a name="Adding on screen indicators"></a> Adding on screen indicators </h1>
<hr size="1" noshade="noshade">
<p />
<strong><em>Last tested against UDK May, 2011</em></strong>
<br>
<strong><em>PC compatible</em></strong>
<p />
<div class="twikiToc"> <ul>
<li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Adding on screen indicators"> Adding on screen indicators</a> <ul>
<li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Overview"> Overview</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Indicator material"> Indicator material</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Unrealscript"> Unrealscript</a> <ul>
<li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#SRadarInfo struct"> SRadarInfo struct</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#AddPostRenderedActor function"> AddPostRenderedActor function</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#PostRender event"> PostRender event</a> <ul>
<li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Update pass"> Update pass</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Rendering pass"> Rendering pass</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Rendering in front of the camera pass"> Rendering in front of the camera pass</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Rendering behind the camera pass"> Rendering behind the camera pass</a>
</li></ul>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Angle calculation"> Angle calculation</a>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Completed Unrealscript class"> Completed Unrealscript class</a>
</li></ul>
</li> <li> <a href="DevelopmentKitGemsAddingOnScreenIndicators.html#Downloads"> Downloads</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
By default, Unreal Tournament 3 has a simplistic on screen indicator to show the player's name when in front of the camera. This development kit gem will show you how to create on screen indicators which point to targets on screen. If the target is off screen because the target is behind the camera then the on screen indicator will stay at the bottom of the screen. If the target is off screen because the target is out of the camera's frustum, then the on screen indicator will either stay on the edges of the screen and point where the target is. The on screen indicator also fades out if the target is currently not being rendered on screen. Lastly, the on screen indicators also change color depending on the team that the target is on.
<p /> <ol>
<li> These pawns are visible on screen, and are on the blue team. Their on screen indicators shift slightly to the left or the right and the arrow points accordingly.
</li> <li> This pawn is hidden behind the bridge, thus the on screen indicator goes transparent.
</li> <li> This a team mate, who is out of the camera frustum's view and is out of sight.
</li> <li> These pawns are behind the player and out of sight.
</li></ol>
<p />
<img src="rsrc/Three/DevelopmentKitGemsAddingOnScreenIndicators/OnScreenRadarExample.jpg" alt="OnScreenRadarExample.jpg" width='800' height='593' />
<p />
<h2><a name="Indicator material"></a> Indicator material </h2>
<hr size="1" noshade="noshade">
The on screen indicator material is responsible for a few things. It's responsible for the rotation, opacity and team colorization. Here is the texture used for the on screen indicator. The below image shows the texture's individual channels.
<p /> <ol>
<li> This is the gray scale diffuse used for the on screen indicator. It has a lot of clear space otherwise when the texture rotates artifacts may appear due to texture wrapping.
</li> <li> This is the mask used to set the opacity of the icon in the middle of the on screen indicator.
</li> <li> This is the mask used to create a shadow for the on screen indicator.
</li> <li> This is the mask used as the opacity for the on screen indicator.
</li></ol>
<p />
The shadow mask and the opacity mask were separated out to allow the shadow to adjust its strength independently; but wasn't added at the end. You could add this yourself if desired.
<p />
<img src="rsrc/Three/DevelopmentKitGemsAddingOnScreenIndicators/OnScreenIndicatorThumbnail.jpg" alt="OnScreenIndicatorThumbnail.jpg" width='800' height='200' />
<p />
The on screen indicator is a transparent, unlit material. Materials should be unlit if they are to be rendered onto the HUD. Only the emissive channel is used as well.
<p />
The emissive channel is composed of two branches. The first branch handles the on screen indicator itself. The on screen indicator texture sampler is rotated by a scalar parameter called <strong>Rotation</strong>. The red channel (#1) is then multiplied by a vector parameter called <strong>TeamColor</strong>. This is then multiplied by a pulsing gray color produced by a sine curve. The second branch handles the on screen indicator icon that goes in the center. A texture parameter called <strong>Portrait</strong> provides the texture. It is shrunk and pushed into the center, so that a reasonable amount of the portrait texture will be seen. A TV screen overlay effect is achieved by multiplying a panning texture on top. This is then multiplied with the green channel (#2) of the on screen indicator texture. The results of the two branches are added together and multiplied by the alpha channel (#4) of the on screen indicator texture.
<p />
The opacity channel simply adds up the blue channel (#3) and the alpha channel (#4). The results is then multiplied by a scalar parameter called <strong>Opacity</strong>.
<p />
<a href="rsrc/Three/DevelopmentKitGemsAddingOnScreenIndicators/OnScreenIndicatorMaterial.jpg" target="_top"><img src="rsrc/Three/DevelopmentKitGemsAddingOnScreenIndicators/OnScreenIndicatorMaterialThumbnail.jpg" alt="OnScreenIndicatorMaterialThumbnail.jpg" width='800' height='464' /></a>
<p />
<h2><a name="Unrealscript"></a> Unrealscript </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="SRadarInfo struct"></a> SRadarInfo struct </h3>
A struct was used to contain information about each of the on screen indicators.
<p /> <ul>
<li> <strong>UTPawn</strong> - A reference to the pawn that this on screen indicator points to.
</li> <li> <strong>MaterialInstanceConstant</strong> - An instance of the material used by the on screen indicator.
</li> <li> <strong>DeleteMe</strong> - A boolean for deletion purposes.
</li> <li> <strong>Offset</strong> - Offset of the on screen indicator used for animation purposes.
</li> <li> <strong>Opacity</strong> - Current opacity of the on screen indicator.
</li></ul>
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
struct SRadarInfo
{
  var UTPawn UTPawn;
  var MaterialInstanceConstant MaterialInstanceConstant;
  var bool DeleteMe;
  var Vector2D Offset;
  var float Opacity;
};
</pre>
</div>
<p />
<h3><a name="AddPostRenderedActor function"></a> AddPostRenderedActor function </h3>
By default, Unreal Tournament 3 uses post rendered actors to render the existing name indicators. This function removes that behavior just for the UTPawn.
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
function AddPostRenderedActor(Actor A)
{
  // Remove post render call for UTPawns as we don&#39;t want the name bubbles showing
  if (UTPawn(A) !&#61; None)
  {
    return;
  }

  Super.AddPostRenderedActor(A);
}
</pre>
</div>
<p />
<h3><a name="PostRender event"></a> PostRender event </h3>
The post render event in Unrealscript is called by the engine to allow Unrealscript an opportunity to render textures, materials or text onto the screen. This is where the bulk of the logic is for this development kit gem; thus will be split up into smaller sections.
<p />
<h4><a name="Update pass"></a> Update pass </h4>
In this pass, the radar info's are all tested for deletion by first setting DeleteMe to true.
<p />
Next all UT Pawns are iterated over using ForEach. For all pawns that isn't owned by the player, first check if a radar info references it. This is done by attempting to find a valid index in the RadarInfo array. If the index is valid and the pawn has health then we set DeleteMe to false as it passes the deletion check. If the index is invalid and the pawn has health, then a new radar info is created. When a new radar info is created, a new material instance is also created for that radar info. The team color is also set, and DeleteMe is set false as it also passes the deletion check.
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
  // Set all radar infos to delete if not found
  for (i &#61; 0; i &#60; RadarInfo.Length; ++i)
  {
    RadarInfo&#91;i].DeleteMe &#61; true;
  }

  // Update the radar infos and see if we need to add or remove any
  ForEach DynamicActors(class&#39;UTPawn&#39;, UTPawn)
  {
    if (UTPawn !&#61; PlayerOwner.Pawn)
    {
      Index &#61; RadarInfo.Find(&#39;UTPawn&#39;, UTPawn);
      // This pawn was not found in our radar infos, so add it
      if (Index &#61;&#61; INDEX&#95;NONE &#38;&#38; UTPawn.Health &#62; 0)
      {
        i &#61; RadarInfo.Length;
        RadarInfo.Length &#61; RadarInfo.Length + 1;
        RadarInfo&#91;i].UTPawn &#61; UTPawn;
        RadarInfo&#91;i].MaterialInstanceConstant &#61; new () class&#39;MaterialInstanceConstant&#39;;

        if (RadarInfo&#91;i].MaterialInstanceConstant !&#61; None)
        {
          RadarInfo&#91;i].MaterialInstanceConstant.SetParent(Material&#39;GemOnscreenRadarContent.PointerMaterial&#39;);

          if (UTPawn.PlayerReplicationInfo !&#61; None &#38;&#38; UTPawn.PlayerReplicationInfo.Team !&#61; None)
          {
            TeamLinearColor &#61; (UTPawn.PlayerReplicationInfo.Team.TeamIndex &#61;&#61; 0) ? Default.RedLinearColor : Default.BlueLinearColor;
            RadarInfo&#91;i].MaterialInstanceConstant.SetVectorParameterValue(&#39;TeamColor&#39;, TeamLinearColor);
          }
          else
          {
            RadarInfo&#91;i].MaterialInstanceConstant.SetVectorParameterValue(&#39;TeamColor&#39;, Default.DMLinearColor);
          }
        }

        RadarInfo&#91;i].DeleteMe &#61; false;
      }
      else if (UTPawn.Health &#62; 0)
      {
        RadarInfo&#91;Index].DeleteMe &#61; false;
      }
    }
  }
</pre>
</div>
<p />
<h4><a name="Rendering pass"></a> Rendering pass </h4>
Before the pass is calculated, the on screen indicator size is first calculated and stored as <strong>PointerSize</strong>. In this implementation, this is relative to the screen resolution width. The camera view direction is also derived from the camera location and rotation. The camera view direction is used to detect if a pawn is behind the player or not.
<p />
In this pass radar info's are rendered if DeleteMe is false. Otherwise they are removed from the radar info array.
<p />
When the on screen indicator is rendered, it is first checked if the associated pawn has been rendered in the last 0.1 second. If it hasn't, then it's opacity is linearly interpolated down to 40%. Otherwise it is linearly interpolated up to 100%. When the opacity is calculated, it is then set in the material instance constant.
<p />
The direction between the player's pawn and the pawn is calculated. The dot product between the camera direction and the player pawn to pawn direction determines if the player is currently looking at the pawn or not. In the image below, the red arrow represents the camera direction. The green arrow represents the direction of the player pawn to the pawn. The dot product will be a value between 1.f and 0.f, thus will be in front of the camera. The blue arrow represents the direction of the player pawn to another pawn. The dot product will be a value between 0.f and -1.f, thus will be behind the camera.
<p />
<img src="rsrc/Three/DevelopmentKitGemsAddingOnScreenIndicators/DotProduct.jpg" alt="DotProduct.jpg" width='256' height='256' />
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
  // Handle rendering of all of the radar infos
  PointerSize &#61; Canvas.ClipX &#42; 0.083f;
  PlayerOwner.GetPlayerViewPoint(CameraLocation, CameraRotation);
  CameraViewDirection &#61; Vector(CameraRotation);

  for (i &#61; 0; i &#60; RadarInfo.Length; ++i)
  {
    if (!RadarInfo&#91;i].DeleteMe)
    {
      if (RadarInfo&#91;i].UTPawn !&#61; None &#38;&#38; RadarInfo&#91;i].MaterialInstanceConstant !&#61; None)
      {
        // Handle the opacity of the pointer. If the player cannot see this pawn,
        // then fade it out half way, otherwise if he can, fade it in
        if (WorldInfo.TimeSeconds - RadarInfo&#91;i].UTPawn.LastRenderTime &#62; 0.1f)
        {
          // Player has not seen this pawn in the last 0.1 seconds
          RadarInfo&#91;i].Opacity &#61; Lerp(RadarInfo&#91;i].Opacity, 0.4f, RenderDelta &#42; 4.f);
        }
        else
        {
          // Player has seen this pawn in the last 0.1 seconds
          RadarInfo&#91;i].Opacity &#61; Lerp(RadarInfo&#91;i].Opacity, 1.f, RenderDelta &#42; 4.f);
        }
        // Apply the opacity
        RadarInfo&#91;i].MaterialInstanceConstant.SetScalarParameterValue(&#39;Opacity&#39;, RadarInfo&#91;i].Opacity);

        // Get the direction from the player&#39;s pawn to the pawn
        PawnDirection &#61; Normal(RadarInfo&#91;i].UTPawn.Location - PlayerOwner.Pawn.Location);

        // Check if the pawn is in front of me
        if (PawnDirection dot CameraViewDirection &#62;&#61; 0.f)
        {
          // Handle rendering the on screen indicator when the actor is in front of the camera
        }
        else
        {
          // Handle rendering the on screen indicator when the actor is behind the camera
        }
      }
    }
    else
    {
      // Null the variables previous stored so garbage collection can occur
      RadarInfo&#91;i].UTPawn &#61; None;
      RadarInfo&#91;i].MaterialInstanceConstant &#61; None;
      // Remove from the radar info array
      RadarInfo.Remove(i, 1);
      // Back step one, to maintain the for loop
      --i;
    }
  }
</pre>
</div>
<p />
<h4><a name="Rendering in front of the camera pass"></a> Rendering in front of the camera pass </h4>
First the <strong>WorldHUDLocation</strong> is calculated by adding together the pawn's location with the collision height as an offset. This is then projected into screen coordinates. If the screen coordinate is on the left hand side of the screen an offset is interpolated to the left; or if it is on the right hand side of the screen an offset is interpolated to the right. This provides a little bit of animation to the on screen indicator. The offset is clamped to ensure that it doesn't get too large in either direction. The rotation of the material instance is then calculated and set. Finally, the on screen indicator is rendered onto the screen.
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
          // Get the world HUD location, which is just above the pawn&#39;s head
          WorldHUDLocation &#61; RadarInfo&#91;i].UTPawn.Location + (RadarInfo&#91;i].UTPawn.GetCollisionHeight() &#42; Vect(0.f, 0.f, 1.f));
          // Project the world HUD location into screen HUD location
          ScreenHUDLocation &#61; Canvas.Project(WorldHUDLocation);

          // If the screen HUD location is more to the right, then swing it to the left
          if (ScreenHUDLocation.X &#62; (Canvas.ClipX &#42; 0.5f))
          {
            RadarInfo&#91;i].Offset.X -&#61; PointerSize &#42; RenderDelta &#42; 4.f;
          }
          else
          {
            // If the screen HUD location is more to the left, then swing it to the right
            RadarInfo&#91;i].Offset.X +&#61; PointerSize &#42; RenderDelta &#42; 4.f;
          }
          RadarInfo&#91;i].Offset.X &#61; FClamp(RadarInfo&#91;i].Offset.X, PointerSize &#42; -0.5f, PointerSize &#42; 0.5f);

          // Set the rotation of the material icon
          ActualPointerLocation.X &#61; Clamp(ScreenHUDLocation.X, 8, Canvas.ClipX - 8) + RadarInfo&#91;i].Offset.X;
          ActualPointerLocation.Y &#61; Clamp(ScreenHUDLocation.Y - PointerSize + RadarInfo&#91;i].Offset.Y, 8, Canvas.ClipY - 8 - PointerSize) + (PointerSize &#42; 0.5f);
          RadarInfo&#91;i].MaterialInstanceConstant.SetScalarParameterValue(&#39;Rotation&#39;, GetAngle(ActualPointerLocation, ScreenHUDLocation));

          // Draw the material pointer
          Canvas.SetPos(ActualPointerLocation.X - (PointerSize &#42; 0.5f), ActualPointerLocation.Y - (PointerSize &#42; 0.5f));
          Canvas.DrawMaterialTile(RadarInfo&#91;i].MaterialInstanceConstant, PointerSize, PointerSize, 0.f, 0.f, 1.f, 1.f);
</pre>
</div>
<p />
<h4><a name="Rendering behind the camera pass"></a> Rendering behind the camera pass </h4>
For actors behind the camera, the on screen indicator is always at the bottom of the screen. While it is possible to still use the project function, it will return results that needs to modified. This is why the projected horizontal coordinates is inversed. If the horizontal screen coordinates is on the left edge then the horizontal offset is pushed to the right and vice versa. This ensures that the on screen indicator is always on screen. Similar rotation calculations are done and applied to the material instance. Finally, the on screen indicator is rendered onto the screen.
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
          // Project the pawn&#39;s location
          ScreenHUDLocation &#61; Canvas.Project(RadarInfo&#91;i].UTPawn.Location);

          // Inverse the Screen HUD location
          ScreenHUDLocation.X &#61; Canvas.ClipX - ScreenHUDLocation.X;

          // If the screen HUD location is on the right edge, then swing it to the left
          if (ScreenHUDLocation.X &#62; (Canvas.ClipX - 8))
          {
            RadarInfo&#91;i].Offset.X -&#61; PointerSize &#42; RenderDelta &#42; 4.f;
            RadarInfo&#91;i].Offset.X &#61; FClamp(RadarInfo&#91;i].Offset.X, PointerSize &#42; -0.5f, PointerSize &#42; 0.5f);
          }
          else if (ScreenHUDLocation.X &#60; 8)
          {
            // If the screen HUD location is on the left edge, then swing it to the right
            RadarInfo&#91;i].Offset.X +&#61; PointerSize &#42; RenderDelta &#42; 4.f;
            RadarInfo&#91;i].Offset.X &#61; FClamp(RadarInfo&#91;i].Offset.X, PointerSize &#42; -0.5f, PointerSize &#42; 0.5f);
          }
          else
          {
            // If the screen HUD location is somewhere in the middle, then straighten it up
            RadarInfo&#91;i].Offset.X &#61; Lerp(RadarInfo&#91;i].Offset.X, 0.f, 4.f &#42; RenderDelta);
          }

          // Set the screen HUD location
          ScreenHUDLocation.X &#61; Clamp(ScreenHUDLocation.X, 8, Canvas.ClipX - 8);
          ScreenHUDLocation.Y &#61; Canvas.ClipY - 8;

          // Set the actual pointer location
          ActualPointerLocation.X &#61; ScreenHUDLocation.X + RadarInfo&#91;i].Offset.X;
          ActualPointerLocation.Y &#61; ScreenHUDLocation.Y - (PointerSize &#42; 0.5f);

          // Set the rotation of the material icon
          RadarInfo&#91;i].MaterialInstanceConstant.SetScalarParameterValue(&#39;Rotation&#39;, GetAngle(ActualPointerLocation, ScreenHUDLocation));

          // Draw the material pointer
          Canvas.SetPos(ActualPointerLocation.X - (PointerSize &#42; 0.5f), ActualPointerLocation.Y - (PointerSize &#42; 0.5f));
          Canvas.DrawMaterialTile(RadarInfo&#91;i].MaterialInstanceConstant, PointerSize, PointerSize, 0.f, 0.f, 1.f, 1.f);
</pre>
</div>
<p />
<h3><a name="Angle calculation"></a> Angle calculation </h3>
In this angle calculation method, the black arrow is the reference vector. The two vectors form either the red line or the green line. The angle calculated is shown as the blue arc. The calculations are done in radians since the material expects the rotation value in radians. Some early checks are done to return simple results such as 0.f (0 degrees), Pi (180 degrees), Pi * 1.5f (270 degrees) and Pi * 0.5f (90 degrees). This method is a faster than the quadrant checking method (using SOH CAH TOA) and the other acos method.
<p />
<img src="rsrc/Three/DevelopmentKitGemsAddingOnScreenIndicators/AngleCalculation.jpg" alt="AngleCalculation.jpg" width='256' height='256' />
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
function float GetAngle(Vector PointB, Vector PointC)
{
  // Check if angle can easily be determined if it is up or down
  if (PointB.X &#61;&#61; PointC.X)
  {
    return (PointB.Y &#60; PointC.Y) ? Pi : 0.f;
  }

  // Check if angle can easily be determined if it is left or right
  if (PointB.Y &#61;&#61; PointC.Y)
  {
    return (PointB.X &#60; PointC.X) ? (Pi &#42; 1.5f) : (Pi &#42; 0.5f);
  }

  return (2.f &#42; Pi) - atan2(PointB.X - PointC.X, PointB.Y - PointC.Y);
}
</pre>
</div>
<p />
<h3><a name="Completed Unrealscript class"></a> Completed Unrealscript class </h3>
This is the completed Unrealscript class; shown here for clarity on how to piece it all together.
<p />
<div class="codetitlebar">
<strong><em>YourHUD.uc</em></strong>
</div>
<div class="codesnippet">
<pre>
class UTRadarHUD extends UTTeamHUD;

struct SRadarInfo
{
  var UTPawn UTPawn;
  var MaterialInstanceConstant MaterialInstanceConstant;
  var bool DeleteMe;
  var Vector2D Offset;
  var float Opacity;
};

var array&#60;SRadarInfo&#62; RadarInfo;

function AddPostRenderedActor(Actor A)
{
  // Remove post render call for UTPawns as we don&#39;t want the name bubbles showing
  if (UTPawn(A) !&#61; None)
  {
    return;
  }

  Super.AddPostRenderedActor(A);
}

event PostRender()
{
  local int i, Index;
  local Vector WorldHUDLocation, ScreenHUDLocation, ActualPointerLocation, CameraViewDirection, PawnDirection, CameraLocation;
  local Rotator CameraRotation;
  local UTPawn UTPawn;
  local LinearColor TeamLinearColor;
  local float PointerSize;

  if (PlayerOwner &#61;&#61; None &#124;&#124; PlayerOwner.Pawn &#61;&#61; None)
  {
    return;
  }

  // Set up the render delta
  RenderDelta &#61; WorldInfo.TimeSeconds - LastHUDRenderTime;

  // Set all radar infos to delete if not found
  for (i &#61; 0; i &#60; RadarInfo.Length; ++i)
  {
    RadarInfo&#91;i].DeleteMe &#61; true;
  }

  // Update the radar infos and see if we need to add or remove any
  ForEach DynamicActors(class&#39;UTPawn&#39;, UTPawn)
  {
    if (UTPawn !&#61; PlayerOwner.Pawn)
    {
      Index &#61; RadarInfo.Find(&#39;UTPawn&#39;, UTPawn);
      // This pawn was not found in our radar infos, so add it
      if (Index &#61;&#61; INDEX&#95;NONE &#38;&#38; UTPawn.Health &#62; 0)
      {
        i &#61; RadarInfo.Length;
        RadarInfo.Length &#61; RadarInfo.Length + 1;
        RadarInfo&#91;i].UTPawn &#61; UTPawn;
        RadarInfo&#91;i].MaterialInstanceConstant &#61; new () class&#39;MaterialInstanceConstant&#39;;

        if (RadarInfo&#91;i].MaterialInstanceConstant !&#61; None)
        {
          RadarInfo&#91;i].MaterialInstanceConstant.SetParent(Material&#39;GemOnscreenRadarContent.PointerMaterial&#39;);

          if (UTPawn.PlayerReplicationInfo !&#61; None &#38;&#38; UTPawn.PlayerReplicationInfo.Team !&#61; None)
          {
            TeamLinearColor &#61; (UTPawn.PlayerReplicationInfo.Team.TeamIndex &#61;&#61; 0) ? Default.RedLinearColor : Default.BlueLinearColor;
            RadarInfo&#91;i].MaterialInstanceConstant.SetVectorParameterValue(&#39;TeamColor&#39;, TeamLinearColor);
          }
          else
          {
            RadarInfo&#91;i].MaterialInstanceConstant.SetVectorParameterValue(&#39;TeamColor&#39;, Default.DMLinearColor);
          }
        }

        RadarInfo&#91;i].DeleteMe &#61; false;
      }
      else if (UTPawn.Health &#62; 0)
      {
        RadarInfo&#91;Index].DeleteMe &#61; false;
      }
    }
  }

  // Handle rendering of all of the radar infos
  PointerSize &#61; Canvas.ClipX &#42; 0.083f;
  PlayerOwner.GetPlayerViewPoint(CameraLocation, CameraRotation);
  CameraViewDirection &#61; Vector(CameraRotation);

  for (i &#61; 0; i &#60; RadarInfo.Length; ++i)
  {
    if (!RadarInfo&#91;i].DeleteMe)
    {
      if (RadarInfo&#91;i].UTPawn !&#61; None &#38;&#38; RadarInfo&#91;i].MaterialInstanceConstant !&#61; None)
      {
        // Handle the opacity of the pointer. If the player cannot see this pawn,
        // then fade it out half way, otherwise if he can, fade it in
        if (WorldInfo.TimeSeconds - RadarInfo&#91;i].UTPawn.LastRenderTime &#62; 0.1f)
        {
          // Player has not seen this pawn in the last 0.1 seconds
          RadarInfo&#91;i].Opacity &#61; Lerp(RadarInfo&#91;i].Opacity, 0.4f, RenderDelta &#42; 4.f);
        }
        else
        {
          // Player has seen this pawn in the last 0.1 seconds
          RadarInfo&#91;i].Opacity &#61; Lerp(RadarInfo&#91;i].Opacity, 1.f, RenderDelta &#42; 4.f);
        }
        // Apply the opacity
        RadarInfo&#91;i].MaterialInstanceConstant.SetScalarParameterValue(&#39;Opacity&#39;, RadarInfo&#91;i].Opacity);

        // Get the direction from the player&#39;s pawn to the pawn
        PawnDirection &#61; Normal(RadarInfo&#91;i].UTPawn.Location - PlayerOwner.Pawn.Location);

        // Check if the pawn is in front of me
        if (PawnDirection dot CameraViewDirection &#62;&#61; 0.f)
        {
          // Get the world HUD location, which is just above the pawn&#39;s head
          WorldHUDLocation &#61; RadarInfo&#91;i].UTPawn.Location + (RadarInfo&#91;i].UTPawn.GetCollisionHeight() &#42; Vect(0.f, 0.f, 1.f));
          // Project the world HUD location into screen HUD location
          ScreenHUDLocation &#61; Canvas.Project(WorldHUDLocation);

          // If the screen HUD location is more to the right, then swing it to the left
          if (ScreenHUDLocation.X &#62; (Canvas.ClipX &#42; 0.5f))
          {
            RadarInfo&#91;i].Offset.X -&#61; PointerSize &#42; RenderDelta &#42; 4.f;
          }
          else
          {
            // If the screen HUD location is more to the left, then swing it to the right
            RadarInfo&#91;i].Offset.X +&#61; PointerSize &#42; RenderDelta &#42; 4.f;
          }
          RadarInfo&#91;i].Offset.X &#61; FClamp(RadarInfo&#91;i].Offset.X, PointerSize &#42; -0.5f, PointerSize &#42; 0.5f);

          // Set the rotation of the material icon
          ActualPointerLocation.X &#61; Clamp(ScreenHUDLocation.X, 8, Canvas.ClipX - 8) + RadarInfo&#91;i].Offset.X;
          ActualPointerLocation.Y &#61; Clamp(ScreenHUDLocation.Y - PointerSize + RadarInfo&#91;i].Offset.Y, 8, Canvas.ClipY - 8 - PointerSize) + (PointerSize &#42; 0.5f);
          RadarInfo&#91;i].MaterialInstanceConstant.SetScalarParameterValue(&#39;Rotation&#39;, GetAngle(ActualPointerLocation, ScreenHUDLocation));

          // Draw the material pointer
          Canvas.SetPos(ActualPointerLocation.X - (PointerSize &#42; 0.5f), ActualPointerLocation.Y - (PointerSize &#42; 0.5f));
          Canvas.DrawMaterialTile(RadarInfo&#91;i].MaterialInstanceConstant, PointerSize, PointerSize, 0.f, 0.f, 1.f, 1.f);
        }
        else
        {
          // Handle rendering the on screen indicator when the actor is behind the camera
          // Project the pawn&#39;s location
          ScreenHUDLocation &#61; Canvas.Project(RadarInfo&#91;i].UTPawn.Location);

          // Inverse the Screen HUD location
          ScreenHUDLocation.X &#61; Canvas.ClipX - ScreenHUDLocation.X;

          // If the screen HUD location is on the right edge, then swing it to the left
          if (ScreenHUDLocation.X &#62; (Canvas.ClipX - 8))
          {
            RadarInfo&#91;i].Offset.X -&#61; PointerSize &#42; RenderDelta &#42; 4.f;
            RadarInfo&#91;i].Offset.X &#61; FClamp(RadarInfo&#91;i].Offset.X, PointerSize &#42; -0.5f, PointerSize &#42; 0.5f);
          }
          else if (ScreenHUDLocation.X &#60; 8)
          {
            // If the screen HUD location is on the left edge, then swing it to the right
            RadarInfo&#91;i].Offset.X +&#61; PointerSize &#42; RenderDelta &#42; 4.f;
            RadarInfo&#91;i].Offset.X &#61; FClamp(RadarInfo&#91;i].Offset.X, PointerSize &#42; -0.5f, PointerSize &#42; 0.5f);
          }
          else
          {
            // If the screen HUD location is somewhere in the middle, then straighten it up
            RadarInfo&#91;i].Offset.X &#61; Lerp(RadarInfo&#91;i].Offset.X, 0.f, 4.f &#42; RenderDelta);
          }

          // Set the screen HUD location
          ScreenHUDLocation.X &#61; Clamp(ScreenHUDLocation.X, 8, Canvas.ClipX - 8);
          ScreenHUDLocation.Y &#61; Canvas.ClipY - 8;

          // Set the actual pointer location
          ActualPointerLocation.X &#61; ScreenHUDLocation.X + RadarInfo&#91;i].Offset.X;
          ActualPointerLocation.Y &#61; ScreenHUDLocation.Y - (PointerSize &#42; 0.5f);

          // Set the rotation of the material icon
          RadarInfo&#91;i].MaterialInstanceConstant.SetScalarParameterValue(&#39;Rotation&#39;, GetAngle(ActualPointerLocation, ScreenHUDLocation));

          // Draw the material pointer
          Canvas.SetPos(ActualPointerLocation.X - (PointerSize &#42; 0.5f), ActualPointerLocation.Y - (PointerSize &#42; 0.5f));
          Canvas.DrawMaterialTile(RadarInfo&#91;i].MaterialInstanceConstant, PointerSize, PointerSize, 0.f, 0.f, 1.f, 1.f);
        }
      }
    }
    else
    {
      // Null the variables previous stored so garbage collection can occur
      RadarInfo&#91;i].UTPawn &#61; None;
      RadarInfo&#91;i].MaterialInstanceConstant &#61; None;
      // Remove from the radar info array
      RadarInfo.Remove(i, 1);
      // Back step one, to maintain the for loop
      --i;
    }
  }

  // Setup the render delta
  LastHUDRenderTime &#61; WorldInfo.TimeSeconds;
  Super.PostRender();
}

function float GetAngle(Vector PointB, Vector PointC)
{
  // Check if angle can easily be determined if it is up or down
  if (PointB.X &#61;&#61; PointC.X)
  {
    return (PointB.Y &#60; PointC.Y) ? Pi : 0.f;
  }

  // Check if angle can easily be determined if it is left or right
  if (PointB.Y &#61;&#61; PointC.Y)
  {
    return (PointB.X &#60; PointC.X) ? (Pi &#42; 1.5f) : (Pi &#42; 0.5f);
  }

  return (2.f &#42; Pi) - atan2(PointB.X - PointC.X, PointB.Y - PointC.Y);
}

defaultproperties
{
}
</pre>
</div>
<p />
<h2><a name="Downloads"></a> Downloads </h2>
<hr size="1" noshade="noshade">
<p /> <ul>
<li> <a href="rsrc/Three/DevelopmentKitGemsAddingOnScreenIndicators/OnScreenIndicator.zip" target="_top">Download</a> the content and source code used for this development kit gem. (OnScreenIndicator.zip)
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
