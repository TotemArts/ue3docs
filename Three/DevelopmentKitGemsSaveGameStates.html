<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | DevelopmentKitGemsSaveGameStates    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">DevelopmentKitGemsSaveGameStates  </b></div>
<div id="tooltext">
<a href="DevelopmentKitGemsSaveGameStatesJP.html" class="twikiLink">日本語訳</a><br><a href="DevelopmentKitGemsSaveGameStatesCH.html" class="twikiLink">中国翻译</a><br><a href="DevelopmentKitGemsSaveGameStatesKR.html" class="twikiLink">한국어</a><br>

<!-- Three/DevelopmentKitGemsSaveGameStates -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="DevelopmentKitGems.html" class="twikiLink">Unreal Development Kit Gems</a></b> &gt; Save Game States <br/>
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="InputOutputHome.html" class="twikiLink">Input / Output</a></b> &gt; Save Game States <br/>
</div>
<hr size="1" noshade="noshade">
<p />
<h1><a name="Save Game States"></a> Save Game States </h1>
<hr size="1" noshade="noshade">
<p />
<strong><em>Last tested against UDK March, 2012</em></strong>
<p />
<strong><em>PC compatible</em></strong>
<br/>
<strong><em>Mac compatible</em></strong>
<br/>
<strong><em>iOS compatible</em></strong>
<p />
<div class="twikiToc"> <ul>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#Save Game States"> Save Game States</a> <ul>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#Overview"> Overview</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Developing with saved game states in mind"> Developing with saved game states in mind</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#General flow of how saved game states work"> General flow of how saved game states work</a> <ul>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#Player saves the game after playing a level for a while"> Player saves the game after playing a level for a while</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Serialize the level name"> Serialize the level name</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Serialize all actors that implement the _SaveGameStateInterface as JSon"> Serialize all actors that implement the SaveGameStateInterface as JSon</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Serialize Kismet and Matinee as JSon"> Serialize Kismet and Matinee as JSon</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Save the data using _BasicSaveObject"> Save the data using BasicSaveObject</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Player loads a game from a saved game state"> Player loads a game from a saved game state</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Load the saved game state object"> Load the saved game state object</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Load the map appending a command line to store saved game state file name"> Load the map appending a command line to store saved game state file name</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#When the map has finished loading, reload the saved game state object"> When the map has finished loading, reload the saved game state object</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Iterate over the JSon data and deserialize the data on the actors and objects within the level"> Iterate over the JSon data and deserialize the data on the actors and objects within the level</a>
</li></ul>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#KActor example"> KActor example</a> <ul>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#Serializing the KActor"> Serializing the KActor</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Deserializing the KActor"> Deserializing the KActor</a>
</li></ul>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Player controlled pawn example"> Player controlled pawn example</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Game State Loaded Kismet Event"> Game State Loaded Kismet Event</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Questions"> Questions</a> <ul>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#How do a handle child Actors or Objects?"> How do a handle child Actors or Objects?</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#The saved game state is stored as plain text! How would I prevent players from cheating?"> The saved game state is stored as plain text! How would I prevent players from cheating?</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Is it possible to store the JSon data online?"> Is it possible to store the JSon data online?</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#How do I integrate this Development Kit Gem!?"> How do I integrate this Development Kit Gem!?</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#I've integrated, but when I load a map nothing happens!"> I've integrated, but when I load a map nothing happens!</a>
</li></ul>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Related Topics"> Related Topics</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#Downloads"> Downloads</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
Unreal Engine 1 and Unreal Engine 2 supported save games by simply saving the entire level from memory to disk. While this method worked well in production, unfortunately any changes content developers made to the levels later on would not reflect over. To solve this problem, another way to represent saved games is to store just enough data, that the saved game is able to be restored by first loading the level and then applying saved game state data to all of the actors and objects in the level.
<p />
<h2><a name="Developing with saved game states in mind"></a> Developing with saved game states in mind </h2>
<hr size="1" noshade="noshade">
Due to the way saved game states work, you have to be very careful about what you destroy within the world. Once an actor is destroyed, it can no longer be picked up by the saved game state serializer because the actor is now gone. If the actor is transient, then it is generally not a problem. However, if the actor is level designer placed then when the level is reloaded and the saved game state data is applied, the level designer placed actor will not be affected as there is no data for it!
<p />
<h2><a name="General flow of how saved game states work"></a> General flow of how saved game states work </h2>
<hr size="1" noshade="noshade"> <ul>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#PlayerSavesTheGameAfterPlayingALevelForAWhile" class="twikiAnchorLink">Player saves the game after playing a level for a while.</a> <ol>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#SerializeTheLevelName" class="twikiAnchorLink">Serialize the level name.</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#SerializeAllActorsThatImplementTheSaveGameStateInterfaceAsJSon" class="twikiAnchorLink">Serialize all actors that implement the SaveGameStateInterface as JSon.</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#SerializeKismetAndMatineeAsJSon" class="twikiAnchorLink">Serialize Kismet and Matinee as JSon.</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#SaveTheDataUsingBasicSaveObject" class="twikiAnchorLink">Save the data using BasicSaveObject.</a>
</li></ol>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#PlayerLoadsAGameFromASavedGameState" class="twikiAnchorLink">Player loads a game from a saved game state.</a> <ol>
<li> <a href="DevelopmentKitGemsSaveGameStates.html#LoadTheSavedGameStateObject" class="twikiAnchorLink">Load the saved game state object.</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#LoadTheMapAppendingACommandLineToStoreSavedGameStateFileName" class="twikiAnchorLink">Load the map appending a command line to store saved game state file name.</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#WhenTheMapHasFinishedLoadingReloadTheSavedGameStateObject" class="twikiAnchorLink">When the map has finished loading, reload the saved game state object</a>
</li> <li> <a href="DevelopmentKitGemsSaveGameStates.html#IterateOverTheJSonDataAndDeserializeTheDataOnTheActorsAndObjectsWithinTheLevel" class="twikiAnchorLink">Iterate over the JSon data and deserialize the data on the actors and objects within the level.</a>
</li></ol>
</li></ul>
<p />
<a name="PlayerSavesTheGameAfterPlayingALevelForAWhile"></a>
<h3><a name="Player saves the game after playing a level for a while"></a> Player saves the game after playing a level for a while </h3>
For example purposes, only a console command has been added to this development kit gem. Obviously, your game will have a graphical user interface attached to it, however you can always call the same console command with the file name parameter anyways. Or the console command function could be made static as it is not dependent on executing within a particular instance of an actor or object (It calls PlayerController::ClientMessage(), but you can always get the local player controller by using Actor::GetALocalPlayerController()).
<p />
When the console command is executed, it kick starts the save game state process. First the SaveGameState object is instanced. The SaveGameState object handles iterating and serializing Actors, Kismet and Matinee. We then "scrub" the file name. Scrubbing the file name just ensures that there are no illegal characters added, although in this case only spaces were checked for. For a more robust scrubbing, you may want to consider ensuring that characters such as \, /, ?, ! are <strong>not</strong> in the file name. The scrubbing function also ensure that the file extension "sav" is also added if it hasn't been already. The SaveGameState is then asked to iterate and serialize Actors, Kismet and Matinee. Finally, if the SaveGameState was successfully saved to disk by BasicSaveObject(), then a message is sent to the player stating that the game was saved.
<p />
<div class="codetitlebar">
SaveGameStatePlayerController.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; This exec function will save the game state to the file name provided.
 &#42;
 &#42; &#64;param      FileName      File name to save the SaveGameState to
 &#42;/
exec function SaveGameState(string FileName)
{
  local SaveGameState SaveGameState;

  // Instance the save game state
  SaveGameState &#61; new () class&#39;SaveGameState&#39;;
  if (SaveGameState &#61;&#61; None)
  {
    return;
  }

  // Scrub the file name
  FileName &#61; ScrubFileName(FileName);

  // Ask the save game state to save the game
  SaveGameState.SaveGameState();

  // Serialize the save game state object onto disk
  if (class&#39;Engine&#39;.static.BasicSaveObject(SaveGameState, FileName, true, class&#39;SaveGameState&#39;.const.SAVEGAMESTATE&#95;REVISION))
  {
    // If successful then send a message
    ClientMessage(&#34;Saved game state to &#34;$FileName$&#34;.&#34;, &#39;System&#39;);
  }
}
</pre>
</div>
<p />
<a name="SerializeTheLevelName"></a>
<h3><a name="Serialize the level name"></a> Serialize the level name </h3>
The saved game state serializes the level name (or map file name) so that the saved game state knows which map it is to load when it, itself is loaded. Rather than storing this in another file such as the configuration file, it makes more sense to simply store it within the saved game state. The saved game state only needs to set the variables it wants saved, as BasicSaveObject() will perform the actual saving to disk for you. If any streaming levels are visible or have a load request pending, then they are saved into an array so that when the save game state is reloaded the streaming levels will be loaded straight away. This step also saves the current GameInfo class.
<p />
<div class="codetitlebar">
SaveGameState.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Saves the game state by serializing all of the actors that implement the SaveGameStateInterface, Kismet and Matinee.
 &#42;/
function SaveGameState()
{
  local WorldInfo WorldInfo;

  // Get the world info, abort if the world info could not be found
  WorldInfo &#61; class&#39;WorldInfo&#39;.static.GetWorldInfo();
  if (WorldInfo &#61;&#61; None)
  {
    return;
  }

  // Save the map file name
  PersistentMapFileName&#61; String(WorldInfo.GetPackageName());

  // Save the currently streamed in map file names
  if (WorldInfo.StreamingLevels.Length &#62; 0)
  {
    // Iterate through the streaming levels
    for (i &#61; 0; i &#60; WorldInfo.StreamingLevels.Length; ++i)
    {
      // Levels that are visible and has a load request pending should be included in the streaming levels list
      if (WorldInfo.StreamingLevels&#91;i] !&#61; None &#38;&#38; (WorldInfo.StreamingLevels&#91;i].bIsVisible &#124;&#124; WorldInfo.StreamingLevels&#91;i].bHasLoadRequestPending))
      {
        StreamingMapFileNames.AddItem(String(WorldInfo.StreamingLevels&#91;i].PackageName));
      }
    }
  }

  // Save the game info class
  GameInfoClassName &#61; PathName(WorldInfo.Game.Class);
}
</pre>
</div>
<p />
<a name="SerializeAllActorsThatImplementTheSaveGameStateInterfaceAsJSon"></a>
<h3><a name="Serialize all actors that implement the _SaveGameStateInterface as JSon"></a> Serialize all actors that implement the SaveGameStateInterface as JSon </h3>
Only dynamic actors need to be serialized, so the iterator of choice here was DynamicActors. A filter for SaveGameStateInterface was also added, as that allows you to decide which dynamic actors need to be serialized and which do not. An interface is used here as it is easier to extend the save game state later on, since it is the actor which will serialize and deserialize the JSon data later on. When the Actor implementing SaveGameStateInterface is asked to serialize itself, it returns the encoded JSon string. The string is added the SerializedActorData array, which is then saved by BasicSaveObject().
<p />
<div class="codetitlebar">
SaveGameState.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Saves the game state by serializing all of the actors that implement the SaveGameStateInterface, Kismet and Matinee.
 &#42;/
function SaveGameState()
{
  local WorldInfo WorldInfo;
  local Actor Actor;
  local String SerializedActorData;
  local SaveGameStateInterface SaveGameStateInterface;
  local int i;

  // Get the world info, abort if the world info could not be found
  WorldInfo &#61; class&#39;WorldInfo&#39;.static.GetWorldInfo();
  if (WorldInfo &#61;&#61; None)
  {
    return;
  }

  // Save the persistent map file name
  PersistentMapFileName &#61; String(WorldInfo.GetPackageName());

  // Save the currently streamed in map file names
  if (WorldInfo.StreamingLevels.Length &#62; 0)
  {
    // Iterate through the streaming levels
    for (i &#61; 0; i &#60; WorldInfo.StreamingLevels.Length; ++i)
    {
      // Levels that are visible and has a load request pending should be included in the streaming levels list
      if (WorldInfo.StreamingLevels&#91;i] !&#61; None &#38;&#38; (WorldInfo.StreamingLevels&#91;i].bIsVisible &#124;&#124; WorldInfo.StreamingLevels&#91;i].bHasLoadRequestPending))
      {
        StreamingMapFileNames.AddItem(String(WorldInfo.StreamingLevels&#91;i].PackageName));
      }
    }
  }

  // Save the game info class
  GameInfoClassName &#61; PathName(WorldInfo.Game.Class);

  // Iterate through all of the actors that implement SaveGameStateInterface and ask them to serialize themselves
  ForEach WorldInfo.DynamicActors(class&#39;Actor&#39;, Actor, class&#39;SaveGameStateInterface&#39;)
  {
    // Type cast to the SaveGameStateInterface
    SaveGameStateInterface &#61; SaveGameStateInterface(Actor);
    if (SaveGameStateInterface !&#61; None)
    {
      // Serialize the actor
      SerializedActorData &#61; SaveGameStateInterface.Serialize();
      // If the serialzed actor data is valid, then add it to the serialized world data array
      if (SerializedActorData !&#61; &#34;&#34;)
      {
        SerializedWorldData.AddItem(SerializedActorData);
      }
    }
  }
}
</pre>
</div>
<p />
The SaveGameStateInterface is very simple. It has two functions that every Actor implementing it, must implement. Serialize(), which handles serializing all of the data required by the Actor at loading time. And Deserialize() handles reading the JSon data saved at an earlier point in time, and restoring the appropriate values.
<p />
<div class="codetitlebar">
SaveGameStateInterface.uc
</div>
<div class="codesnippet">
<pre>
interface SaveGameStateInterface;

/&#42;&#42;
 &#42; Serializes the actor&#39;s data into JSon
 &#42;
 &#42; &#64;return  JSon data representing the state of this actor
 &#42;/
function String Serialize();

/&#42;&#42;
 &#42; Deserializes the actor from the data given
 &#42;
 &#42; &#64;param  Data  JSon data representing the differential state of this actor
 &#42;/
function Deserialize(JSonObject Data);
</pre>
</div>
<p />
<a name="SerializeKismetAndMatineeAsJSon"></a>
<h3><a name="Serialize Kismet and Matinee as JSon"></a> Serialize Kismet and Matinee as JSon </h3>
The save game state is also able to serialize Kismet Events and Kismet Variables. This allows game designers to implement a portion of the game using Kismet. This is done by iterating though the level's Kismet Events and Kismet variables and serializing each one.
<p />
Kismet Events have their ActivationTime calculated as offsets. When the saved game state is reloaded, the WorldInfo.TimeSeconds is usually at zero or a very small number. This is unlikely to be the time when the game was saved previously. ActivationTime is mostly important if the Kismet Event has set its ReTriggerDelay variable. Thus to prevent the bug where a Kismet Event is retriggered too quickly by saving and loading, it is required to calculate the time remaining from ActivationTime with ReTriggerDelay in consideration. This way, when the Kismet Event is reloaded the ActivationTime is usually set in the future, if it had been triggered. The other value that is saved is the TriggerCount. This is usually required for triggers that have their MaxTriggerCount values set to something other than zero.
<p />
Kismet Variables are detected using a typecasting trial and error method. Another option would have been to iterate over the Kismet Sequence Objects looking for each type of Kismet Variable. Either approach is fine. Once a Kismet Variable has been detected, its value is then serialized.
<p />
<div class="codetitlebar">
SaveGameState.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Saves the Kismet game state
 &#42;/
protected function SaveKismetState()
{
  local WorldInfo WorldInfo;
  local array&#60;Sequence&#62; RootSequences;
  local array&#60;SequenceObject&#62; SequenceObjects;
  local SequenceEvent SequenceEvent;
  local SeqVar&#95;Bool SeqVar&#95;Bool;
  local SeqVar&#95;Float SeqVar&#95;Float;
  local SeqVar&#95;Int SeqVar&#95;Int;
  local SeqVar&#95;Object SeqVar&#95;Object;
  local SeqVar&#95;String SeqVar&#95;String;
  local SeqVar&#95;Vector SeqVar&#95;Vector;
  local int i, j;
  local JSonObject JSonObject;

  // Get the world info, abort if it does not exist
  WorldInfo &#61; class&#39;WorldInfo&#39;.static.GetWorldInfo();
  if (WorldInfo &#61;&#61; None)
  {
    return;
  }

  // Get all of the root sequences within the world, abort if there are no root sequences
  RootSequences &#61; WorldInfo.GetAllRootSequences();
  if (RootSequences.Length &#60;&#61; 0)
  {
    return;
  }

  // Serialize all SequenceEvents and SequenceVariables
  for (i &#61; 0; i &#60; RootSequences.Length; ++i)
  {
    if (RootSequences&#91;i] !&#61; None)
    {
      // Serialize Kismet Events
      RootSequences&#91;i].FindSeqObjectsByClass(class&#39;SequenceEvent&#39;, true, SequenceObjects);
      if (SequenceObjects.Length &#62; 0)
      {
        for (j &#61; 0; j &#60; SequenceObjects.Length; ++j)
        {
          SequenceEvent &#61; SequenceEvent(SequenceObjects&#91;j]);
          if (SequenceEvent !&#61; None)
          {
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SequenceEvent so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SequenceEvent));
              // Calculate the activation time of what it should be when the saved game state is loaded. This is done as the retrigger delay minus the difference between the current world time
              // and the last activation time. If the result is negative, then it means this was never triggered before, so always make sure it is larger or equal to zero.
              JsonObject.SetFloatValue(&#34;ActivationTime&#34;, FMax(SequenceEvent.ReTriggerDelay - (WorldInfo.TimeSeconds - SequenceEvent.ActivationTime), 0.f));
              // Save the current trigger count
              JSonObject.SetIntValue(&#34;TriggerCount&#34;, SequenceEvent.TriggerCount);
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }
          }
        }
      }

      // Serialize Kismet Variables
      RootSequences&#91;i].FindSeqObjectsByClass(class&#39;SequenceVariable&#39;, true, SequenceObjects);
      if (SequenceObjects.Length &#62; 0)
      {
        for (j &#61; 0; j &#60; SequenceObjects.Length; ++j)
        {
          // Attempt to serialize as a boolean variable
          SeqVar&#95;Bool &#61; SeqVar&#95;Bool(SequenceObjects&#91;j]);
          if (SeqVar&#95;Bool !&#61; None)
          {
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SeqVar&#95;Bool so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SeqVar&#95;Bool));
              // Save the boolean value
              JSonObject.SetIntValue(&#34;Value&#34;, SeqVar&#95;Bool.bValue);
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }

            // Continue to the next one within the array as we&#39;re done with this array index
            continue;
          }

          // Attempt to serialize as a float variable
          SeqVar&#95;Float &#61; SeqVar&#95;Float(SequenceObjects&#91;j]);
          if (SeqVar&#95;Float !&#61; None)
          {
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SeqVar&#95;Float so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SeqVar&#95;Float));
              // Save the float value
              JSonObject.SetFloatValue(&#34;Value&#34;, SeqVar&#95;Float.FloatValue);
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }

            // Continue to the next one within the array as we&#39;re done with this array index
            continue;
          }

          // Attempt to serialize as an int variable
          SeqVar&#95;Int &#61; SeqVar&#95;Int(SequenceObjects&#91;j]);
          if (SeqVar&#95;Int !&#61; None)
          {
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SeqVar&#95;Int so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SeqVar&#95;Int));
              // Save the int value
              JSonObject.SetIntValue(&#34;Value&#34;, SeqVar&#95;Int.IntValue);
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }

            // Continue to the next one within the array as we&#39;re done with this array index
            continue;
          }

          // Attempt to serialize as an object variable
          SeqVar&#95;Object &#61; SeqVar&#95;Object(SequenceObjects&#91;j]);
          if (SeqVar&#95;Object !&#61; None)
          {
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SeqVar&#95;Object so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SeqVar&#95;Object));
              // Save the object value
              JSonObject.SetStringValue(&#34;Value&#34;, PathName(SeqVar&#95;Object.GetObjectValue()));
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }

            // Continue to the next one within the array as we&#39;re done with this array index
            continue;
          }

          // Attempt to serialize as a string variable
          SeqVar&#95;String &#61; SeqVar&#95;String(SequenceObjects&#91;j]);
          if (SeqVar&#95;String !&#61; None)
          {
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SeqVar&#95;String so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SeqVar&#95;String));
              // Save the string value
              JSonObject.SetStringValue(&#34;Value&#34;, SeqVar&#95;String.StrValue);
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }

            // Continue to the next one within the array as we&#39;re done with this array index
            continue;
          }

          // Attempt to serialize as a vector variable
          SeqVar&#95;Vector &#61; SeqVar&#95;Vector(SequenceObjects&#91;j]);
          if (SeqVar&#95;Vector !&#61; None)
          {
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SeqVar&#95;Vector so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SeqVar&#95;Vector));
              // Save the vector value
              JSonObject.SetFloatValue(&#34;Value&#95;X&#34;, SeqVar&#95;Vector.VectValue.X);
              JSonObject.SetFloatValue(&#34;Value&#95;Y&#34;, SeqVar&#95;Vector.VectValue.Y);
              JSonObject.SetFloatValue(&#34;Value&#95;Z&#34;, SeqVar&#95;Vector.VectValue.Z);
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }

            // Continue to the next one within the array as we&#39;re done with this array index
            continue;
          }
        }
      }
    }
  }
}
</pre>
</div>
<p />
Saving Matinee is done in the same way as saving Kismet, as what it saved is the Matinee Kismet Sequence Action. That is, all of the Kismet Sequence Objects are iterated over, and filtering is done for the SeqAct_Interp class. Then the variables relevant are serialized and added to the SerializedWorldData array.
<p />
<div class="codetitlebar">
SaveGameState.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Saves the Matinee game state
 &#42;/
protected function SaveMatineeState()
{
  local WorldInfo WorldInfo;
  local array&#60;Sequence&#62; RootSequences;
  local array&#60;SequenceObject&#62; SequenceObjects;
  local SeqAct&#95;Interp SeqAct&#95;Interp;
  local int i, j;
  local JSonObject JSonObject;

  // Get the world info, abort if it does not exist
  WorldInfo &#61; class&#39;WorldInfo&#39;.static.GetWorldInfo();
  if (WorldInfo &#61;&#61; None)
  {
    return;
  }

  // Get all of the root sequences within the world, abort if there are no root sequences
  RootSequences &#61; WorldInfo.GetAllRootSequences();
  if (RootSequences.Length &#60;&#61; 0)
  {
    return;
  }

  // Serialize all SequenceEvents and SequenceVariables
  for (i &#61; 0; i &#60; RootSequences.Length; ++i)
  {
    if (RootSequences&#91;i] !&#61; None)
    {
      // Serialize Matinee Kismet Sequence Actions
      RootSequences&#91;i].FindSeqObjectsByClass(class&#39;SeqAct&#95;Interp&#39;, true, SequenceObjects);
      if (SequenceObjects.Length &#62; 0)
      {
        for (j &#61; 0; j &#60; SequenceObjects.Length; ++j)
        {
          SeqAct&#95;Interp &#61; SeqAct&#95;Interp(SequenceObjects&#91;j]);
          if (SeqAct&#95;Interp !&#61; None)
          {
            // Attempt to serialize the data
            JSonObject &#61; new () class&#39;JSonObject&#39;;
            if (JSonObject !&#61; None)
            {
              // Save the path name of the SeqAct&#95;Interp so it can found later
              JSonObject.SetStringValue(&#34;Name&#34;, PathName(SeqAct&#95;Interp));
              // Save the current position of the SeqAct&#95;Interp
              JSonObject.SetFloatValue(&#34;Position&#34;, SeqAct&#95;Interp.Position);
              // Save if the SeqAct&#95;Interp is playing or not
              JSonObject.SetIntValue(&#34;IsPlaying&#34;, (SeqAct&#95;Interp.bIsPlaying) ? 1 : 0);
              // Save if the SeqAct&#95;Interp is paused or not
              JSonObject.SetIntValue(&#34;Paused&#34;, (SeqAct&#95;Interp.bPaused) ? 1 : 0);
              // Encode this and append it to the save game data array
              SerializedWorldData.AddItem(class&#39;JSonObject&#39;.static.EncodeJson(JSonObject));
            }
          }
        }
      }
    }
  }
}
</pre>
</div>
<p />
<a name="SaveTheDataUsingBasicSaveObject"></a>
<h3><a name="Save the data using _BasicSaveObject"></a> Save the data using BasicSaveObject </h3>
As shown earlier, the save game state data is saved by BasicSaveObject(). BasicSaveObject() returns true or false depending if the file was written successfully or not. This allows you to display a message if the saved game was saved successfully or not.
<p />
<div class="codetitlebar">
SaveGameStatePlayerController.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; This exec function will save the game state to the file name provided.
 &#42;
 &#42; &#64;param      FileName      File name to save the SaveGameState to
 &#42;/
exec function SaveGameState(string FileName)
{
  local SaveGameState SaveGameState;

  // Instance the save game state
  SaveGameState &#61; new () class&#39;SaveGameState&#39;;
  if (SaveGameState &#61;&#61; None)
  {
    return;
  }

  // Scrub the file name
  FileName &#61; ScrubFileName(FileName);

  // Ask the save game state to save the game
  SaveGameState.SaveGameState();

  // Serialize the save game state object onto disk
  if (class&#39;Engine&#39;.static.BasicSaveObject(SaveGameState, FileName, true, class&#39;SaveGameState&#39;.const.SAVEGAMESTATE&#95;REVISION))
  {
    // If successful then send a message
    ClientMessage(&#34;Saved game state to &#34;$FileName$&#34;.&#34;, &#39;System&#39;);
  }
}
</pre>
</div>
<p />
<hr/>
<p />
<a name="PlayerLoadsAGameFromASavedGameState"></a>
<h3><a name="Player loads a game from a saved game state"></a> Player loads a game from a saved game state </h3>
LoadGameState() is the entry point from where saved game states are loaded. Again, this function may be made a static function as it is not really dependent on any class instances.
<p />
<div class="codetitlebar">
SaveGameStatePlayerController.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; This exec function will load the game state from the file name provided
 &#42;
 &#42; &#64;param    FileName    File name of load the SaveGameState from
 &#42;/
exec function LoadGameState(string FileName);
</pre>
</div>
<p />
<a name="LoadTheSavedGameStateObject"></a>
<h3><a name="Load the saved game state object"></a> Load the saved game state object </h3>
The saved game state object is first loaded from disk using BasicLoadObject().
<p />
<div class="codetitlebar">
SaveGameStatePlayerController.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; This exec function will load the game state from the file name provided
 &#42;
 &#42; &#64;param    FileName    File name of load the SaveGameState from
 &#42;/
exec function LoadGameState(string FileName)
{
  local SaveGameState SaveGameState;

  // Instance the save game state
  SaveGameState &#61; new () class&#39;SaveGameState&#39;;
  if (SaveGameState &#61;&#61; None)
  {
    return;
  }

  // Scrub the file name
  FileName &#61; ScrubFileName(FileName);

  // Attempt to deserialize the save game state object from disk
  if (class&#39;Engine&#39;.static.BasicLoadObject(SaveGameState, FileName, true, class&#39;SaveGameState&#39;.const.SAVEGAMESTATE&#95;REVISION))
  {
  }
}
</pre>
</div>
<p />
<a name="LoadTheMapAppendingACommandLineToStoreSavedGameStateFileName"></a>
<h3><a name="Load the map appending a command line to store saved game state file name"></a> Load the map appending a command line to store saved game state file name </h3>
If the saved game state object was loaded successfully, then the serialized map is loaded with command line parameters stating that when the map has finished loading, it should continue loading up the saved game state defined. If you decide to make this function a static function, you can call ConsoleCommand() from other global referenceable Actors.
<p />
<img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note</strong>: The console command 'start' is used here instead of 'open' because 'start' always resets the command line parameters; where as 'open' <em>appends</em> command line parameters. This is very important, otherwise the command line parameter "SaveGameState" will be appended multiple times which will lead to incorrect loading of the save game state!
<p />
<div class="codetitlebar">
SaveGameStatePlayerController.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; This exec function will load the game state from the file name provided
 &#42;
 &#42; &#64;param    FileName    File name of load the SaveGameState from
 &#42;/
exec function LoadGameState(string FileName)
{
  local SaveGameState SaveGameState;

  // Instance the save game state
  SaveGameState &#61; new () class&#39;SaveGameState&#39;;
  if (SaveGameState &#61;&#61; None)
  {
    return;
  }

  // Scrub the file name
  FileName &#61; ScrubFileName(FileName);

  // Attempt to deserialize the save game state object from disk
  if (class&#39;Engine&#39;.static.BasicLoadObject(SaveGameState, FileName, true, class&#39;SaveGameState&#39;.const.SAVEGAMESTATE&#95;REVISION))
  {
    // Start the map with the command line parameters required to then load the save game state
    ConsoleCommand(&#34;start &#34;$SaveGameState.PersistentMapFileName$&#34;?Game&#61;&#34;$SaveGameState.GameInfoClassName$&#34;?SaveGameState&#61;&#34;$FileName);
  }
}
</pre>
</div>
<p />
<a name="WhenTheMapHasFinishedLoadingReloadTheSavedGameStateObject"></a>
<h3><a name="When the map has finished loading, reload the saved game state object"></a> When the map has finished loading, reload the saved game state object </h3>
When the map has loaded, SaveStateGameInfo::InitGame() picks out whether or not a save game state command line parameter exists or not. If it does then it saves the value within PendingSaveGameFileName. Then when the match is started, the save game state object is loaded from disk again and is asked to load the game state. When the saved game state is loaded, a message is sent to the player to inform him / her that the saved game has loaded. If there are any streaming levels, then SaveStateGameInfo::StartMatch() will ask all player controllers streaming in the other maps. However, because streaming in the other maps will not be finished in the same tick, a looping timer called SaveStateGameInfo::WaitingForStreamingLevelsTimer() is setup to watch for when all streaming levels have finished loading. When the streaming maps have finished loading, then the match is started by calling Super.StartMatch() [UTGame::StartMatch()].
<p />
<div class="codetitlebar">
SaveGameStateGameInfo.uc
</div>
<div class="codesnippet">
<pre>
class SaveGameStateGameInfo extends UTGame;

// Pending save game state file name
var private string PendingSaveGameFileName;

/&#42;
 &#42; Initialize the game. The GameInfo&#39;s InitGame() function is called before any other scripts (including PreBeginPlay()), and is used by the GameInfo to initialize parameters and spawn its helper classes.
 &#42;
 &#42; &#64;param    Options        Passed options from the command line
 &#42; &#64;param    ErrorMessage    Out going error messages
 &#42;/
event InitGame(string Options, out string ErrorMessage)
{
  Super.InitGame(Options, ErrorMessage);

  // Set the pending save game file name if required
  if (HasOption(Options, &#34;SaveGameState&#34;))
  {
    PendingSaveGameFileName &#61; ParseOption(Options, &#34;SaveGameState&#34;);
  }
  else
  {
    PendingSaveGameFileName &#61; &#34;&#34;;
  }
}

/&#42;&#42;
 &#42; Start the match - inform all actors that the match is starting, and spawn player pawns
 &#42;/
function StartMatch()
{
  local SaveGameState SaveGameState;
  local PlayerController PlayerController;
  local int i;

  // Check if we need to load the game or not
  if (PendingSaveGameFileName !&#61; &#34;&#34;)
  {
    // Instance the save game state
    SaveGameState &#61; new () class&#39;SaveGameState&#39;;
    if (SaveGameState &#61;&#61; None)
    {
      return;
    }

    // Attempt to deserialize the save game state object from disk
    if (class&#39;Engine&#39;.static.BasicLoadObject(SaveGameState, PendingSaveGameFileName, true, class&#39;SaveGameState&#39;.const.SAVEGAMESTATE&#95;REVISION))
    {
      // Synchrously load in any streaming levels
      if (SaveGameState.StreamingMapFileNames.Length &#62; 0)
      {
        // Ask every player controller to load up the streaming map
        ForEach WorldInfo.AllControllers(class&#39;PlayerController&#39;, PlayerController)
        {
          // Stream map files now
          for (i &#61; 0; i &#60; SaveGameState.StreamingMapFileNames.Length; ++i)
          {
            PlayerController.ClientUpdateLevelStreamingStatus(Name(SaveGameState.StreamingMapFileNames&#91;i]), true, true, true);
          }

          // Block everything until pending loading is done
          PlayerController.ClientFlushLevelStreaming();
        }

        // Store the save game state in StreamingSaveGameState
        StreamingSaveGameState &#61; SaveGameState;
        // Start the looping timer which waits for all streaming levels to finish loading
        SetTimer(0.05f, true, NameOf(WaitingForStreamingLevelsTimer));
        return;
      }

      // Load the game state
      SaveGameState.LoadGameState();
    }

    // Send a message to all player controllers that we&#39;ve loaded the save game state
    ForEach WorldInfo.AllControllers(class&#39;PlayerController&#39;, PlayerController)
    {
      PlayerController.ClientMessage(&#34;Loaded save game state from &#34;$PendingSaveGameFileName$&#34;.&#34;, &#39;System&#39;);
    }
  }

  Super.StartMatch();
}

function WaitingForStreamingLevelsTimer()
{
  local int i;
  local PlayerController PlayerController;

  for (i &#61; 0; i &#60; WorldInfo.StreamingLevels.Length; ++i)
  {
    // If any levels still have the load request pending, then return
    if (WorldInfo.StreamingLevels&#91;i].bHasLoadRequestPending)
    {
      return;
    }
  }

  // Clear the looping timer
  ClearTimer(NameOf(WaitingForStreamingLevelsTimer));

  // Load the save game state
  StreamingSaveGameState.LoadGameState();
  // Clear it for garbage collection
  StreamingSaveGameState &#61; None;

  // Send a message to all player controllers that we&#39;ve loaded the save game state
  ForEach WorldInfo.AllControllers(class&#39;PlayerController&#39;, PlayerController)
  {
    PlayerController.ClientMessage(&#34;Loaded save game state from &#34;$PendingSaveGameFileName$&#34;.&#34;, &#39;System&#39;);
  }

  // Start the match
  Super.StartMatch();
}
</pre>
</div>
<p />
<a name="IterateOverTheJSonDataAndDeserializeTheDataOnTheActorsAndObjectsWithinTheLevel"></a>
<h3><a name="Iterate over the JSon data and deserialize the data on the actors and objects within the level"></a> Iterate over the JSon data and deserialize the data on the actors and objects within the level </h3>
Now that the saved game state object has been loaded, it is now possible to iterate over the Actors that implement SaveGameStateInterface, Kismet and Matinee and restore them based on the data stored in SerializedWorldData array (which is now encoded as JSon).
<p />
As SerializedWorldData is iterated over, each entry is decoded as a JSonObject. Retrieving the Name will provide some insight as to what the JSonObject data is relevant to. Testing for SeqAct_Interp will reveal that the data is relevant for a Matinee Object, SeqEvent or SeqVar for either Kismet Event or a Kismet Variables. If those three fail, then it must be for an Actor in the world.
<p />
If the JSonObject data is for an Actor in the world, then the actor is retrieved by using FindObject(). As the full path name of the Actor is stored, FindObject() should be able to find any Actor that was placed by the level designer. If FindObject() fails, then it must be for an Actor that was instanced during play. This is why it is often useful to store the ObjectArchetype too, so that it can be reinstanced by the saved game state if required. Once the Actor is found or instanced, the Actor is then casted to SaveGameStateInterface and is then asked to deserialize itself based on the data stored within the JSonObject.
<p />
<div class="codetitlebar">
SaveGameState.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Loads the game state by deserializing all of the serialized data and applying the data to the actors that implement the SaveGameStateInterface, Kisment and Matinee.
 &#42;/
function LoadGameState()
{
  local WorldInfo WorldInfo;
  local int i;
  local JSonObject JSonObject;
  local String ObjectName;
  local SaveGameStateInterface SaveGameStateInterface;
  local Actor Actor, ActorArchetype;

  // No serialized world data to load!
  if (SerializedWorldData.Length &#60;&#61; 0)
  {
    return;
  }

  // Grab the world info, abort if no valid world info
  WorldInfo &#61; class&#39;WorldInfo&#39;.static.GetWorldInfo();
  if (WorldInfo &#61;&#61; None)
  {
    return;
  }

  // For each serialized data object
  for (i &#61; 0; i &#60; SerializedWorldData.Length; ++i)
  {
    if (SerializedWorldData&#91;i] !&#61; &#34;&#34;)
    {
      // Decode the JSonObject from the encoded string
      JSonObject &#61; class&#39;JSonObject&#39;.static.DecodeJson(SerializedWorldData&#91;i]);
      if (JSonObject !&#61; None)
      {
        // Get the object name
        ObjectName &#61; JSonObject.GetStringValue(&#34;Name&#34;);
        // Check if the object name contains SeqAct&#95;Interp, if so deserialize Matinee
        if (InStr(ObjectName, &#34;SeqAct&#95;Interp&#34;,, true) !&#61; INDEX&#95;NONE)
        {
          LoadMatineeState(ObjectName, JSonObject);
        }
        // Check if the object name contains SeqEvent or SeqVar, if so deserialize Kismet
        else if (InStr(ObjectName, &#34;SeqEvent&#34;,, true) !&#61; INDEX&#95;NONE &#124;&#124; InStr(ObjectName, &#34;SeqVar&#34;,, true) !&#61; INDEX&#95;NONE)
        {
          LoadKismetState(ObjectName, JSonObject);
        }
        // Otherwise it is some other type of actor
        else
        {
          // Try to find the persistent level actor
          Actor &#61; Actor(FindObject(ObjectName, class&#39;Actor&#39;));

          // If the actor was not in the persistent level, then it must have been transient then attempt to spawn it
          if (Actor &#61;&#61; None)
          {
            // Spawn the actor
            ActorArchetype &#61; GetActorArchetypeFromName(JSonObject.GetStringValue(&#34;ObjectArchetype&#34;));
            if (ActorArchetype !&#61; None)
            {
              Actor &#61; WorldInfo.Spawn(ActorArchetype.Class,,,,, ActorArchetype, true);
            }
          }

          if (Actor !&#61; None)
          {
            // Cast to the save game state interface
            SaveGameStateInterface &#61; SaveGameStateInterface(Actor);
            if (SaveGameStateInterface !&#61; None)
            {
              // Deserialize the actor
              SaveGameStateInterface.Deserialize(JSonObject);
            }
          }
        }
      }
    }
  }
}

/&#42;&#42;
 &#42; Returns an actor archetype from the name
 &#42;
 &#42; &#64;return    Returns an actor archetype from the string representation
 &#42;/
function Actor GetActorArchetypeFromName(string ObjectArchetypeName)
{
  local WorldInfo WorldInfo;

  WorldInfo &#61; class&#39;WorldInfo&#39;.static.GetWorldInfo();
  if (WorldInfo &#61;&#61; None)
  {
    return None;
  }

  // Use static look ups if on the console, for static look ups to work
  //  &#42; Force cook the classes or packaged archetypes to the maps
  //  &#42; Add packaged archetypes to the StartupPackage list
  //  &#42; Reference the packages archetypes somewhere within Unrealscript
  if (WorldInfo.IsConsoleBuild())
  {
    return Actor(FindObject(ObjectArchetypeName, class&#39;Actor&#39;));
  }
  else // Use dynamic look ups if on the PC
  {
    return Actor(DynamicLoadObject(ObjectArchetypeName, class&#39;Actor&#39;));
  }
}
</pre>
</div>
<p />
Deserializing Kismet is done in much the same way as deserializing Actors, with the exception that if a Kismet Sequence Object cannot be found, Unrealscript will not attempt to instance it. Once the Kismet Sequence Object is found using FindObject(), it is then type casted to find out what it is exactly. From there the saved values from the JSonObject is restored.
<p />
<div class="codetitlebar">
SaveGameState.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Loads the Kismet Sequence state based on the data provided
 &#42;
 &#42; &#64;param    ObjectName    Name of the Kismet object in the level
 &#42; &#64;param    Data      Data as JSon for the Kismet object
 &#42;/
function LoadKismetState(string ObjectName, JSonObject Data)
{
  local SequenceEvent SequenceEvent;
  local SeqVar&#95;Bool SeqVar&#95;Bool;
  local SeqVar&#95;Float SeqVar&#95;Float;
  local SeqVar&#95;Int SeqVar&#95;Int;
  local SeqVar&#95;Object SeqVar&#95;Object;
  local SeqVar&#95;String SeqVar&#95;String;
  local SeqVar&#95;Vector SeqVar&#95;Vector;
  local Object SequenceObject;
  local WorldInfo WorldInfo;

  // Attempt to find the sequence object
  SequenceObject &#61; FindObject(ObjectName, class&#39;Object&#39;);

  // Could not find sequence object, so abort
  if (SequenceObject &#61;&#61; None)
  {
    return;
  }

  // Deserialize Kismet Event
  SequenceEvent &#61; SequenceEvent(SequenceObject);
  if (SequenceEvent !&#61; None)
  {
    WorldInfo &#61; class&#39;WorldInfo&#39;.static.GetWorldInfo();
    if (WorldInfo !&#61; None)
    {
      SequenceEvent.ActivationTime &#61; WorldInfo.TimeSeconds + Data.GetFloatValue(&#34;ActivationTime&#34;);
    }

    SequenceEvent.TriggerCount &#61; Data.GetIntValue(&#34;TriggerCount&#34;);
    return;
  }

  // Deserialize Kismet Variable Bool
  SeqVar&#95;Bool &#61; SeqVar&#95;Bool(SequenceObject);
  if (SeqVar&#95;Bool !&#61; None)
  {
    SeqVar&#95;Bool.bValue &#61; Data.GetIntValue(&#34;Value&#34;);
    return;
  }

  // Deserialize Kismet Variable Float
  SeqVar&#95;Float &#61; SeqVar&#95;Float(SequenceObject);
  if (SeqVar&#95;Float !&#61; None)
  {
    SeqVar&#95;Float.FloatValue &#61; Data.GetFloatValue(&#34;Value&#34;);
    return;
  }

  // Deserialize Kismet Variable Int
  SeqVar&#95;Int &#61; SeqVar&#95;Int(SequenceObject);
  if (SeqVar&#95;Int !&#61; None)
  {
    SeqVar&#95;Int.IntValue &#61; Data.GetIntValue(&#34;Value&#34;);
    return;
  }

  // Deserialize Kismet Variable Object
  SeqVar&#95;Object &#61; SeqVar&#95;Object(SequenceObject);
  if (SeqVar&#95;Object !&#61; None)
  {
    SeqVar&#95;Object.SetObjectValue(FindObject(Data.GetStringValue(&#34;Value&#34;), class&#39;Object&#39;));
    return;
  }

  // Deserialize Kismet Variable String
  SeqVar&#95;String &#61; SeqVar&#95;String(SequenceObject);
  if (SeqVar&#95;String !&#61; None)
  {
    SeqVar&#95;String.StrValue &#61; Data.GetStringValue(&#34;Value&#34;);
    return;
  }

  // Deserialize Kismet Variable Vector
  SeqVar&#95;Vector &#61; SeqVar&#95;Vector(SequenceObject);
  if (SeqVar&#95;Vector !&#61; None)
  {
    SeqVar&#95;Vector.VectValue.X &#61; Data.GetFloatValue(&#34;Value&#95;X&#34;);
    SeqVar&#95;Vector.VectValue.Y &#61; Data.GetFloatValue(&#34;Value&#95;Y&#34;);
    SeqVar&#95;Vector.VectValue.Z &#61; Data.GetFloatValue(&#34;Value&#95;Z&#34;);
    return;
  }
}
</pre>
</div>
<p />
Deserializing Matinee is similar to deserializing Kismet. However, if the Matinee Sequence was playing at the time the saved game state was saved, then IsPlaying will be stored as 1 within the JSonObject. Thus, the ForceStartPosition is set and Matinee is asked to play. Otherwise Matinee will have its position set according to the Position value stored within the JSonObject.
<p />
<div class="codetitlebar">
SaveGameState.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Loads up the Matinee state based on the data
 &#42;
 &#42; &#64;param    ObjectName    Name of the Matinee Kismet object
 &#42; &#64;param    Data      Saved Matinee Kismet data
 &#42;/
function LoadMatineeState(string ObjectName, JSonObject Data)
{
  local SeqAct&#95;Interp SeqAct&#95;Interp;
  local float OldForceStartPosition;
  local bool OldbForceStartPos;

  // Find the matinee kismet object
  SeqAct&#95;Interp &#61; SeqAct&#95;Interp(FindObject(ObjectName, class&#39;Object&#39;));
  if (SeqAct&#95;Interp &#61;&#61; None)
  {
    return;
  }

  if (Data.GetIntValue(&#34;IsPlaying&#34;) &#61;&#61; 1)
  {
    OldForceStartPosition &#61; SeqAct&#95;Interp.ForceStartPosition;
    OldbForceStartPos &#61; SeqAct&#95;Interp.bForceStartPos;

    // Play the matinee at the forced position
    SeqAct&#95;Interp.ForceStartPosition &#61; Data.GetFloatValue(&#34;Position&#34;);
    SeqAct&#95;Interp.bForceStartPos &#61; true;
    SeqAct&#95;Interp.ForceActivateInput(0);

    // Reset the start position and start pos
    SeqAct&#95;Interp.ForceStartPosition &#61; OldForceStartPosition;
    SeqAct&#95;Interp.bForceStartPos &#61; OldbForceStartPos;
  }
  else
  {
    // Set the position of the matinee
    SeqAct&#95;Interp.SetPosition(Data.GetFloatValue(&#34;Position&#34;), true);
  }

  // Set the paused
  SeqAct&#95;Interp.bPaused &#61; (Data.GetIntValue(&#34;Paused&#34;) &#61;&#61; 1) ? true : false;
}
</pre>
</div>
<p />
<h2><a name="KActor example"></a> KActor example </h2>
<hr size="1" noshade="noshade">
This example shows how you would setup a KActor to serialize and deserialize itself using the Save Game State System. Remember that for any Actor class that you want the Save Game System to automatically pick up upon loading or saving, you need to implement the SaveGameStateInterface.
<p />
<div class="codetitlebar">
SaveGameStateKActor.uc
</div>
<div class="codesnippet">
<pre>
class SaveGameStateKActor extends KActor
  Implements(SaveGameStateInterface);
</pre>
</div>
<p />
<h3><a name="Serializing the KActor"></a> Serializing the KActor </h3>
Only the location and rotation values are saved here. The path name and object archetype are required data; otherwise the Save Game State System will not know what Actor or Object to apply the data to and or if the Actor or Object is required to be instanced the Save Game State System will not know what Actor or Object archetype to instance.
<p />
So the location is saved as three floats and the rotation is saved as three integers. You can of course save more variables as required. One reason why JSon was chosen, was that you can create parent - child structures using the JSonObject::SetObject() function. Thus you can also have child Actors or Objects serialize themselves within this step (ensure that these Actors or Objects have a way of keeping track if they have been serialized or not; as you do not want these Actors or Objects being serialized and deserialized more than once) and saved together with the parent data set. This naturally creates a very easy method to handle attached Actors or Objects, without having to tweak the base Save Game State System code base.
<p />
<div class="codetitlebar">
SaveGameStateKActor.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Serializes the actor&#39;s data into JSon
 &#42;
 &#42; &#64;return    JSon data representing the state of this actor
 &#42;/
function String Serialize()
{
  local JSonObject JSonObject;

  // Instance the JSonObject, abort if one could not be created
  JSonObject &#61; new () class&#39;JSonObject&#39;;
  if (JSonObject &#61;&#61; None)
  {
    `Warn(Self$&#34; could not be serialized for saving the game state.&#34;);
    return &#34;&#34;;
  }

  // Serialize the path name so that it can be looked up later
  JSonObject.SetStringValue(&#34;Name&#34;, PathName(Self));

  // Serialize the object archetype, in case this needs to be spawned
  JSonObject.SetStringValue(&#34;ObjectArchetype&#34;, PathName(ObjectArchetype));

  // Save the location
  JSonObject.SetFloatValue(&#34;Location&#95;X&#34;, Location.X);
  JSonObject.SetFloatValue(&#34;Location&#95;Y&#34;, Location.Y);
  JSonObject.SetFloatValue(&#34;Location&#95;Z&#34;, Location.Z);

  // Save the rotation
  JSonObject.SetIntValue(&#34;Rotation&#95;Pitch&#34;, Rotation.Pitch);
  JSonObject.SetIntValue(&#34;Rotation&#95;Yaw&#34;, Rotation.Yaw);
  JSonObject.SetIntValue(&#34;Rotation&#95;Roll&#34;, Rotation.Roll);

  // Send the encoded JSonObject
  return class&#39;JSonObject&#39;.static.EncodeJson(JSonObject);
}
</pre>
</div>
<p />
<h3><a name="Deserializing the KActor"></a> Deserializing the KActor </h3>
When the KActor is asked to deserialize itself, it is given the JSon data that it had serialized itself. Thus simply performing the opposite should restore the KActor to its state that it was when the game state was saved. As mentioned above, if you required child Actors or Objects to be serialized; then here would be the appropriate place to deserialize that data.
<p />
<div class="codetitlebar">
SaveGameStateKActor.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Deserializes the actor from the data given
 &#42;
 &#42; &#64;param    Data    JSon data representing the differential state of this actor
 &#42;/
function Deserialize(JSonObject Data)
{
  local Vector SavedLocation;
  local Rotator SavedRotation;

  // Deserialize the location and set it
  SavedLocation.X &#61; Data.GetFloatValue(&#34;Location&#95;X&#34;);
  SavedLocation.Y &#61; Data.GetFloatValue(&#34;Location&#95;Y&#34;);
  SavedLocation.Z &#61; Data.GetFloatValue(&#34;Location&#95;Z&#34;);

  // Deserialize the rotation and set it
  SavedRotation.Pitch &#61; Data.GetIntValue(&#34;Rotation&#95;Pitch&#34;);
  SavedRotation.Yaw &#61; Data.GetIntValue(&#34;Rotation&#95;Yaw&#34;);
  SavedRotation.Roll &#61; Data.GetIntValue(&#34;Rotation&#95;Roll&#34;);

  if (StaticMeshComponent !&#61; None)
  {
    StaticMeshComponent.SetRBPosition(SavedLocation);
    StaticMeshComponent.SetRBRotation(SavedRotation);
  }
}
</pre>
</div>
<p />
<h2><a name="Player controlled pawn example"></a> Player controlled pawn example </h2>
<hr size="1" noshade="noshade">
The player controlled pawn is an interesting example where none of the Actors involved are placed by the level designers; that is neither the PlayerController or the Pawn classes were placed in the map. However, Pawns may be placed by the level designer for different purposes such as place enemy monsters in the map for a single player game. Thus the method that was done here was to save an extra flag called IsPlayerControlled. Thus when the pawn is instanced and deserialized by the Save Game System, if IsPlayerControlled is set to 1 then the deserializing code will tell the GameInfo about that.
<p />
<div class="codetitlebar">
SaveGameStatePlayerController.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Serializes the actor&#39;s data into JSon
 &#42;
 &#42; &#64;return    JSon data representing the state of this actor
 &#42;/
function String Serialize()
{
  local JSonObject JSonObject;

  // Instance the JSonObject, abort if one could not be created
  JSonObject &#61; new () class&#39;JSonObject&#39;;
  if (JSonObject &#61;&#61; None)
  {
    `Warn(Self$&#34; could not be serialized for saving the game state.&#34;);
    return &#34;&#34;;
  }

  // Serialize the path name so that it can be looked up later
  JSonObject.SetStringValue(&#34;Name&#34;, PathName(Self));

  // Serialize the object archetype, in case this needs to be spawned
  JSonObject.SetStringValue(&#34;ObjectArchetype&#34;, PathName(ObjectArchetype));

  // Save the location
  JSonObject.SetFloatValue(&#34;Location&#95;X&#34;, Location.X);
  JSonObject.SetFloatValue(&#34;Location&#95;Y&#34;, Location.Y);
  JSonObject.SetFloatValue(&#34;Location&#95;Z&#34;, Location.Z);

  // Save the rotation
  JSonObject.SetIntValue(&#34;Rotation&#95;Pitch&#34;, Rotation.Pitch);
  JSonObject.SetIntValue(&#34;Rotation&#95;Yaw&#34;, Rotation.Yaw);
  JSonObject.SetIntValue(&#34;Rotation&#95;Roll&#34;, Rotation.Roll);

  // If the controller is the player controller, then saved a flag to say that it should be repossessed by the player when we reload the game state
  JSonObject.SetIntValue(&#34;IsPlayerControlled&#34;, (PlayerController(Controller) !&#61; None) ? 1 : 0);

  // Send the encoded JSonObject
  return class&#39;JSonObject&#39;.static.EncodeJson(JSonObject);
}

/&#42;&#42;
 &#42; Deserializes the actor from the data given
 &#42;
 &#42; &#64;param    Data    JSon data representing the differential state of this actor
 &#42;/
function Deserialize(JSonObject Data)
{
  local Vector SavedLocation;
  local Rotator SavedRotation;
  local SaveGameStateGameInfo SaveGameStateGameInfo;

  // Deserialize the location and set it
  SavedLocation.X &#61; Data.GetFloatValue(&#34;Location&#95;X&#34;);
  SavedLocation.Y &#61; Data.GetFloatValue(&#34;Location&#95;Y&#34;);
  SavedLocation.Z &#61; Data.GetFloatValue(&#34;Location&#95;Z&#34;);
  SetLocation(SavedLocation);

  // Deserialize the rotation and set it
  SavedRotation.Pitch &#61; Data.GetIntValue(&#34;Rotation&#95;Pitch&#34;);
  SavedRotation.Yaw &#61; Data.GetIntValue(&#34;Rotation&#95;Yaw&#34;);
  SavedRotation.Roll &#61; Data.GetIntValue(&#34;Rotation&#95;Roll&#34;);
  SetRotation(SavedRotation);

  // Deserialize if this was a player controlled pawn, if it was then tell the game info about it
  if (Data.GetIntValue(&#34;IsPlayerControlled&#34;) &#61;&#61; 1)
  {
    SaveGameStateGameInfo &#61; SaveGameStateGameInfo(WorldInfo.Game);
    if (SaveGameStateGameInfo !&#61; None)
    {
      SaveGameStateGameInfo.PendingPlayerPawn &#61; Self;
    }
  }
}
</pre>
</div>
<p />
When GameInfo::RestartPlayer() is called, it first checks if there is a pending player pawn waiting for the player controller. If there is, then the player controller is given that instead.
<p />
<div class="codetitlebar">
SaveGameStateGameInfo.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Restarts a controller
 &#42;
 &#42; &#64;param    NewPlayer    Player to restart
 &#42;/
function RestartPlayer(Controller NewPlayer)
{
  local LocalPlayer LP;
  local PlayerController PC;

  // Ensure that we have a controller
  if (NewPlayer &#61;&#61; None)
  {
    return;
  }

  // If we have a pending player pawn, then just possess that one
  if (PendingPlayerPawn !&#61; None)
  {
    // Assign the pending player pawn as the new player&#39;s pawn
    NewPlayer.Pawn &#61; PendingPlayerPawn;

    // Initialize and start it up
    if (PlayerController(NewPlayer) !&#61; None)
    {
      PlayerController(NewPlayer).TimeMargin &#61; -0.1;
    }

    NewPlayer.Pawn.LastStartTime &#61; WorldInfo.TimeSeconds;
    NewPlayer.Possess(NewPlayer.Pawn, false);
    NewPlayer.ClientSetRotation(NewPlayer.Pawn.Rotation, true);

    if (!WorldInfo.bNoDefaultInventoryForPlayer)
    {
      AddDefaultInventory(NewPlayer.Pawn);
    }

    SetPlayerDefaults(NewPlayer.Pawn);

    // Clear the pending pawn
    PendingPlayerPawn &#61; None;
  }
  else // Otherwise spawn a new pawn for the player to possess
  {
    Super.RestartPlayer(NewPlayer);
  }

  // To fix custom post processing chain when not running in editor or PIE.
  PC &#61; PlayerController(NewPlayer);
  if (PC !&#61; none)
  {
    LP &#61; LocalPlayer(PC.Player);

    if (LP !&#61; None)
    {
      LP.RemoveAllPostProcessingChains();
      LP.InsertPostProcessingChain(LP.Outer.GetWorldPostProcessChain(), INDEX&#95;NONE, true);

      if (PC.myHUD !&#61; None)
      {
        PC.myHUD.NotifyBindPostProcessEffects();
      }
    }
  }
}
</pre>
</div>
<p />
This would ensure that the player when loading a saved game state ends up in the same position as before, and not back at a PlayerStart.
<p />
<h2><a name="Game State Loaded Kismet Event"></a> Game State Loaded Kismet Event </h2>
<hr size="1" noshade="noshade">
Sometimes it may be necessary to perform some Kismet Actions to ensure that the game world is fully restored. This is done by making a custom Sequence Event.
<p />
<div class="codetitlebar">
SaveGameState_SeqEvent_SavedGameStateLoaded.uc
</div>
<div class="codesnippet">
<pre>
class SaveGameState&#95;SeqEvent&#95;SavedGameStateLoaded extends SequenceEvent;

defaultproperties
{
  ObjName&#61;&#34;Saved Game State Loaded&#34;
  MaxTriggerCount&#61;0
  VariableLinks.Empty
  OutputLinks(0)&#61;(LinkDesc&#61;&#34;Loaded&#34;)
  bPlayerOnly&#61;false
}
</pre>
</div>
<p />
The custom Sequence Event is then triggered when the save game state is loaded in GameInfo::StartMatch().
<p />
<div class="codetitlebar">
SaveGameStateGameInfo.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42;
 &#42; Start the match - inform all actors that the match is starting, and spawn player pawns
 &#42;/
function StartMatch()
{
  local SaveGameState SaveGameState;
  local PlayerController PlayerController;
  local int Idx;
  local array&#60;SequenceObject&#62; Events;
  local SaveGameState&#95;SeqEvent&#95;SavedGameStateLoaded SavedGameStateLoaded;

  // Check if we need to load the game or not
  if (PendingSaveGameFileName !&#61; &#34;&#34;)
  {
    // Instance the save game state
    SaveGameState &#61; new () class&#39;SaveGameState&#39;;
    if (SaveGameState &#61;&#61; None)
    {
      return;
    }

    // Attempt to deserialize the save game state object from disk
    if (class&#39;Engine&#39;.static.BasicLoadObject(SaveGameState, PendingSaveGameFileName, true, class&#39;SaveGameState&#39;.const.SAVEGAMESTATE&#95;REVISION))
    {
      // Load the game state
      SaveGameState.LoadGameState();
    }

    // Send a message to all player controllers that we&#39;ve loaded the save game state
    ForEach WorldInfo.AllControllers(class&#39;PlayerController&#39;, PlayerController)
    {
      PlayerController.ClientMessage(&#34;Loaded save game state from &#34;$PendingSaveGameFileName$&#34;.&#34;, &#39;System&#39;);

      // Activate saved game state loaded events
      if (WorldInfo.GetGameSequence() !&#61; None)
      {
        WorldInfo.GetGameSequence().FindSeqObjectsByClass(class&#39;SaveGameState&#95;SeqEvent&#95;SavedGameStateLoaded&#39;, true, Events);
        for (Idx &#61; 0; Idx &#60; Events.Length; Idx++)
        {
          SavedGameStateLoaded &#61; SaveGameState&#95;SeqEvent&#95;SavedGameStateLoaded(Events&#91;Idx]);
          if (SavedGameStateLoaded !&#61; None)
          {
            SavedGameStateLoaded.CheckActivate(PlayerController, PlayerController);
          }
        }
      }
    }
  }

  Super.StartMatch();
}
</pre>
</div>
<p />
<h2><a name="Questions"></a> Questions </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="How do a handle child Actors or Objects?"></a> How do a handle child Actors or Objects? </h3>
One reason why JSon was chosen, was that you can create parent - child structures using the JSonObject::SetObject() function. Thus you can also have child Actors or Objects serialize themselves within this step (ensure that these Actors or Objects have a way of keeping track if they have been serialized or not; as you do not want these Actors or Objects being serialized and deserialized more than once) and saved together with the parent data set. This naturally creates a very easy method to handle attached Actors or Objects, without having to tweak the base Save Game State System code base. When the Actor or Object is asked to be deserialized, then you can iterate through the inner JSonObjects and perform the same kind of deserialization.
<p />
<h3><a name="The saved game state is stored as plain text! How would I prevent players from cheating?"></a> The saved game state is stored as plain text! How would I prevent players from cheating? </h3>
Another reason why JSon was chosen, was that it would be very easy to debug the saved game state files by simply opening them up in Notepad or some other kind of text editing software. However, it is understandable that not storing it as binary may lead to some fears about cheating.
<p />
There are a few trains of thought on this. You could obfuscate the data by passing the encoded JSon through a text mangler function. However, even that would eventually get decoded by people who really want to hack your saved games. Even binary would not be immune to this.
<p />
Therefore, at the end of the day; there is very little you can do to prevent cheating; unless you can verify the source of the information and verify where the save data is being stored (online saves).
<p />
<h3><a name="Is it possible to store the JSon data online?"></a> Is it possible to store the JSon data online? </h3>
Yes. The nice thing about using JSon for this, is that it is a plain text interchangable data format that can be sent to a server via <a href="TcpLink.html" class="twikiLink">TCPLink</a>. Thus save games can be stored online some where and the client could retrieve them on a different machine... or even on a <strong><em>different</em></strong> device. Or you could even have a website which reads the JSon data and displays the player's progress to them. The possibilities are practically endless.
<p />
<h3><a name="How do I integrate this Development Kit Gem!?"></a> How do I integrate this Development Kit Gem!? </h3>
You can either subclass from SaveGameState classes (easiest) or you can shift the code within SaveGameState classes into your own game. Remember, you <strong>must</strong> be running the correct game type so that the correct PlayerController is being used by the game; otherwise none of the code will work because the incorrect classes are being used. To check which GameInfo and which PlayerController is currently being used, used the "showdebug" console command. This will print on screen in the top left corner which GameInfo and which PlayerController are currently being used.
<p />
<!--
After you've integrated the code into your own game type, you need to alter the console command which launches the map after a load save game state command has been issued.
<p />
<div class="codesnippet">
ConsoleCommand("start "$SaveGameState.MapFileName$"?<b><u>Game=SaveGameState.SaveGameStateGameInfo</u></b>?SaveGameState="$FileName);
</div>
<p />
You must change the GameInfo to use when reloading the map to your own one. Failure to do so, will incorrectly load the integrated game type!
-->
<p />
<h3><a name="I've integrated, but when I load a map nothing happens!"></a> I've integrated, but when I load a map nothing happens! </h3>
Remember that by default, the example code uses SaveGameStateGameInfo::StartMatch() and a delayed called to Super.StartMatch() [UTGame::StartMatch()] when the Save Game State has streaming levels. GameInfo::StartMatch() is automatically called when bDelayedStart is false and bWaitingToStartMatch is true by default. However, if this does not fit with your game; then remember to call SaveGameStateGameInfo::StartMatch(). You can also move the contents of the SaveGameStateGameInfo::StartMatch(), as the main reason why it is in there is because save game state requires the PlayerController to be instanced before the save game state is loaded.
<p />
<h2><a name="Related Topics"></a> Related Topics </h2>
<hr size="1" noshade="noshade"> <ul>
<li> <a href="UnrealOnMobile.html#BasicSaveObject" class="twikiAnchorLink">Unreal On Mobile - Basic Save Object()</a>
</li> <li> <a href="CloudDocumentStorage.html" class="twikiLink">Cloud Storage</a>
</li> <li> <a href="TcpLink.html" class="twikiLink">TCP Link</a>
</li></ul>
<p />
<h2><a name="Downloads"></a> Downloads </h2>
<hr size="1" noshade="noshade"> <ul>
<li> <a href="rsrc/Three/DevelopmentKitGemsSaveGameStates/SaveGameState-08-05-2012.zip" target="_top">Download</a> the script and example map.
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
