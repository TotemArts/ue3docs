<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | NavigationMeshReference    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">NavigationMeshReference  </b></div>
<div id="tooltext">
<a href="NavigationMeshReferenceJP.html" class="twikiLink">日本語訳</a><br><a href="NavigationMeshReferenceCH.html" class="twikiLink">中国翻译</a><br><a href="NavigationMeshReferenceKR.html" class="twikiLink">한국어</a><br>

<!-- Three/NavigationMeshReference -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AIAndNavigationHome.html" class="twikiLink">AI &amp; Navigation</a></b> &gt; Navigation Mesh Reference
</div>
<hr size="1" noshade="noshade">
<h1><a name="Navigation Mesh Reference"></a> Navigation Mesh Reference </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="NavigationMeshReference.html#Navigation Mesh Reference"> Navigation Mesh Reference</a> <ul>
<li> <a href="NavigationMeshReference.html#Overview"> Overview</a>
</li> <li> <a href="NavigationMeshReference.html#Obstacle Mesh"> Obstacle Mesh</a>
</li> <li> <a href="NavigationMeshReference.html#Generation Process"> Generation Process</a> <ul>
<li> <a href="NavigationMeshReference.html#1. Exploration"> 1. Exploration</a>
</li> <li> <a href="NavigationMeshReference.html#2. Mesh Simplification"> 2. Mesh Simplification</a> <ul>
<li> <a href="NavigationMeshReference.html#Square merge"> Square merge</a>
</li> <li> <a href="NavigationMeshReference.html#Concave Slab Merge"> Concave Slab Merge</a>
</li> <li> <a href="NavigationMeshReference.html#Slab decomposition"> Slab decomposition</a>
</li></ul>
</li> <li> <a href="NavigationMeshReference.html#3. Mesh Finalization"> 3. Mesh Finalization</a>
</li></ul>
</li> <li> <a href="NavigationMeshReference.html#Benefits of a Navigation Mesh over pathnodes:"> Benefits of a Navigation Mesh over pathnodes:</a> <ul>
<li> <a href="NavigationMeshReference.html#Reduction in node density"> Reduction in node density</a>
</li> <li> <a href="NavigationMeshReference.html#More optimal data structures"> More optimal data structures</a>
</li> <li> <a href="NavigationMeshReference.html#Obviation of _FindAnchor"> Obviation of FindAnchor</a>
</li> <li> <a href="NavigationMeshReference.html#Better pathing behavior"> Better pathing behavior</a>
</li> <li> <a href="NavigationMeshReference.html#No more raycasts"> No more raycasts</a>
</li> <li> <a href="NavigationMeshReference.html#Strictly better representation of the world"> Strictly better representation of the world</a>
</li> <li> <a href="NavigationMeshReference.html#Automatic generation"> Automatic generation</a>
</li> <li> <a href="NavigationMeshReference.html#Intrinsic flexibility for agents of varrying sizes"> Intrinsic flexibility for agents of varrying sizes</a>
</li> <li> <a href="NavigationMeshReference.html#Potential for &quot;real&quot; handling of dynamic objects"> Potential for "real" handling of dynamic objects</a>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
Rather than representing the world as a series of connected points, we instead attempt a more accurate representation of an AI's configuration space via a connected graph of convex polygons.  At each node (polygon) we know that an AI can get from any point in that node, to any other point in that node due to its convexity.  Thus the task of pathfinding through the graph simplifies into pathfinding along a connected graph of nodes, similar to how a path search would be performed on the waypoint-graph Unreal currently employs.  The difference between the two systems being that with the old method, once a path is generated you have no other data except the points along your path.
<p />
With a navigation mesh you have a path representing a series of polygons you need to walk through in order to reach your goal, but you also know exactly what the walk-able space looks like along the way.  Instead of having to hit each point exactly along a waypoint-graph generated path an AI now has all the information associated with the interface between nodes of the navigation mesh.  This allows for accurate and practically free cutting of corners, and in general much more natural looking movement.
<p />
Fig A depicts an example of this:
<p />
<img alt="FigA.gif" src="rsrc/Three/NavigationMeshReference/FigA.gif" /> (FIG A)
<p />
Note that even with a path of 10 nodes the waypoint graph's pathing behavior is inferior to that of the 4 node navigation mesh path.
<p />
<h2><a name="Obstacle Mesh"></a> Obstacle Mesh </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
In addition to the mesh itself, we also generate a mesh which represents obstacles in the world.  This ends up being 'walls' along the edges of the movement mesh.  The purpose of this mesh is to allow low-fidelity raycasts (against this obstacle mesh only) when an AI needs to know whether it can walk from one point to another directly.  This allows us to skip doing a path search in wide open areas even if there are many polygons between the start and the goal.  An octree is generated containing polys from both graphs which is used for quick lookups of starting polys (what polygon am I in currently) as well as goal poly lookups (what polygon is my goal in).
<p />
<p />
<h2><a name="Generation Process"></a> Generation Process </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
One of the biggest drawbacks most Navigation mesh implementations suffer from is that the creation of the mesh is left to artists, and can be quite labor intensive (even more so than placing pathnodes).  It is with this in mind that we decided to build a system for automatically generating a mesh without designer grunt work.
<p />
This process is completed in three stages.
<p />
<h3><a name="1. Exploration"></a> 1. Exploration </h3>
<p />
Starting with each position placed by a designer, the map is 'flood filled'.  That is, according to some step size, each segment of the map is examined via raycasts and once verified, added to the mesh.  At the end of this stage we end up with a high density mesh that resembles a grid.  We are working with squares here due to the AABB nature of Unreal's line-checks.
(Fig. C depicts the mesh after the first stage of mesh generation)
<p />
<img alt="FigC.jpg" src="rsrc/Three/NavigationMeshReference/FigC.jpg" />
<p />
One disadvantage of this approach is that objects which are slightly out of phase with the step size being used for exploration can end up being far away from the boundary of the mesh.  To alleviate this, during exploration when an obstacle is hit, the step size will be subdivided N times to achieve the desired level of accuracy.
<p />
(Fig. D depicts a section of the test map which benefits from subdivision)
<p />
<img alt="FigD.jpg" src="rsrc/Three/NavigationMeshReference/FigD.jpg" />
<p />
<h3><a name="2. Mesh Simplification"></a> 2. Mesh Simplification </h3>
<p />
The trickiest (and most time consuming step) is that of simplifying the mesh to something more reasonable to fit in memory and run pathfinding on.
Currently our simplification is primarily accomplished via a slab merge approach, and then convex decomposition of said slabs into a minimal amount of convex shapes.
The whole process takes form of the following steps:
<p /> <ol>
<li> Square merge to reduce number of polys and speed up the following steps
</li> <li> Merge all polys into concave slabs separated only by differences in slope
</li> <li> Decompose concave slabs into convex shapes
</li></ol>
<p />
<h4><a name="Square merge"></a> Square merge </h4>
<p />
Square merge simply picks a starting node, and expands it in all directions trying to find the most optimal (biggest area) configuration of that starting square.  This process is fast and reduces the number of nodes by a large factor, speeding up the rest of the process.
Here is a screenshot of the test map after square merge is completed:
<p />
<img alt="pathtest_squaremerge.jpg" src="rsrc/Three/NavigationMeshReference/pathtest_squaremerge.jpg" />
<p />
See UNavigationMeshBase::MergeSquares()
<p />
<h4><a name="Concave Slab Merge"></a> Concave Slab Merge </h4>
<p />
This step merges adjacent polys (whether the result is convex or not) as much as possible.  Polys that are too dissimiler in slope, or whose merge would pull the resulting shape too far off the original polys will not be merged.
<p />
Here is what the mesh looks like after this step has been performed:
<p />
<img alt="pathtest_nodecomp.jpg" src="rsrc/Three/NavigationMeshReference/pathtest_nodecomp.jpg" />
<p />
Note: this step incorporates edge simplification which smoothes out stair-step shapes caused by the grid nature of the original expansion process.  To illustrate, here is a shot of the mesh without this
edge simplification turned on:
<p />
<img alt="pathtest_nodecomp_noedgesimplification.jpg" src="rsrc/Three/NavigationMeshReference/pathtest_nodecomp_noedgesimplification.jpg" />
<p />
See UNavigationMeshBase::MergePolysConcave()
<p />
<h4><a name="Slab decomposition"></a> Slab decomposition </h4>
<p />
Once the mesh has been simplified into slabs of similar slope and height, we need to break them down into usable shapes.  This is done via a convex decomposition process, that uses an A* approach to find the optimal configuration of shapes to represent the concave slab.
See UNavigationMeshBase::DecomposePolyToConvexPrimitives()
<p />
<h3><a name="3. Mesh Finalization"></a> 3. Mesh Finalization </h3>
<p />
Now that the mesh has been simplified, the final step is building path-able edges between nodes, and generating the obstacle mesh.  Also during this step we cull unused vertices and massage the data for serialization.
<p />
(Fig. I depicts the mesh after all steps are complete, note the vertical surfaces which depict the obstacle mesh)
<p />
<img alt="pathtest_fullybuilt.jpg" src="rsrc/Three/NavigationMeshReference/pathtest_fullybuilt.jpg" />
<p />
<h2><a name="Benefits of a Navigation Mesh over pathnodes:"></a> Benefits of a Navigation Mesh over pathnodes: </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
<h3><a name="Reduction in node density"></a> Reduction in node density </h3>
<p />
Since with a mesh we can represent a large area with a single polygon, overall graph density goes down.  This is a win for many reasons: <ol>
<li> Memory footprint is reduced with the decrease in nodes being stored.
</li> <li> Pathfinding times go down as the density of the graph being searched shrinks.
</li> <li> Less nodes means less time fixing up cross-level pathing information
</li></ol>
<p />
(Fig B is an example of node density using our current codebase of this in MP_Gridlock)
<p />
<img alt="gridlock_simpler.jpg" src="rsrc/Three/NavigationMeshReference/gridlock_simpler.jpg" />
<p />
<h3><a name="More optimal data structures"></a> More optimal data structures </h3>
<p />
Currently path data is stored via UReachSpecs, and ANavigationPoints in the level.  This results in bloat of memory footprint both because of overhead from parent classes (AActor especially) and due to the distributed nature of the data.  With a mesh our data is stored in one big buffer which lends itself more easily to compression, and other optimizations.  No significant effort has been made to optimize our data, but already we are seeing 20% gains over pathnodes in MP_Gridlock.
<p />
<h3><a name="Obviation of _FindAnchor"></a> Obviation of FindAnchor </h3>
<p />
Currently whenever starting a pathsearch an AI first needs to determine which pathnode it should start pathing from.  This is accomplished via an octree check to return the pathnodes in range, and then doing raycasts from the AI to the pathnodes in order to find the closest, reachable path node.  The same must be done for the path destination if the destination is not on the graph already.  Some of this can (and is) mitigated via caching, etc.. but the fact remains that a non trivial amount of raycasts must be done by pathing AIs periodically at run time.  Using a navigation mesh the ambiguity which FindAnchor resolves does not exist.  We simply find the polygon the AI is currently inside, and that is our start location.  The same is true for our destination.
<p />
<h3><a name="Better pathing behavior"></a> Better pathing behavior </h3>
<p />
Demonstrated earlier (in Fig. A) there are several situations where movement from waypoint graphs can be un-natural looking.  The closest pathnode to the AI may be behind him, or in the opposite direction that he's going.  The same problem remains for the goal.
<p />
<h3><a name="No more raycasts"></a> No more raycasts </h3>
<p />
Using the data we generate into the navigation mesh, a significant portion of the raycasts AI do can be eliminated.  One example is when an AI first tries to move, an initial raycast is performed in order to determine if the AI can go directly to its destination and avoid pathfinding on the network.  This is no longer needed for two reasons.  First, in most cases if a point can be directly reached it will be in the same polygon as the AI, so it's a simple matter of finding the polygon for start and goal and detecing they are the same.  Second, we can fall back on the obstacle mesh to do a low-fi linecheck to determine direct reachability.  Both options are much cheaper than a raycast.  There are several other instances in the gears codebase where an AI asks if it can go directly to a point, all of which no longer need to do a raycast.
<p />
Another potential avenue for optimization is having AI move on the mesh itself (rather than running via PHYS_Walking).  The mesh is a fair representation of the configuration space the AI can walk on, so it would be fairly trivial to project onto the mesh and do a single raycast to correct the AI onto the visible geo rather than the N raycasts per frame PHYS_Walking does.  This would be especially useful for crowds.  Since they probably don't need all the fidelity a normal AI does, we could potentially handle many more crowd actors at a time by snapping them to the navigation mesh rather than doing collision checks against world geometry.  Indeed we should be able to increase the number of AI on screen in general.
<p />
<h3><a name="Strictly better representation of the world"></a> Strictly better representation of the world </h3>
<p />
A continuous representation of walkable space is beneficial to for many other types of space queries an AI might do.  Some examples:
<p /> <ul>
<li> The process of determining a position to remain in squad formation is vastly improved because one can actually check to see if the desired formation position is in the mesh and thus walk-able or not.  Prior methods relied on finding the closest path node to the formation position, which is expensive to find.  Furthermore the closest path node to the position isn't necessarily very near the formation position, and often looks bad.
</li> <li> AI are able to mantle over a wall at any point along the wall rather than having to go to a discrete pathnode which represents a 'mantle-able' location
</li> <li> Trivial adaptation of the mesh as an accurate influence map.  Propagating across a hand-authored waypoint-graph is only marginally accurate due to the incomplete covering of the worldspace, and is reliant on human-placed nodes whereas our mesh is precise, and complete.
</li></ul>
<p />
There are many other examples, but suffice it to say the increase in available data is beneficial to many ancillary AI behaviors.
<p />
<h3><a name="Automatic generation"></a> Automatic generation </h3>
<p />
Being that the generation process is automatic, the load on designers to create (and maintain) their levels with paths is alleviated.  The obvious benefit is that designers don't have to place the nodes in the first place, but also the likelyhood of paths being 'wrong' (as in someone changed the geometry without changing the path network) is reduced as the automatic generation process always does the 'right' thing.  For example there were several instances during gears production where a fully scripted level was handed off for a visual pass, which consequently broke large portions of the pathdata on the level.  The ability to build paths automatically allows an easy way out of this situation.
<p />
<h3><a name="Intrinsic flexibility for agents of varrying sizes"></a> Intrinsic flexibility for agents of varrying sizes </h3>
<p />
Another benefit of a more accurate representation of the world is that special considerations for entities of varrying widths are no longer necessary.  Rather than having to manually add a width class for every type of walking creature in use, we can make use of the extra data the mesh affords.  Edge widths between polys are already computed, and we can also fall back on 'extent' linechecks against the low-fi obstacle mesh to obtain accurate information about reachability for wide entities at runtime.
<p />
<h3><a name="Potential for &quot;real&quot; handling of dynamic objects"></a> Potential for "real" handling of dynamic objects </h3>
<p />
When restricted to a waypoint graph handling of dynamic objects which get in the way is difficult, and sometimes not possible.  For example if you throw a crate onto a reachspec the data says nothing about how to get around the obstacle.  Obviously you can do raycasts and try to add a dynamic anchor to side step the obstacle, but this a) requires raycasts, and b) doesn't work in many situations.  Using a navigation mesh, all that is neccesary to avoid an obstacle can be done within the mesh, without the need for raycasts.  You simply take the bounding box of the obstacle and split the polys its inside around the boundary.  You now have a fully pathable mesh that describes how to avoid that obstacle without the need for any line checks.  The newly split polygon would act as a sub-hierarchy for that polygon.  Rather than adjusting the overall mesh, we would build a mesh within the affected polygon such that when an AI enters it, he would then pathfind on the sub-mesh in order to navigate around the obstacle.  See Fig. J on the next page for an example of this;
<p />
<img alt="SplitExample.gif" src="rsrc/Three/NavigationMeshReference/SplitExample.gif" />
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
