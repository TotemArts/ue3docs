<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | PhysicalAnimation    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">PhysicalAnimation  </b></div>
<div id="tooltext">
<a href="PhysicalAnimationJP.html" class="twikiLink">日本語訳</a><br><a href="PhysicalAnimationCH.html" class="twikiLink">中国翻译</a><br><a href="PhysicalAnimationKR.html" class="twikiLink">한국어</a><br>

<!-- Three/PhysicalAnimation -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/Three/PhysicalAnimation/UDNCSS_test.css";</style>
<p />
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="PhysicsHome.html" class="twikiLink">Physics</a></b> &gt; Physical Animation <br/>
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AnimationHome.html" class="twikiLink">Animation</a></b> &gt; Physical Animation <br/>
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AnimatorHome.html" class="twikiLink">Animators</a></b> &gt; Physical Animation <br/>
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="SkeletalMeshHome.html" class="twikiLink">Skeletal Meshes</a></b> &gt; Physical Animation
</div>
<hr size="1" noshade="noshade">
<h1><a name="Physical Animation"></a> Physical Animation </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="PhysicalAnimation.html#Physical Animation"> Physical Animation</a> <ul>
<li> <a href="PhysicalAnimation.html#Overview"> Overview</a>
</li> <li> <a href="PhysicalAnimation.html#Pipeline"> Pipeline</a>
</li> <li> <a href="PhysicalAnimation.html#Workflow"> Workflow</a>
</li> <li> <a href="PhysicalAnimation.html#Controlling Physics"> Controlling Physics</a> <ul>
<li> <a href="PhysicalAnimation.html#Types of Physics"> Types of Physics</a>
</li> <li> <a href="PhysicalAnimation.html#Physics Objects"> Physics Objects</a>
</li></ul>
</li> <li> <a href="PhysicalAnimation.html#Partial physical simulation on skeletal meshes"> Partial physical simulation on skeletal meshes</a>
</li> <li> <a href="PhysicalAnimation.html#Full physical simulation on skeletal meshes"> Full physical simulation on skeletal meshes</a>
</li> <li> <a href="PhysicalAnimation.html#Unreal Editor"> Unreal Editor</a>
</li> <li> <a href="PhysicalAnimation.html#Useful console commands"> Useful console commands</a>
</li> <li> <a href="PhysicalAnimation.html#Examples"> Examples</a> <ul>
<li> <a href="PhysicalAnimation.html#Unrealscript"> Unrealscript</a>
</li> <li> <a href="PhysicalAnimation.html#Physically simulated hit reactions"> Physically simulated hit reactions</a> <ul>
<li> <a href="PhysicalAnimation.html#Arcade simulation"> Arcade simulation</a>
</li> <li> <a href="PhysicalAnimation.html#Realistic simulation"> Realistic simulation</a>
</li></ul>
</li> <li> <a href="PhysicalAnimation.html#Death animations that blend into a rag doll"> Death animations that blend into a rag doll</a>
</li></ul>
</li> <li> <a href="PhysicalAnimation.html#Licensee Seminar Presentations"> Licensee Seminar Presentations</a>
</li> <li> <a href="PhysicalAnimation.html#Downloads"> Downloads</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
There are often situations where physics simulations must be performed on attachments to achieve the desired animation. For example, chains on a prisoner that rattle around or rag dolls for an unconscious character that flops around. As the characters moves and blends between different animations, it's impossible to predetermine where things may be. Unreal Engine 3 solves this problem by allowing animators and programmers to define some or all bones in a skeletal mesh as physically simulated rigid body attachments.
<p />
A character that has chains attached to the arms that are driven by physics, with the rest of the body driven by blended animations and inverse kinematics.
<p />
<img src="rsrc/Three/PhysicalAnimation/SkeletalMeshWithPhysicsSimulatedChains.jpg" alt="SkeletalMeshWithPhysicsSimulatedChains.jpg" width='800' height='593' />
<p />
A character that is using physics to simulate the whole body.
<p />
<img src="rsrc/Three/PhysicalAnimation/SkeletalMeshRagdoll.jpg" alt="SkeletalMeshRagdoll.jpg" width='800' height='726' />
<p />
<h2><a name="Pipeline"></a> Pipeline </h2>
<hr size="1" noshade="noshade">
The physical animation system is part of the Unreal Engine 3 animation pipeline. First, the normal animation is processed when blending is handled via the Anim Tree. Secondly, inverse kinematic control is then applied via the Anim Tree. Lastly, the physics is applied to the skeleton via the Physics Asset. The physics sub system then processes the remaining physics, and the graphics sub system then renders the scene.
<p />
The physics for the skeleton is calculated based on whether the bone is fixed or not. Fixed bones are never simulated by physics and will be driven by the blended animation and inverse kinematic system. Unfixed bones will be simulated by physics.
<p />
<img src="rsrc/Three/PhysicalAnimation/PhysicalAnimation-Pipeline.JPG" width="640" height="164" />
<p />
<h2><a name="Workflow"></a> Workflow </h2>
<hr size="1" noshade="noshade">
A programmer and an animator will work together to produce the needed physical animation content. The animator will set up the physics asset which involves locking the bodies and simulating the system to see how it all ties together. The programmer will then be responsible for enabling or disabling physical animation depending on the game play.
<p />
<h2><a name="Controlling Physics"></a> Controlling Physics </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="Types of Physics"></a> Types of Physics </h3>
There are two types of physics: <ol>
<li> Kinematic ("fixed") <ul>
<li> Goes exactly where you say
</li> <li> Ignores collisions
</li> <li> Pushes objects it hits very hard
</li></ul>
</li> <li> Dynamic ("unfixed") <ul>
<li> Responds realistically to collisions
</li> <li> Need to use forces or constraints to control it
</li></ul>
</li></ol>
<p />
<h3><a name="Physics Objects"></a> Physics Objects </h3>
There are three physics objects: <ol>
<li> Forces <ul>
<li> Used to apply a constant force (such as gravity or wind)
</li></ul>
</li> <li> Impulse <ul>
<li> Used to apply a one off force (such as explosions or gun shots)
</li></ul>
</li> <li> Constraint <ul>
<li> Used to apply a continuous force (such as joints or springs)
</li></ul>
</li></ol>
<p />
<h2><a name="Partial physical simulation on skeletal meshes"></a> Partial physical simulation on skeletal meshes </h2>
<hr size="1" noshade="noshade">
A common effect in modern games is to have some parts perform physics simulation, while the rest of the character animates using blended animations and inverse kinematics. The easiest way to set this up is to make the character's skeletal mesh contain all bones, including those for the physically simulated parts. Shown below is the skeleton used for the chained character.
<p />
<img src="rsrc/Three/PhysicalAnimation/SkeletalMeshBones.jpg" alt="SkeletalMeshBones.jpg" width='800' height='615' />
<p />
This also means you should create a PhysicsAsset for the skeletal mesh using the PhAT tool, including the bones that you want to be physical simulated. You can preview how these physics parts will look in PhAT by 'fixing' all but those bodies (which can be easily done by right-clicking in the tree view and choosing <strong>Unfix All Bodies Below..</strong> or <strong>Fix All Bodies Below..</strong>. You can also set the fixed status of individual rigid bodies by clicking on the bone and checking or unchecking the <strong>Fixed</strong> property.
<p />
<img src="rsrc/Three/PhysicalAnimation/SetFixedBodies.jpg" alt="SetFixedBodies.jpg" width='800' height='615' />
<p />
During simulation in the tool, you can assign an AnimSet in the <strong>Preview Anim Set</strong> option, and pick an animation (such as a run cycle) from the drop down on the tool bar to loop. Press the play button to loop the animation, or the stop button to stop the animation. You can change the animation on the fly without having to stop the simulation. You can also check the <strong>Blend On Poke</strong> property, which will allow you to use the left mouse button to poke the skeletal mesh and have it blend between partial and full physical simulation.
<p />
<img src="rsrc/Three/PhysicalAnimation/PlayAnimationWithSimulatingUnfixedBodies.jpg" alt="PlayAnimationWithSimulatingUnfixedBodies.jpg" width='800' height='615' />
<p />
Make sure to assign the <strong>PhysicsAsset</strong> to your character in game, and set <strong>bHasPhysicsAssetInstance</strong> to true.
<p />
<img src="rsrc/Three/PhysicalAnimation/SetupSkeletalMeshActor.jpg" alt="SetupSkeletalMeshActor.jpg" width='800' height='582' />
<p />
Now when you run the game, and type <strong>nxvis collision</strong> in the console, you should see white shapes for the physics objects of your character. However they aren't physically simulating just yet.
<p />
<img src="rsrc/Three/PhysicalAnimation/ShowPhysicsCollision.jpg" alt="ShowPhysicsCollision.jpg" width='800' height='593' />
<p />
What needs to be considered is how the physics for these bones will be blended into the animations of your character. Normally you use the <strong>PhysicsWeight</strong> parameter on the skeletal mesh component to choose how much to blend between the output of the physics engine and the output of the animation system. In this case, you want to have these particular bones to always use the output of the physics engine, even when <strong>PhysicsWeight</strong> is zero. To do this, there is a parameter called <strong>bAlwaysFullAnimWeight</strong> on each rigid body within the physics asset. Set this to true for all these bones. You will also need to set <strong>bEnableFullAnimWeightBodies</strong> to true on the skeletal mesh component.
<p />
<img src="rsrc/Three/PhysicalAnimation/SettingAlwaysFullAnimWeight.jpg" alt="SettingAlwaysFullAnimWeight.jpg" width='800' height='615' />
<p />
When an actor's physics is PHYS_RigidBody, rigid bodies default to the fixed state that is defined in the physics asset. However, characters that are running around are normally are usually in PHYS_Walking or PHYS_Falling etc, all rigid bodies default to fixed; regardless of what is defined in the physics asset. In order to have the physics simulate on our these rigid bodies, it is required to explicitly 'unfix' them in code. There is a helpful function called <strong>SetFullAnimWeightBonesFixed</strong> within PhysicsAssetInstance. If you look at SkeletalMeshActor you can see an example of unfixing the flagged rigid bodies inside PostBeginPlay.
<p />
<div class="codetitlebar">
SkeletalMeshActor.uc
</div>
<div class="codesnippet">
<pre>
simulated event PostBeginPlay()
{
  // grab the current mesh for replication
  if (Role &#61;&#61; ROLE&#95;Authority &#38;&#38; SkeletalMeshComponent !&#61; None)
  {
    ReplicatedMesh &#61; SkeletalMeshComponent.SkeletalMesh;
  }

  // Unfix bodies flagged as &#39;full anim weight&#39;
  if (SkeletalMeshComponent !&#61; None &#38;&#38;
      //SkeletalMeshComponent.bEnableFullAnimWeightBodies &#38;&#38;
      SkeletalMeshComponent.PhysicsAssetInstance !&#61; None)
  {
    SkeletalMeshComponent.PhysicsAssetInstance.SetFullAnimWeightBonesFixed(FALSE, SkeletalMeshComponent);
  }

  if(bHidden)
  {
    SkeletalMeshComponent.SetClothFrozen(TRUE);
  }
}
</pre>
</div>
<p />
Once you have done all of these steps, you should see your parts moving physically in-game. If there are problems, it is good to use the <strong>nxvis collision</strong> option. If you are not seeing any white shapes, then there is something wrong with the physics asset, or the way it is assigned, or perhaps there is no PhysicsAssetInstance for some reason. If you see white shapes, but the rigid bodies are not being simulated, then there is something wrong with the unfixing of these rigid bodies. If you see the white rigid bodies moving correctly, but the bones are not, there is something wrong with them being blended into the final result.
<p />
Having partial physics simulation on skeletal meshes that are attached using Unreal attachment methods to other skeletal meshes can be tricky. This is mainly a problem when the base skeletal mesh component uses physics as well - for example if you wanted to attach a ponytail skeletal mesh to a character skeletal mesh, and the character then falls down using physics. This will usually result in a one-frame lag between the ponytail and the head, because Unreal code has to execute after the body has been simulated in order to update the fixed body location of the pony tail root to the attached location. One way to get around this is to instead create a physics joint between the pony tail and the head in code, rather than using Unreal attachment methods. This is a little complex though - an example can be seen in the UT hoverboard function SetHoverboardRiderPhysics, where the feet of a physics rider are jointed to the physics hoverboard. Or you can set <strong>bForceUpdateAttachmentsInTick</strong> to reupdate attachments; but this can be expensive.
<p />
A final thing you may want to adjust is collision. To have rigid bodies collide with the rest characters animated physics bodies, you will first need to set <strong>BlockRigidBody</strong> to true. Then you need to make sure that whatever RBChannel is set to is also set to true in the RBCollideWithChannels container. For a character, this is normally RBCC_Pawn. Currently it is not easy to have rigid bodies parts collide only with their owners limbs, and not with limbs of other characters. In this example, one of the chains that is attached to the characters arms is colliding with the crate below.
<p />
<img src="rsrc/Three/PhysicalAnimation/RigidBodyCollision.jpg" alt="RigidBodyCollision.jpg" width='800' height='593' />
<p />
<h2><a name="Full physical simulation on skeletal meshes"></a> Full physical simulation on skeletal meshes </h2>
<hr size="1" noshade="noshade"> <ul>
<li> <strong>bHasPhysicsAssetInstance</strong> must be true. This will ensure that the physics sub system instances the physics asset for this skeletal mesh. This is not necessary for per-bone line checks on the skeletal mesh.
</li> <li> The actor that owns the skeletal mesh does not require the physics mode be set to <strong>PHYS_RigidBody</strong>. This just ensures that the actor's location and rotation matches the root body's location and rotation.
</li> <li> Unfix the rigid body instances that you want to be dynamic by calling <strong>SetFixed(false)</strong> which is defined in RB_BodyInstance.
</li> <li> Ensure physics is blended in for those bodies <ul>
<li> Set <strong>PhysicsWeight</strong> to a value greater than zero in the skeletal mesh component.
</li> <li> Set <strong>bEnableFullAnimWeightBodies</strong> to true in the skeletal mesh component.
</li> <li> Set <strong>bAlwaysFullAnimWeight</strong> to true in RB_BodySetup.
</li></ul>
</li></ul>
<p />
<div class="codetitlebar">
<em>YourPawn.uc</em>
</div>
<div class="codesnippet">
<pre>
simulated function bool Died(Controller Killer, class&#60;DamageType&#62; DamageType, vector HitLocation)
{
  if (Super.Died(Killer, DamageType, HitLocation))
  {
    Mesh.MinDistFactorForKinematicUpdate &#61; 0.f;
    Mesh.SetRBChannel(RBCC&#95;Pawn);
    Mesh.SetRBCollidesWithChannel(RBCC&#95;Default, true);
    Mesh.SetRBCollidesWithChannel(RBCC&#95;Pawn, false);
    Mesh.SetRBCollidesWithChannel(RBCC&#95;Vehicle, false);
    Mesh.SetRBCollidesWithChannel(RBCC&#95;Untitled3, false);
    Mesh.SetRBCollidesWithChannel(RBCC&#95;BlockingVolume, true);
    Mesh.ForceSkelUpdate();
    Mesh.SetTickGroup(TG&#95;PostAsyncWork);
    CollisionComponent &#61; Mesh;
    CylinderComponent.SetActorCollision(false, false);
    Mesh.SetActorCollision(true, false);
    Mesh.SetTraceBlocking(true, true);
    SetPhysics(PHYS&#95;RigidBody);
    Mesh.PhysicsWeight &#61; 1.0;

    if (Mesh.bNotUpdatingKinematicDueToDistance)
    {
      Mesh.UpdateRBBonesFromSpaceBases(true, true);
    }

    Mesh.PhysicsAssetInstance.SetAllBodiesFixed(false);
    Mesh.bUpdateKinematicBonesFromAnimation &#61; false;
    Mesh.SetRBLinearVelocity(Velocity, false);
    Mesh.ScriptRigidBodyCollisionThreshold &#61; MaxFallSpeed;
    Mesh.SetNotifyRigidBodyCollision(true);
    Mesh.WakeRigidBody();

    return true;
  }

  return false;
}
</pre>
</div>
<p />
You can of course reverse the process to allow a rag dolled character to get back up again.
<p />
<h2><a name="Unreal Editor"></a> Unreal Editor </h2>
<hr size="1" noshade="noshade"> <ul>
<li> SkeletalMeshActor and its children are capable of using physics to simulate some bones on skeletal meshes.
</li> <li> KAsset and its children may be placed in the level to do full physics simulation on skeletal meshes.
</li></ul>
<p />
<h2><a name="Useful console commands"></a> Useful console commands </h2>
<hr size="1" noshade="noshade"> <ul>
<li> <strong>nxvis collision</strong> - shows the collision bodies used by the physics simulation. Use this over <strong>show collision</strong>, as <strong>show collision</strong> only shows the collision hulls used for the Unreal physics sub system.
</li></ul>
<p />
<img src="rsrc/Three/PhysicalAnimation/NxvisCollisionConsoleCommand.jpg" alt="NxvisCollisionConsoleCommand.jpg" width='800' height='593' />
<p />
<p /> <ul>
<li> <strong>show bones</strong> - shows the bone's location and rotation used to render the animated skeletal mesh.
</li></ul>
<p />
<img src="rsrc/Three/PhysicalAnimation/ShowBonesConsoleCommand.jpg" alt="ShowBonesConsoleCommand.jpg" width='800' height='593' />
<p />
<p /> <ul>
<li> <strong>show prephysbones</strong> - shows the bone's location and rotation after blended animation and inverse kinematics is applied but before physics is applied. Notice how the bones of the chains is pointing straight out, this is because there is no predefined animations made for them. But after physics is applied, the chains are in the correct position.
</li></ul>
<p />
<img src="rsrc/Three/PhysicalAnimation/ShowPrePhysicsBonesConsoleCommand.jpg" alt="ShowPrePhysicsBonesConsoleCommand.jpg" width='800' height='593' />
<p />
<h2><a name="Examples"></a> Examples </h2>
<hr size="1" noshade="noshade">
A general purpose Actor was created for all examples below. For each example the Unrealscript logic flow is listed.
<p />
<h3><a name="Unrealscript"></a> Unrealscript </h3>
<div class="codetitlebar">
HitReactionPawn.uc
</div>
<div class="codesnippet">
<pre>
class HitReactionPawn extends SkeletalMeshCinematicActor;

// Death animation
var(HitReaction) Name DeathAnimName;
// Bone names to unfix when hit reaction is simulated
var(HitReaction) array&#60;Name&#62; UnfixedBodyNames;
// Bone names to enable springs when hit reaction is simulated
var(HitReaction) array&#60;Name&#62; EnabledSpringBodyNames;
// Linear bone spring strength to use when hit reaction is simulated
var(HitReaction) float LinearBoneSpringStrength;
// Angular bone spring strength to use when hit reaction is simulated
var(HitReaction) float AngularBoneSpringStrength;
// Radius of the force to apply
var(HitReaction) float ForceRadius;
// Force amplification
var(HitReaction) float ForceAmplification;
// Maximum amount of force that can be applied
var(HitReaction) float MaximumForceThatCanBeApplied;
// Blend in time for the hit reaction
var(HitReaction) float PhysicsBlendInTime;
// Physics simulation time for the hit reaction
var(HitReaction) float PhysicsTime;
// Blend out time for the hit reaction
var(HitReaction) float PhysicsBlendOutTime;
// Full body rag doll
var(HitReaction) bool FullBodyRagdoll;

var Name PreviousAnimName;

event TakeDamage(int DamageAmount, Controller EventInstigator, vector HitLocation, vector Momentum, class&#60;DamageType&#62; DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
  local AnimNodeSequence AnimNodeSequence;

  Super.TakeDamage(DamageAmount, EventInstigator, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);

  if (SkeletalMeshComponent &#61;&#61; None &#124;&#124; SkeletalMeshComponent.PhysicsAssetInstance &#61;&#61; None)
  {
    return;
  }

  if (IsTimerActive(NameOf(SimulatingPhysicsBlendIn)) &#124;&#124; IsTimerActive(NameOf(SimulatingPhysics)) &#124;&#124; IsTimerActive(NameOf(SimulatedPhysicsBlendOut)))
  {
    return;
  }

  if (FullBodyRagdoll)
  {
    if (DeathAnimName !&#61; &#39;&#39;)
    {
      AnimNodeSequence &#61; AnimNodeSequence(SkeletalMeshComponent.Animations);

      if (AnimNodeSequence !&#61; None)
      {
        PreviousAnimName &#61; AnimNodeSequence.AnimSeqName;
        AnimNodeSequence.SetAnim(DeathAnimName);
        AnimNodeSequence.PlayAnim();
        AnimNodeSequence.bCauseActorAnimEnd &#61; true;
        return;
      }
    }
    else
    {
      TurnOnRagdoll(Normal(Momentum) &#42; FMin(DamageAmount &#42; ForceAmplification, MaximumForceThatCanBeApplied));
    }
  }
  else
  {
    if (DeathAnimName !&#61; &#39;&#39;)
    {
      AnimNodeSequence &#61; AnimNodeSequence(SkeletalMeshComponent.Animations);

      if (AnimNodeSequence !&#61; None)
      {
        PreviousAnimName &#61; AnimNodeSequence.AnimSeqName;
        AnimNodeSequence.SetAnim(DeathAnimName);
        AnimNodeSequence.PlayAnim();
        AnimNodeSequence.bCauseActorAnimEnd &#61; true;
        return;
      }
    }
    else
    {
      TurnOnRagdoll(Vect(0.f, 0.f, 0.f));
      // Apply the impulse
      SkeletalMeshComponent.AddRadialImpulse(HitLocation - (Normal(Momentum) &#42; 16.f), ForceRadius, FMin(DamageAmount &#42; ForceAmplification, MaximumForceThatCanBeApplied), RIF&#95;Linear, true);
      // Wake up the rigid body
      SkeletalMeshComponent.WakeRigidBody();
    }
  }

  BlendInPhysics();
}

event OnAnimEnd(AnimNodeSequence AnimNodeSequence, float PlayedTime, float ExcessTime)
{
  TurnOnRagdoll(Vect(0.f, 0.f, 0.f));
  BlendInPhysics();
  AnimNodeSequence.bCauseActorAnimEnd &#61; false;
}

function TurnOnRagdoll(Vector RBLinearVelocity)
{
  // Force update the skeleton
  SkeletalMeshComponent.ForceSkelUpdate();

  // Fix the bodies that don&#39;t need to play a part in the physical hit reaction
  if (UnfixedBodyNames.Length &#62; 0)
  {
    SkeletalMeshComponent.PhysicsAssetInstance.SetNamedBodiesFixed(false, UnfixedBodyNames, SkeletalMeshComponent,, true);
  }
  else
  {
    SkeletalMeshComponent.PhysicsAssetInstance.SetAllBodiesFixed(false);
  }

  // Enable springs on bodies that are required in the physical hit reaction
  if (EnabledSpringBodyNames.Length &#62; 0)
  {
    SkeletalMeshComponent.PhysicsAssetInstance.SetNamedRBBoneSprings(true, EnabledSpringBodyNames, LinearBoneSpringStrength, AngularBoneSpringStrength, SkeletalMeshComponent);
  }

  SkeletalMeshComponent.bUpdateKinematicBonesFromAnimation &#61; false;
  SkeletalMeshComponent.SetRBLinearVelocity(RBLinearVelocity, true);
  SkeletalMeshComponent.WakeRigidBody();
}

function BlendInPhysics()
{
  // Set the timer for the physics to blend in
  if (PhysicsBlendInTime &#62; 0.f)
  {
    SetTimer(PhysicsBlendInTime, false, NameOf(SimulatingPhysicsBlendIn));
  }
  else
  {
    SkeletalMeshComponent.PhysicsWeight &#61; 1.f;
    SimulatingPhysicsBlendIn();
  }
}


function SimulatingPhysicsBlendIn()
{
  if (PhysicsTime &#61;&#61; 0.f)
  {
    SimulatingPhysics();
  }
  else
  {
    // Set the timer for the physics to stay
    SetTimer(PhysicsTime, false, NameOf(SimulatingPhysics));
  }
}

function SimulatingPhysics()
{
  local AnimNodeSequence AnimNodeSequence;

  // Set the timer for the physics to blend out
  SetTimer(PhysicsBlendOutTime, false, NameOf(SimulatedPhysicsBlendOut));

  if (PreviousAnimName !&#61; &#39;&#39;)
  {
    AnimNodeSequence &#61; AnimNodeSequence(SkeletalMeshComponent.Animations);

    if (AnimNodeSequence !&#61; None)
    {
      AnimNodeSequence.SetAnim(PreviousAnimName);
      AnimNodeSequence.PlayAnim(true);
    }
  }
}

function SimulatedPhysicsBlendOut()
{
  // Set physics weight to zero
  SkeletalMeshComponent.PhysicsWeight &#61; 0.f;
  SkeletalMeshComponent.ForceSkelUpdate();

  if (FullBodyRagdoll)
  {
    SkeletalMeshComponent.PhysicsAssetInstance.SetAllBodiesFixed(true);
    SkeletalMeshComponent.bUpdateKinematicBonesFromAnimation &#61; true;
  }
  else
  {
    SkeletalMeshComponent.bUpdateKinematicBonesFromAnimation &#61; true;

    if (UnfixedBodyNames.Length &#62; 0)
    {
      SkeletalMeshComponent.PhysicsAssetInstance.SetNamedBodiesFixed(true, UnfixedBodyNames, SkeletalMeshComponent,, true);
    }
    else
    {
      SkeletalMeshComponent.PhysicsAssetInstance.SetAllBodiesFixed(true);
    }

    // Disable springs on bodies that were required in the physical hit reaction
    if (EnabledSpringBodyNames.Length &#62; 0)
    {
      SkeletalMeshComponent.PhysicsAssetInstance.SetNamedRBBoneSprings(false, EnabledSpringBodyNames, 0.f, 0.f, SkeletalMeshComponent);
    }
  }

  // Put the rigid body to sleep
  SkeletalMeshComponent.PutRigidBodyToSleep();
}

function Tick(float DeltaTime)
{
  Super.Tick(DeltaTime);

  if (IsTimerActive(NameOf(SimulatingPhysicsBlendIn)))
  {
    // Blending in physics
    SkeletalMeshComponent.PhysicsWeight &#61; GetTimerCount(NameOf(SimulatingPhysicsBlendIn)) / GetTimerRate(NameOf(SimulatingPhysicsBlendIn));
  }
  else if (IsTimerActive(NameOf(SimulatedPhysicsBlendOut)))
  {
    // Blending out physics
    SkeletalMeshComponent.PhysicsWeight &#61; 1.f - (GetTimerCount(NameOf(SimulatedPhysicsBlendOut)) / GetTimerRate(NameOf(SimulatedPhysicsBlendOut)));
  }
}

defaultproperties
{
  Begin Object Name&#61;SkeletalMeshComponent0
    bHasPhysicsAssetInstance&#61;true
    bUpdateJointsFromAnimation&#61;true
  End Object

  ForceRadius&#61;64.f
}
</pre>
</div>
<p />
<h3><a name="Physically simulated hit reactions"></a> Physically simulated hit reactions </h3>
To add extra realism in games, characters should react as realistically as possible to the forces applied to them. Whether this is from an object in the world banging into them, or when they receive hits from a gun. There are two possibilities that can happen when a character is hit by a gun; depending on realistic you want your game to be.
<p />
<h4><a name="Arcade simulation"></a> Arcade simulation </h4>
Arcade simulation only is used in games where movement and aim should not be impeded by the hit reaction. Thus players always retain full movement and aiming capabilities. This would be important in games such as Unreal Tournament 3 since the player should always be in control.
<p />
This simulation will only apply physical changes to the upper part of the body, enable stiff angular springs in the hands and head to keep the gun and head pointing in the right direction.
<p />
The properties of HitReactionPawn to achieve this are:
<p />
<img src="rsrc/Three/PhysicalAnimation/ArcadeHitReaction.jpg" alt="ArcadeHitReaction.jpg" width='539' height='782' />
<p />
Unrealscript logic flow: <ul>
<li> TakeDamage is called when the player shoots the HitReactionPawn
</li> <li> Check if there is a valid skeletal mesh component, physical asset instance and if the script is not currently in the middle of simulating physics
</li> <li> FullBodyRagdoll is false and DeathAnimName is empty, thus turn on physics, apply a radial impulse to simulate the weapon hit and wake up the rigid body <ul>
<li> Unfix bodies defined in <strong>UnfixedBodyNames</strong>. If that is empty, it will unfix all bodies.
</li> <li> Enable bone springs is defined in <strong>EnabledSpringBodyNames</strong>, and set the strengths of them using <strong>LinearBoneSpringStrength</strong> and <strong>AngularBoneSpringStrength</strong>.
</li> <li> Bones no longer need to be updated via the animation, <strong>bUpdateKinematicBonesFromAnimation</strong> is set false.
</li></ul>
</li> <li> Blend In timer is set.
</li> <li> When blend in timer is called, it will call the physics stay timer.
</li> <li> When physics stay timer is called, it will call the blend out timer.
</li> <li> After blending out, the process above is reversed.
</li> <li> If the blend in timer is running, or the blend out timer is running, tick blends between animation and physics by adjusting the <strong>PhysicsWeight</strong> by finding the percentage of time passed with the timers.
</li></ul>
<p />
The neck and right clavicle bones are less likely to be affected by the player's shots, but the rest of the upper body reacts according.
<p />
<img src="rsrc/Three/PhysicalAnimation/ArcadeHitReactionShot.jpg" alt="ArcadeHitReactionShot.jpg" width='800' height='593' />
<p />
<h4><a name="Realistic simulation"></a> Realistic simulation </h4>
In games where realism is the main factor, it may be useful to allow players to prevent enemies from aiming at them by firing at them or to stop enemies from charging and running away by shooting the enemies legs.
<p />
The properties of HitReactionPawn to achieve this are:
<p />
<img src="rsrc/Three/PhysicalAnimation/RealisticHitReaction.jpg" alt="RealisticHitReaction.jpg" width='539' height='782' />
<p />
The unrealscript logic flow is the same above however, bone springs and their strengths have been set. This helps keep those bones as close as possible to the animation without it being too stiff.
<p />
The whole body is affected by the player's shot. Additional logic could be added to cause the affected pawn to trip and fall if desired (Blend into another animation, blend out physics, after some times blend in physics again to simulate the fall).
<p />
<img src="rsrc/Three/PhysicalAnimation/RealismHitReactionShot.jpg" alt="RealismHitReactionShot.jpg" width='800' height='593' />
<p />
<h3><a name="Death animations that blend into a rag doll"></a> Death animations that blend into a rag doll </h3>
Rather than instantly rag dolling upon death, it may be desired for a short animation to play first. When the animation ends, the rag doll then blends in.
<p />
The properties of HitReactionPawn to achieve this are:
<p />
<img src="rsrc/Three/PhysicalAnimation/AnimatedRagdoll.jpg" alt="AnimatedRagdoll.jpg" width='539' height='782' />
<p />
Unrealscript logic flow: <ul>
<li> TakeDamage is called when the player shoots the HitReactionPawn
</li> <li> Check if there is a valid skeletal mesh component, physical asset instance and if the script is not currently in the middle of simulating physics
</li> <li> FullBodyRagdoll is false and DeathAnimName is not empty.
</li> <li> Play the death animation and ensure that the anim node sequence that is playing it will call OnAnimEnd when the animation finishes.
</li> <li> When OnAnimEnd is called, enable physics. For best results, do not set a blend in time otherwise the death sequence can be odd! <ul>
<li> Unfix bodies defined in <strong>UnfixedBodyNames</strong>. If that is empty, it will unfix all bodies.
</li> <li> Enable bone springs is defined in <strong>EnabledSpringBodyNames</strong>, and set the strengths of them using <strong>LinearBoneSpringStrength</strong> and <strong>AngularBoneSpringStrength</strong>.
</li> <li> Bones no longer need to be updated via the animation, <strong>bUpdateKinematicBonesFromAnimation</strong> is set false.
</li></ul>
</li> <li> Blend In timer is set.
</li> <li> When blend in timer is called, it will call the physics stay timer.
</li> <li> When physics stay timer is called, it will call the blend out timer.
</li> <li> After blending out, the process above is reversed.
</li> <li> If the blend in timer is running, or the blend out timer is running, tick blends between animation and physics by adjusting the <strong>PhysicsWeight</strong> by finding the percentage of time passed with the timers.
</li></ul>
<p />
This allows animators to create animated sequences which handle the initial fall, so that it feels like the body is reacting to the fall as well. In this case, there is a special animation played back when the body is continuously hit by the Stinger weapon in Unreal Tournament 3. Rag doll simulation begins at the end of the animation.
<p />
<img src="rsrc/Three/PhysicalAnimation/AnimatedRagdollShot.jpg" alt="AnimatedRagdollShot.jpg" width='800' height='593' />
<p />
<!--
Examples above now demonstrate the case studies in a more tutorial like fashion
!---++ Case Studies
<hr size="1" noshade="noshade">
<p />
!---+++ <em>Gears of War</em>
!---++++ Hit Reaction
To achieve the hit reaction effect, take the following steps:
<p /> <ul>
<li> On hit, <em>unfix</em> bodies above hips.
</li> <li> Enable constraint position drive <em>springs</em>.
</li> <li> Continue to try and match animation.
</li> <li> Also enable bone springs on hands and head.
</li> <li> Strong angular stiffness - keeps gun pointed in right direction.
</li> <li> <code>PhysicsWeight</code> blends from 1.0 to 0.0.
</li> <li> When entire animation is run again, re-fix upper bodies.
</li></ul>
<p />
!---++++ Death Animation
To achieve the death animation effect, take the following steps:
<p /> <ul>
<li> Upon death, switch all bodies to dynamic.
</li> <li> Pick an animation based on circumstance.
</li> <li> Enable position drive.
</li> <li> Enable bone spring on hips to keep character from falling over <ul>
<li> Break spring if extension is too long.
</li> <li> Set <code>bDisableOnOverextension</code> to <strong>TRUE</strong> and provide an <code>OverextensionThreshold</code> amount.
</li></ul>
</li> <li> Ramp down position drive strengths over time.
</li> <li> Useful functions in PhysicsAssetInstance: <ul>
<li> <code>SetNamedBodiesFixed</code>
</li> <li> <code>SetAllMotorsAngularDriveParams</code>
</li></ul>
</li></ul>
<p />
!---+++ <em>Unreal Tournament 3</em>
!---++++ Cloth: Flags
Cloth effects are now fully supported, and they work on all platforms.
<p />
Set up the Skeletal Mesh by indicating which bones are going to be used for cloth.
<p />
Useful variables and functions for Cloth effects: <ul>
<li> <code>bAutoFreezeClothWhenNotRendered</code> <ul>
<li> Stop all simulation and update when not seen.
</li></ul>
</li> <li> <code>ClothWind</code> parameter gives better <em>fluttering</em> effect <ul>
<li> Wind direction is calculated as the dot product of wind direction and surface normal.
</li></ul>
</li> <li> <code>ClothBaseVelClampRange</code> <ul>
<li> Clamp cloth vertex velocities to within a <em>box</em> of Base velocity.
</li> <li> Very useful for fast moving/turning characters.
</li> <li> Change based on setting (e.g. flag picked up).
</li></ul>
</li></ul>
-->
<p />
<!--  -->
<p />
<h2><a name="Downloads"></a> Downloads </h2>
<hr size="1" noshade="noshade">
<p /> <ul>
<li> <a href="rsrc/Three/PhysicalAnimation/PhysicalAnimationExample-31-12-2011.zip" target="_top">Download</a> the content used in this document. Please <a href="CustomUnrealScriptProjects.html" class="twikiLink">compile</a> the UDN package before loading PhysicalAnimationBMap.udk.
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
