<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | CharactersTechnicalGuide    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">CharactersTechnicalGuide  </b></div>
<div id="tooltext">
<a href="CharactersTechnicalGuideJP.html" class="twikiLink">日本語訳</a><br><a href="CharactersTechnicalGuideCH.html" class="twikiLink">中国翻译</a><br><a href="CharactersTechnicalGuideKR.html" class="twikiLink">한국어</a><br>

<!-- Three/CharactersTechnicalGuide -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="GameplayProgrammingHome.html" class="twikiLink">Gameplay Programming</a></b> &gt; Characters Technical Guide
</div>
<hr size="1" noshade="noshade">
<h1><a name="Characters Technical Guide"></a> Characters Technical Guide </h1>
<hr size="1" noshade="noshade">
<p />
<strong><em>Last tested against UDK June, 2011</em></strong>
<p />
<div class="twikiToc"> <ul>
<li> <a href="CharactersTechnicalGuide.html#Characters Technical Guide"> Characters Technical Guide</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#Overview"> Overview</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Controllers"> Controllers</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#Controller"> Controller</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#Pawns and Possession"> Pawns and Possession</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Inventory"> Inventory</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Movement and Navigation"> Movement and Navigation</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Camera / Aiming"> Camera / Aiming</a>
</li></ul>
</li> <li> <a href="CharactersTechnicalGuide.html#Player Controller"> Player Controller</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#General"> General</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Player Input / Movement"> Player Input / Movement</a>
</li></ul>
</li> <li> <a href="CharactersTechnicalGuide.html#AI Controller"> AI Controller</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#Decision Making"> Decision Making</a>
</li></ul>
</li></ul>
</li> <li> <a href="CharactersTechnicalGuide.html#Pawn"> Pawn</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#Controllers and Possession"> Controllers and Possession</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Inventory and Weapons"> Inventory and Weapons</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Taking Damage"> Taking Damage</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Animations"> Animations</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Camera Perspective / Aiming"> Camera Perspective / Aiming</a>
</li></ul>
</li> <li> <a href="CharactersTechnicalGuide.html#Example Player"> Example Player</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#Player Pawn Class"> Player Pawn Class</a>
</li> <li> <a href="CharactersTechnicalGuide.html#Player Controller Class"> Player Controller Class</a>
</li> <li> <a href="CharactersTechnicalGuide.html#GameInfo Class"> GameInfo Class</a>
</li></ul>
</li> <li> <a href="CharactersTechnicalGuide.html#Example NPC"> Example NPC</a> <ul>
<li> <a href="CharactersTechnicalGuide.html#NPC Pawn Class"> NPC Pawn Class</a>
</li> <li> <a href="CharactersTechnicalGuide.html#NPC Controller Class"> NPC Controller Class</a>
</li></ul>
</li> <li> <a href="CharactersTechnicalGuide.html#Testing out your new custom NPC"> Testing out your new custom NPC</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
Characters in Unreal are made up of two parts: a Pawn and a Controller. The Pawn is the physical representation of a player or non-playable character (NPC) in the world. It doesn’t know the difference between being controlled by a player and being controlled by AI. Pawns have a mesh, collision, and physics enabling them to handle all the functionality involved with the physical interaction between the character and the world. They also contain functionality for the taking of damage from other players or their surroundings, making sounds, playing animations, and any inventory functionality such as holding and/or firing weapons (although the weapon firing process is technically started from the controller class).
<p />
Each Pawn can have a single Controller at any one time. The Controller, as its name suggests, takes care of telling the Pawn what to do and how to behave. It is essentially the brains behind the Pawn. Controllers come in different flavors, such as PlayerControllers and AIControllers, but their main purpose is to accept input from the player or other stimuli in the world, make process that input, and act accordingly. This usually results in passing off some command or series of commands to the Pawn.
<p />
Under normal circumstances, the GameInfo class will handle creating the Controllers for all the players upon login and then when the match begins it creates a Pawn for each Controller and assigns it to that Controller. This last process is referred to as <em>possession</em>, as the Pawn is now possessed by and under the control of the Controller. The full player creation process is diagramed below.
<p />
<img alt="CreationProcess.jpg" src="rsrc/Three/CharactersTechnicalGuide/CreationProcess.jpg" />
<p />
Of course, this does not have to be the case. Your game may consist of a world populated by NPCs that are hand-placed in the world and not created dynamically. These NPCs would most likely be a subclass of the base Pawn class which would handle the creation of their own Controllers and assign themselves to that Controller.
<p />
<h2><a name="Controllers"></a> Controllers </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
A Controller is a non-physical Actor which is attached to a Pawn in order to control its actions. It uses information received from the player or from its surroundings and uses that information to cause the Pawn to behave accordingly. The Controller is in charge of movement, whether it be in reaction to the player input or traversing paths generated by the navigation system and performing actions based on various events. When the Pawn moves in the game, it does so because the Controller told it to. Controllers receive many notifications of events occurring for the Pawn they control &ndash; things like seeing or hearing an enemy. The Controller uses these events to implement the appropriate behavior for the Pawn in response to the corresponding event.
<p />
The two main subclasses of Controllers are <code><b>PlayerController</b></code> and <code><b>AIController</b></code>. When creating your new character, you will extend from one of these classes, or one of their subclasses, depending on what type of character you are creating.
<p />
Controllers, especially AIControllers, also make heavy use of States which allows the Controller to override functions within the same class and have them perform different actions depending on the current state of the Controller. States also provide the ability to use latent code and latent functions, such as the movement functions that AI characters use to navigate the world.
<p />
<h3><a name="Controller"></a> Controller </h3>
<p />
The base Controller class contains generic functions and events that pertain to the controlling of a Pawn in general and not necessarily specific to whether it is a player-controlled Pawn or an AI-controlled Pawn.
<p />
<h4><a name="Pawns and Possession"></a> Pawns and Possession </h4>
<p />
These functions have to do with the possessing and unpossessing of Pawns.
<p /> <ul>
<li> <strong>Possess [inPawn] [bVehicleTransition]</strong> - This assigns the specified Pawn as this Controller’s Pawn and notifies the Pawn by calling its PossessedBy() function.
</li> <li> <strong>UnPossess</strong> - This clears this Controller’s Pawn reference and notifies the Pawn it is no longer controlled by this Controller by calling its UnPossessedBy() function.
</li></ul>
<p />
<h4><a name="Inventory"></a> Inventory </h4>
<p />
These functions have to do with pickups, weapons, and other inventory-specific functionality.
<p /> <ul>
<li> <strong>RatePickup [PickupHolder] [PickupClass]</strong> - This is a callback from the PickupFactory which calculates the desirability of the pickup.
</li> <li> <strong>HandlePickup [InvetoryItem]</strong> - This function is an empty placeholder to be overridden allowing you to implement additional functionality for handling items that are picked up.
</li> <li> <strong>FireWeaponAt [inActor]</strong> - This function causes the Controller’s Pawn to fire the currently active weapon at the specified actor.
</li> <li> <strong>StopFiring</strong> - This forces the Controller’s Pawn to stop firing the currently active weapon.
</li> <li> <strong>SwitchToBestWeapon [bForceNewWeapon]</strong> - This calculates which of the weapons in the inventory of this Controller’s Pawn is the best and makes it the active weapon. The options bool parameter can force a different weapon than the currently active one to be chosen whether the active weapon is the best or not.
</li> <li> <strong>ClientSetWeapon [WeaponClass]</strong> - This forces this Controller’s Pawn to switch to the specified weapon, assuming a weapon of that type exists in the Pawn’s inventory.
</li></ul>
<p />
See the <a href="WeaponsTechnicalGuide.html" class="twikiLink">Weapons Technical Guide</a> for more information about Weapons.
<p />
<h4><a name="Movement and Navigation"></a> Movement and Navigation </h4>
<p />
These functions have to do with latently moving the possessed Pawn around the world; meaning a command is given to go to a particular destination and the movement is automatic without needing to be updated every tick.
<p /> <ul>
<li> <strong>MoveTo [NewDestination] [ViewFocus] [DestinationOffset] [bShouldWalk]</strong> - This causes the Pawn to move to the specified destination, or within the optional specified offset thereof, while keeping its focus on the given optional actor. This function will use the path network to help the Pawn navigate to the destination.
</li> <li> <strong>MoveToDirectNonPathPos [NewDestination] [ViewFocus] [DestinationOffset] [bShouldWalk]</strong> - This is identical in functionality to MoveTo() except that it should only be used when moving to the final goal and not following a path.
</li> <li> <strong>MoveToward [NewTarget] [ViewFocus] [DestinationOffset] [bUseStrafing] [bShouldWalk]</strong> - This causes the Pawn to move to the given actor, specified as the NewTarget. This function will take advantage of the navigation network when moving to another Pawn or an inventory actor.
</li> <li> <strong>FindPathTo [aPoint] [MaxPathLength] [bReturnPartial]</strong> - This calculates a path to the navigation node closest to the given destination and returns the next node along that path.
</li> <li> <strong>FindPathToward [anActor] [bWeightDetours] [MaxPathLength] [bReturnPartial]</strong> - This calculates a path to the navigation node closest to the given actor and returns the next node along that path.
</li> <li> <strong>FindPathTowardNearest [GoalClass] [bWeightDetours] [MaxPathLength] [bReturnpartial]</strong> - This calculates a path to the nearest node of the specified class and returns the next node along that path.
</li> <li> <strong>FindPathToIntercept [Pawn] [InRouteGoal] [bWeightDetours] [MaxPathLength] [bReturnpartial]</strong> - This calculates a path to intercept the given pawn as it moves through the world and returns the next node along that path.
</li> <li> <strong>PointReachable [aPoint]</strong> - This returns whether the specified location is directly reachable given the Pawn’s movement capabilities. This function can be expensive and should be avoided in favor of ActorReachable() if possible.
</li> <li> <strong>ActorReachable [anActor]</strong> - This returns whether the specified Actor is directly reachable given the Pawn’s movement capabilities. Though potentially more optimized than PointReachable(), this function also can be expensive and should be used sparingly.
</li> <li> <strong>FindRandomDest</strong> - This returns a random node on the navigation network. This can be good for creating a state where the character roams the world.
</li></ul>
<p />
See the <a href="AIOverview.html" class="twikiLink">AI Overview</a> for more information on Artificial Intelligence and Navigation.
<p />
<h4><a name="Camera / Aiming"></a> Camera / Aiming </h4>
<p />
The functions in this section have to do with the viewpoint and aiming of the Controller and its Pawn.
<p /> <ul>
<li> <strong>GetPlayerViewPoint [out_Location] [out_Rotation]</strong> - This returns the point of view of the Controller’s Pawn. For human players, this is the camera’s viewpoint. For AI-controlled players, this is the viewpoint from the Pawn’s eyes. In this base implementation, it is simply the location and rotation of the Controller itself.
</li> <li> <strong>GetActorEyesViewPoint [out_Location] [out_Rotation]</strong> - This returns the point of view of the Controller or its Pawn if one exists. Essentially, this returns where the player is looking from and in which direction.
</li> <li> <strong>IsAimingAt [Target] [Epsilon]</strong> - This returns whether the Controller is currently aiming at the specified target, within a given amount of wiggle room. An Epsilon of 1.0 means aiming directly at the target, while lower values allow for some error.
</li></ul>
<p />
<h3><a name="Player Controller"></a> Player Controller </h3>
<p />
The PlayerController, and its subclasses, implements functionality for receiving input from the human player and processing that input into the action you see in the game. For the most part, this means the PlayerController handles actions like moving the Pawn, controlling the camera (by way of the Pawn), and switching or firing weapons based on the buttons or keys the player has pressed. Below are some of the main functions from the PlayerController classes with descriptions of each.
<p />
<h4><a name="General"></a> General </h4>
<p />
These functions are general in nature and belong to no specific category.
<p /> <ul>
<li> <strong>Playertick [DeltaTime]</strong> - This is the main update function for players. It is executed every cycle.
</li> <li> <strong>ConsoleCommand [Command]</strong> - This executes the given command as though it were a console command entered by the player.
</li></ul>
<p />
<h4><a name="Player Input / Movement"></a> Player Input / Movement </h4>
<p />
These functions pertain to the input and movement of the player.
<p /> <ul>
<li> <strong>InitInputSystem</strong> - This function initializes the input system by creating a new instance of the PlayerInput class of the PlayerController.
</li> <li> <strong>PlayerMove [DeltaTime]</strong> - This calculates the new acceleration and rotation values for the current move and then calls either ProcessMove() (for single-player or listen servers) or ReplicateMove() (for network clients). This is simply a stub in the base PlayerController class but is overridden within certain states which involve movement, such as the PlayerWalking state. This function is called from the PlayerTick() function every cycle.
</li> <li> <strong>ProcessMove [DeltaTime] [newAccel] [DoubleClickMove] [DeltaRot]</strong> - This handles the current move on the client. This function is overridden inside certain states which require special functionality for movement.
</li> <li> <strong>ReplicateMove [DeltaTime] [newAccel] [DoubleClickMove] [DeltaRot]</strong> - This function starts off the movement process. It saves the current move in the PendingMove list, then calls ProcessMove() and ServerMove() (executed on the server).
</li> <li> <strong>ServerMove [TimeStamp] [inAccel] [ClientLoc] [MoveFlags] [ClientRoll] [View]</strong> - This is executed only on the server and performs the current move by calling MoveAutonomous(). It also determines if an update Is necessary based on whether enough time has passed since the last update or if there is enough error between the client and server positions.
</li> <li> <strong>Move Autonomous [DeltaTime] [MoveFlags] [newAccel] [DeltaRot]</strong> - This calls ProcessMove() and updates any autonomous physics calculations that need to be performed.
</li> <li> <strong>ClientUpdatePosition</strong> - This updates the player’s position on the client to match that of the server. This is called from the PlayerTick() function, but only after the ServerMove() function has determined it necessary.
</li> <li> <strong>UpdateRotation [DeltaTime]</strong> - This updates the rotation of the Controller and that of the Controller’s Pawn based on the player’s input
</li> <li> <strong>ProcessViewRotation [DeltaTime] [out_ViewRotation] [DeltaRot]</strong> - This processes the player’s view rotation based on the player’s input and outputs the resulting rotation. This is called from UpdateRotation().
</li></ul>
<p />
<h3><a name="AI Controller"></a> AI Controller </h3>
<p />
The AIController, and its subclasses, implements functionality for observing the Pawn’s environment and making intelligent decisions based on that information. It essentially uses its own self-contained decision loop to continually cycle through the decision-making process and carry out the appropriate actions based on those decisions. The main functions from the AIController classes are explained below.
<p />
<h4><a name="Decision Making"></a> Decision Making </h4>
<p />
When dealing with AI-controlled entities, the decision-making process is clearly very important. Without something processing information and deciding what to do or how to behave based on that information, your NPC characters are really nothing more than statues. Obviously, discussions of how to create good AI are well beyond the scope of this document, but you still need to know how and where to add your AI code into the AIController class structure. The functions below are the main workhorses in the decision-making process.
<p />
Note: These functions are implemented in the UDKBot class and not in the base AIController class. You would need to extend from UDKBot or UTBot in order to make use of these.
<p /> <ul>
<li> <strong>ExecuteWhatToDoNext</strong> - This is the main entry point for the decision-making process and should contain the majority of the decision logic. This function gets executed during the physics tick, however; so it should not contain anything that could change the physics state.
</li> <li> <strong>WhatToDoNext</strong> - This causes ExecuteWhatToDoNext() to be called during the next tick and can also contain any code which is unsafe to perform during the physics tick. This would not be called from within state code in favor of using LatentWhatToDonext().
</li> <li> <strong>LatentWhatToDoNext</strong> - This encapsulates calling WhatToDoNext() and waiting for the tick-delayed decision-making process to occur. This is called from state code so that the state is paused while waiting for the next decision-making loop.
</li></ul>
<p />
<p />
<h2><a name="Pawn"></a> Pawn </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
The Pawn class is the base class for all players, characters, creatures, and other types of entities within Unreal. As was mentioned previously, it is responsible for the physical interaction between the player or AI and the world. When creating a custom Pawn class, you will first want to know what functionality exists already so that you can make appropriate decisions about how to override the existing functionality in order to implement the behavior you desire your new character to have as well as budgeting the necessary time that will be needed in cases where completely new functionality might need to be added. To aid in this, the important functions from the Pawn class are explained below broken up into categories of functionality.
<p />
<h3><a name="Controllers and Possession"></a> Controllers and Possession </h3>
<p />
These functions contain functionality related to the Pawn’s interaction with Controllers and being possessed and unpossessed.
<p /> <ul>
<li> <strong>PossessedBy [controller] [bVehicleTransition]</strong> - This sets the Controller passed in as the Pawn’s new Controller and performs any other necessary actions or initialization. This is called by the Controller when it takes possession of the Pawn.
</li> <li> <strong>Unpossessed</strong> - This clears the Pawn’s Controller and resets any other relevant properties. This is called from the Controller when the Pawn dies, the round ends, or when the Controller no longer wishes to be in possession of the Pawn, i.e. if the Controller wishes to take possession of a different Pawn.
</li> <li> <strong>SpawnDefaultController</strong> - This spawns an instance of the ControllerClass for the Pawn, if the Pawn does not currently have a controller, and causes the Controller to possess the Pawn. This is called in the Pawn’s PostBeginPlay() function to ensure that Pawns placed in the level or Pawns spawned during gameplay get possessed by a Controller.
</li> <li> <strong>DetatchFromController [bDestroyController]</strong> - This causes the Controller to no longer possess the Pawn and optionally to destroy the Controller after the possession is broken. This is called when the Pawn dies, is reset, is being destroyed, or is being assigned another Controller.
</li></ul>
<p />
<h3><a name="Inventory and Weapons"></a> Inventory and Weapons </h3>
<p />
Most of the inventory functionality is handled by the InventoryManager of the Pawn which is spawned in the PostBeginPlay() event. The Pawn does, however, handle some of the functionality and relays commands to the InventoryManager through the use of several inventory-specific functions as well.  The Pawn class also contains several functions pertaining to weapons and the firing of those weapons. These functions are listed below.
<p /> <ul>
<li> <strong>AddDefaultInventory</strong> - This adds the inventory items listed in the default inventory to the Pawn’s inventory. This function Is called from the AddDefaultInventory() function of the GameInfo class.
</li> <li> <strong>CreateInventory [inventoryClass] [bDoNotActivate]</strong> - This creates an instance of the specified inventory class, adds it to the Pawn’s inventory, and returns the new inventory item. This function simply passes the call onto the InventoryManager to handle the actual work.
</li> <li> <strong>FindInventoryType [inventoryClass] [bAllowSubclass]</strong> - This searches the Pawn’s inventory for an instance of the specified class and returns that instance if one is found.
</li> <li> <strong>TossInventory [invenetoryItem] [forceVelocity]</strong> - This causes the Pawn to throw away the specified inventory item with an optional velocity, removing it from the Pawn’s inventory.
</li> <li> <strong>ThrowActiveWeapon</strong> - This causes the Pawn to throw the currently active weapon onto the ground, removing it from the Pawn’s inventory. This simply passes the command to the TossInventory() function to handle the work.
</li> <li> <strong>SetActiveWeapon [newWeapon]</strong> - This sets the specified weapon as the Pawn’s active weapon. This simply passes the command on to the InventoryManager to handle the work.
</li> <li> <strong>PlayWeaponSwitch [oldWeapon] [newWeapon]</strong> - This is used to cause the Pawn to play the necessary animations for switching its weapon from the old weapon to the new weapon. This is called from the InventoryManager’s ChangeWeapon() function.
</li> <li> <strong>StartFire [fireModeNum]</strong> - This causes the Pawn to start firing the active weapon using the specified firemode. This passes the command to the Inventorymanager.
</li> <li> <strong>StopFire [fireModeNum]</strong> - This causes the Pawn to stop firing the active weapon and firemode. This passes the command on to the InventoryManager.
</li> <li> <strong>WeaponFired [weapon] [bViaReplication] [hitLocation]</strong> - This is used to delegate the creation of all effects related to firing the active weapon. This calls the active weapon’s PlayFireEffects() function.
</li> <li> <strong>WeaponStoppedFiring [weapon] [bViaReplication]</strong> - This is used to delegate the destruction of all the effects related to firing the active weapon. This calls the active weapon’s StopFireEffects() function.
</li></ul>
<p />
<h3><a name="Taking Damage"></a> Taking Damage </h3>
<p />
The Pawn class contains functionality for healing as well as taking damage from weapons and other circumstances. Functions relating to damage and health are listed below.
<p /> <ul>
<li> <strong>TakeDamage [damage] [instigatedBy] [hitLocation] [momentum] [damageType] [hitInfo] [damageCauser]</strong> - This decreases the health of the Pawn by the specified amount. <ul>
<li> <strong>Damage</strong> - The amount by which to decrease the health.
</li> <li> <strong>InstigatedBy</strong> - The Controller of the Pawn who is responsible for the damage being taken.
</li> <li> <strong>HitLocation</strong> - The position from which the damage is to be applied.
</li> <li> <strong>Momentum</strong> - A velocity to be applied to the Pawn as a result of the damage.
</li> <li> <strong>DamageType</strong> - The damage type class describing the type of damage being done.
</li> <li> <strong>HitInfo</strong> - An optional TraceHitInfo struct of information about the damage.
</li> <li> <strong>DamageCauser</strong> - An optional Actor responsible for the damage being done.
</li></ul>
</li> <li> <strong>HealDamage [amount] [healer] [damageType]</strong> - This increases the Pawn’s health by the specified amount, limiting the resulting health amount to the Pawn’s maximum health and only if the Pawn is not dead or already at full health.
</li> <li> <strong>TakeFallingDamage</strong> - This applies damage to the Pawn based on the velocity at which it is falling. This passes the appropriate damage amount on to the TakeDamage() function.
</li> <li> <strong>CrushedBy [otherPawn]</strong> - This causes the Pawn to take damage when another Pawn becomes based on it. The amount of damage is based on the velocity of the Pawn that became based on this Pawn. This is called from the Pawn’s BaseChange() function and passes the damage amount to the TakeDamage() function.
</li> <li> <strong>TakeRadiusDamageOnBones [instigatedBy] [baseDamage] [damageRadius] [damageType] [momentum] [hurtOrigin] [bFullDamage] [damageCauser] [bones]</strong> - This function applies a radius-dependent attenuated damage to a list of specific bones on the Pawn’s skeletal mesh.
</li> <li> <strong>NotifyTakeHit [instigatedBy] [hitLocation] [damage] [damageType] [momentum]</strong> - This function sends out notifications to anything that needs to be notified that the Pawn has taken damage. This calls the Controller’s NotifyTakeHit() function.
</li> <li> <strong>TakeDrowningDamage</strong> - This applies damage based on whether the Pawn is in water and has been underwater for too long.
</li></ul>
<p />
<h3><a name="Animations"></a> Animations </h3>
<p />
Pawns use a skeletal mesh as their main visual component. While a great deal of the playing of animations for actions such as movement is handled by the AnimTree assigned to the Pawn, they do have some limited functionality for playing animations built in. Much of this comes in the form of helper functions which pass commands on to the skeletal mesh component of the Pawn. These functions are described below.
<p />
Note: The SkeletalMeshComponent of the Pawn, referenced by the Mesh variable, contains animation-related functionality for playing individual animation sequences. Keep in mind that using this requires that the one and only animation node in the Pawn’s AnimTree is an AnimNodeSequence node. This means you would be losing all the advanced functionality of the AnimTree system, such as blending; but the functionality is present, if needed.
<p /> <ul>
<li> <strong>SetMorphWeight [MorphNodeName] [MorphWieght]</strong> - Sets the weight of a particular morph node within the AnimTree assigned to the Pawn.
</li> <li> <strong>SetSkelControlScale [SkelControlName] [Scale]</strong> - Sets the scale of a particular SkelControl node within the AnimTree assigned to the Pawn.
</li> <li> <strong>PlayActorFaceFXAnim [AnimSet] [GroupName] [SeqName] [SoundCueToPlay]</strong> - This causes the Pawn to play the specified FaceFX facial animation sequence.
</li> <li> <strong>StopActorFaceFXAnim</strong> - This stops the currently playing FaceFX facial animation sequence.
</li> <li> <strong>IsActorPlayingFaceFXAnim</strong> - This returns a Boolean value saying whether the Pawn is currently playing a FaceFX facial animation.
</li></ul>
<p />
<h3><a name="Camera Perspective / Aiming"></a> Camera Perspective / Aiming </h3>
<p />
These functions contain functionality for controlling the position and orientation of the player’s camera when the Pawn is the current view target as well as setting the current aim for the player or NPC.
<p /> <ul>
<li> <strong>CalcCamera [DeltaTime] [out_CamLoc] [out_CamRot] [out_FOV]</strong> - This calculates the camera’s viewpoint when viewing from the Pawn. This is the main camera calculation for the player.
</li> <li> <strong>GetDefaultCameraMode [controller]</strong> - This returns the default camera mode, as a name, that should be used for this Pawn. This is usually called by the controller when possessing the Pawn.
</li> <li> <strong>ProcessViewRotation [deltaTime]  [out_ViewRotation] [out_DeltaRot]</strong> - This processes the player’s view rotation and returns the final view rotation as the out_ViewRotation parameter. This is called from the UpdateRotation() function of the PlayerController.
</li> <li> <strong>SetViewRotation [NewRotation]</strong> - Sets the rotation of the Controller, if one exists, or of the Pawn itself if no Controller exists.
</li> <li> <strong>GetActorEyesViewPoint [out_Location] [out_Rotation]</strong> - This returns the location and orientation of the Pawn’s eyes, or the point of view of the player. For a first person perspective this is identical to the camera location and orientation. It is also the view point most traces will be performed from.
</li> <li> <strong>GetBaseAimRotation</strong> - This returns the aiming rotation, as a Rotator, of the Pawn without any adjustments, such as aim error, autolock, adhesion, etc.
</li> <li> <strong>GetAdjustedAimFor [Weapon] [StartFireLoc]</strong> - This allows an intermediate point to apply any adjustments to the base aim rotation, like aim error, auto-aiming, etc. By default, this passes the command to the GetAdjustedaimFor() function of the Controller. If no Controller exists for the Pawn, it returns the base aim rotation.
</li></ul>
<p />
<p />
<h2><a name="Example Player"></a> Example Player </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
To demonstrate adding a new player-controlled character using a custom mesh, three new classes will be used: a Pawn, a PlayerController, and a GameInfo. The goal of this example is to show the basics of creating a new character to be controlled by the player. Once you have the basic implementation, it is simply a matter of using what is available or adding your own custom functionality to implement a new character that suits your game.
<p />
<img alt="Player.jpg" src="rsrc/Three/CharactersTechnicalGuide/Player.jpg" />
<p />
<h3><a name="Player Pawn Class"></a> Player Pawn Class </h3>
<p />
For this example, the new Pawn class has a little added functionality. We have decided to give it a built-in health regeneration feature. Inside the Tick() function, a specified amount of health is added to the Pawn’s current Health every so often. To accomplish this, a few class variables were added and then the Tick function was overridden and the regeneration was added.
<p />
<div class="codetitlebar">
UDNPawn.uc
</div>
<div class="codesnippet">
<pre>
class UDNPawn extends UTPawn;

var float ElapsedRegenTime;
var float RegenAmount;
var float RegenTime;

event Tick(float DeltaTime)
{
  //calculate elapsed time
  ElapsedRegenTime +&#61; DeltaTime;

  //has enough time elapsed?
  if(ElapsedRegenTime &#62;&#61; RegenTime)
  {
    //heal the Pawn and reset elapsed time
    HealDamage(RegenAmount, Controller, class&#39;DamageType&#39;);
    ElapsedRegenTime &#61; 0.0f;
  }
}

defaultproperties
{
  //set defaults for regeneration properties
  RegenAmount&#61;2
  RegenTime&#61;1
}
</pre>
</div>
<p />
<h3><a name="Player Controller Class"></a> Player Controller Class </h3>
<p />
The new PlayerController class is a very basic extension of the UTPlayerController class. It simply adds a new class variable to hold the class of the character to use as the player and then sets that as the player’s character using the existing ServerSetCharacterClass() function.
<p />
<div class="codetitlebar">
UDNPlayerController.uc
</div>
<div class="codesnippet">
<pre>
class UDNPlayerController extends UTPlayerController;

var class&#60;UTFamilyInfo&#62; CharacterClass;

simulated event PostBeginPlay()
{
  super.PostBeginPlay();

  SetupPlayerCharacter();
}

/&#42;&#42; Set player&#39;s character info class &#38; perform any other initialization &#42;/
function SetupPlayerCharacter()
{
  //Set character to our custom character
  ServerSetCharacterClass(CharacterClass);
}

defaultproperties
{
  //Points to the UTFamilyInfo class for your custom character
  CharacterClass&#61;class&#39;UTFamilyInfo&#95;Liandri&#95;Male&#39;
}
</pre>
</div>
<p />
<h3><a name="GameInfo Class"></a> GameInfo Class </h3>
<p />
A new gametype is needed in this case in order to specify that the new Pawn and PlayerController classes should be used. You will most likely be using a custom gametype anyway in the creation of your game using UDK so you would just add the appropriate default properties to that class instead of creating a new one. For this example, the new gametype is created and simply sets the DefaultPawnClass and PlayerControllerClass properties to point to the new Pawn and PlayerController classes.
<p />
<div class="codetitlebar">
UDNGame.uc
</div>
<div class="codesnippet">
<pre>
class UDNGame extends UTDeathMatch;

defaultproperties
{
  //Points to your custom Pawn class
  DefaultPawnClass&#61;class&#39;UDNPawn&#39;

  //Points to your custom PlayerController class
  PlayerControllerClass&#61;class&#39;UDNPlayerController&#39;
}
</pre>
</div>
<p />
Now, if we run a map using this new game type, the player should regenerate when damaged and be using the custom character.
<p />
<p />
<h2><a name="Example NPC"></a> Example NPC </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
To demonstrate a simple AI-controlled Pawn, a new Pawn and Controller class will be created. The Pawn class will be placeable within Unreal Editor and will handle Setting up the mesh, animation, physics properties as well as setting a class of controller to use. The Controller will be responsible for causing the NPC to roam around the world, choosing random destinations each time it reaches the current one.
<p />
<img alt="NPC.jpg" src="rsrc/Three/CharactersTechnicalGuide/NPC.jpg" />
<p />
<h3><a name="NPC Pawn Class"></a> NPC Pawn Class </h3>
<p />
The Pawn class is fairly simple. It has a couple of added properties, but these are really just duplicates of existing properties meant to make it easy to use for the designer. A SkeletalMeshComponent is used to set up all the visual properties, such as the mesh, AnimTree, AnimSets, PhysicsAsset, etc. Some default values for this are set in the default properties block. A class is used to set the class of Controller to use to control the NPC. The PostBeginPlay() function is used to set the existing ControllerClass variable to the new NPCController variable. Finally, the SetCharacterClassFromInfo() function is overridden to do nothing as it will not be needed for this NPC implementation.
<p />
The full source for the class is shown here:
<p />
<div class="codetitlebar">
UDNPawn_NPC.uc
</div>
<div class="codesnippet">
<pre>
class UDNPawn&#95;NPC extends UTPawn
  placeable;

var(NPC) SkeletalMeshComponent NPCMesh;
var(NPC) class&#60;AIController&#62; NPCController;

simulated event PostBeginPlay()
{
  if(NPCController !&#61; none)
  {
    //set the existing ControllerClass to our new NPCController class
    ControllerClass &#61; NPCController;
  }

  Super.PostBeginPlay();
}

//override to do nothing
simulated function SetCharacterClassFromInfo(class&#60;UTFamilyInfo&#62; Info)
{
}

defaultproperties
{
  //Setup default NPC mesh
  Begin Object Class&#61;SkeletalMeshComponent Name&#61;NPCMesh0
    SkeletalMesh&#61;SkeletalMesh&#39;CH&#95;LIAM&#95;Cathode.Mesh.SK&#95;CH&#95;LIAM&#95;Cathode&#39;
    PhysicsAsset&#61;PhysicsAsset&#39;CH&#95;AnimCorrupt.Mesh.SK&#95;CH&#95;Corrupt&#95;Male&#95;Physics&#39;
    AnimSets(0)&#61;AnimSet&#39;CH&#95;AnimHuman.Anims.K&#95;AnimHuman&#95;BaseMale&#39;
    AnimtreeTemplate&#61;AnimTree&#39;CH&#95;AnimHuman&#95;Tree.AT&#95;CH&#95;Human&#39;
  End Object
  NPCMesh&#61;NPCMesh0
  Mesh&#61;NPCMesh0
  Components.Add(NPCMesh0)

  //Points to your custom AIController class - as the default value
  NPCController&#61;class&#39;UDNBot&#39;
}
</pre>
</div>
<p />
<h3><a name="NPC Controller Class"></a> NPC Controller Class </h3>
<p />
The Controller class is about the most basic navigation implementation possible. The ExecuteWhatToDoNext() function, which is the main decision-making function, is overridden to send the Controller continuously into the Roaming state. This state simply checks to see if a destination exists or if the Pawn has reached the current one, sets a new destination if necessary, and then tells the Controller to move toward the destination. Finally, the LatentWhatToDoNext() function is called to cause the ExecuteWhatToDoNext() function to be called again next tick, restarting the decision loop all over again.
<p />
The source for the controller class is shown here:
<p />
<div class="codetitlebar">
UDNBot.uc
</div>
<div class="codesnippet">
<pre>
class UDNBot extends UTBot;

var Actor Destination;

protected event ExecuteWhatToDoNext()
{
  //Go to the roaming state
  GotoState(&#39;Roaming&#39;);
}

state Roaming
{
Begin:
  //If we just began or we have reached the Destination
  //pick a new destination - at random
  if(Destination &#61;&#61; none &#124;&#124; Pawn.ReachedDestination(Destination))
  {
    Destination &#61; FindRandomDest();
  }

  //Find a path to the destination and move to the next node in the path
  MoveToward(FindPathToward(Destination), FindPathToward(Destination));

  //fire off next decision loop
  LatentWhatToDoNext();
}

defaultproperties
{
}
</pre>
</div>
<p />
<h2><a name="Testing out your new custom NPC"></a> Testing out your new custom NPC </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
Your new NPC class can be found within Actor Classes. It may be easier to use the search widget.
<p />
<img src="rsrc/Three/CharactersTechnicalGuide/UDNCTG_ActorClasses.jpg" alt="UDNCTG_ActorClasses.jpg" width='481' height='691' />
<p />
Once the actor is selected in the Actor Classes tab within the Content Browser, you can now right click within the game view port to bring up the context menu. Within the context menu, select the menu item <strong>Add UDN_PawnNPC Here</strong>.
<p />
<img src="rsrc/Three/CharactersTechnicalGuide/UDNCTG_AddActor.jpg" alt="UDNCTG_AddActor.jpg" width='541' height='914' />
<p />
The NPC is now within the world. Now you can use PIE to test the game.
<p />
<img src="rsrc/Three/CharactersTechnicalGuide/UDNCTG_PlacedNPC.jpg" alt="UDNCTG_PlacedNPC.jpg" width='745' height='903' />
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
