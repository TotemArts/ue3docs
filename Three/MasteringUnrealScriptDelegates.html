<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | MasteringUnrealScriptDelegates    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">MasteringUnrealScriptDelegates  </b></div>
<div id="tooltext">
<a href="MasteringUnrealScriptDelegatesJP.html" class="twikiLink">日本語訳</a><br><a href="MasteringUnrealScriptDelegatesCH.html" class="twikiLink">中国翻译</a><br><a href="MasteringUnrealScriptDelegatesKR.html" class="twikiLink">한국어</a><br>

<!-- Three/MasteringUnrealScriptDelegates -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div class="twikiToc"> <ul>
<li> <a href="MasteringUnrealScriptDelegates.html#CHAPTER 12 - DELEGATES">CHAPTER 12 - DELEGATES</a> <ul>
<li> <a href="MasteringUnrealScriptDelegates.html#12.1 - OVERVIEW">12.1 - OVERVIEW</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#12.2 - DECLARING A DELEGATE">12.2 - DECLARING A DELEGATE</a> <ul>
<li> <a href="MasteringUnrealScriptDelegates.html#DELEGATE PARAMETERS">DELEGATE PARAMETERS</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#DEFAULT BEHAVIOR">DEFAULT BEHAVIOR</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#12.3 - DELEGATES AS VARIABLES">12.3 - DELEGATES AS VARIABLES</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#12.4 - PASSING A DELEGATE TO A FUNCTION">12.4 - PASSING A DELEGATE TO A FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#12.5 - DELEGATES AND MEMORY">12.5 - DELEGATES AND MEMORY</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#12.6 - UISCENE AND UIOBJECT DELEGATES">12.6 - UISCENE AND UIOBJECT DELEGATES</a> <ul>
<li> <a href="MasteringUnrealScriptDelegates.html#UISCENE DELEGATES">UISCENE DELEGATES</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UIOBJECT DELEGATES">UIOBJECT DELEGATES</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#12.7 – OTHER DELEGATES IN UNREAL ENGINE 3 AND UNREAL TOURNAMENT 3">12.7 – OTHER DELEGATES IN UNREAL ENGINE 3 AND UNREAL TOURNAMENT 3</a> <ul>
<li> <a href="MasteringUnrealScriptDelegates.html#AUDIOCOMPONENT">AUDIOCOMPONENT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#GAMEINFO">GAMEINFO</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#GAMEVIEWPORTCLIENT">GAMEVIEWPORTCLIENT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#INTERACTION">INTERACTION</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINEACCOUNTINTERFACE">ONLINEACCOUNTINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINECONTENTINTERFACE">ONLINECONTENTINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINEGAMEINTERFACE">ONLINEGAMEINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINENEWSINTERFACE">ONLINENEWSINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINEPLAYERINTERFACE">ONLINEPLAYERINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINEPLAYERINTERFACEEX">ONLINEPLAYERINTERFACEEX</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINESTATSINTERFACE">ONLINESTATSINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINESTATSREAD">ONLINESTATSREAD</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINESTATSWRITE">ONLINESTATSWRITE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINESYSTEMINTERFACE">ONLINESYSTEMINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINEVOICEINTERFACE">ONLINEVOICEINTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#PARTICLESYSTEMCOMPONENT">PARTICLESYSTEMCOMPONENT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#PLAYERCONTROLLER">PLAYERCONTROLLER</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UICOMBOBOX">UICOMBOBOX</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UICOMP_DRAWCOMPONENTS">UICOMP_DRAWCOMPONENTS</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UIDATAPROVIDER">UIDATAPROVIDER</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UIDATASTORE">UIDATASTORE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UIDATASTORE_GAMESTATE">UIDATASTORE_GAMESTATE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UIEDITBOX">UIEDITBOX</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UIEVENT">UIEVENT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UIOPTIONLISTBASE">UIOPTIONLISTBASE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UISCREENOBJECT">UISCREENOBJECT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UISCROLLBAR">UISCROLLBAR</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UISCROLLBARMARKERBUTTON">UISCROLLBARMARKERBUTTON</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UITABBUTTON">UITABBUTTON</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UITABCONTROL">UITABCONTROL</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UITOOLTIP">UITOOLTIP</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINEGAMEINTERFACEIMPL">ONLINEGAMEINTERFACEIMPL</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINEGAMEINTERFACEGAMESPY">ONLINEGAMEINTERFACEGAMESPY</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINESUBSYSTEMGAMESPY">ONLINESUBSYSTEMGAMESPY</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#ONLINESUBSYSTEMLIVE">ONLINESUBSYSTEMLIVE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTBOT">UTBOT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTDATASTORE_ONLINESTATS">UTDATASTORE_ONLINESTATS</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTDEPLOYEDACTOR">UTDEPLOYEDACTOR</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTDRAWMAPPANEL">UTDRAWMAPPANEL</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTEXPLOSIONLIGHT">UTEXPLOSIONLIGHT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTKACTOR">UTKACTOR</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTMISSIONGRI">UTMISSIONGRI</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTSCOREBOARDPANEL">UTSCOREBOARDPANEL</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTSIMPLEIMAGELIST">UTSIMPLEIMAGELIST</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTSIMPLELIST">UTSIMPLELIST</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTSKELCONTROL_CANTILEVERBEAM">UTSKELCONTROL_CANTILEVERBEAM</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTSKELCONTROL_TURRETCONSTRAINED">UTSKELCONTROL_TURRETCONSTRAINED</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTSLOWVOLUME">UTSLOWVOLUME</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTTABPAGE.UC">UTTABPAGE.UC</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIFRONTEND_BINDKEYS360">UTUIFRONTEND_BINDKEYS360</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIFRONTEND_BINDKEYSPC">UTUIFRONTEND_BINDKEYSPC</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIFRONTEND_BINDKEYSPS3">UTUIFRONTEND_BINDKEYSPS3</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIFRONTEND_BOTSELECTION">UTUIFRONTEND_BOTSELECTION</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIFRONTEND_SETTINGSPANELS">UTUIFRONTEND_SETTINGSPANELS</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIMENULIST">UTUIMENULIST</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIOPTIONLIST">UTUIOPTIONLIST</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIPANEL_MAPCYCLE">UTUIPANEL_MAPCYCLE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIPANEL_SINGLEMAP">UTUIPANEL_SINGLEMAP</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUIPRESSBUTTON">UTUIPRESSBUTTON</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUISCENE">UTUISCENE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUISCENE_MESSAGEBOX">UTUISCENE_MESSAGEBOX</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUISCENE_SAVEPROFILE">UTUISCENE_SAVEPROFILE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_CHARACTERPART">UTUITABPAGE_CHARACTERPART</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_FINDQUICKMATCH">UTUITABPAGE_FINDQUICKMATCH</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_GAMEMODESELECTION">UTUITABPAGE_GAMEMODESELECTION</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_MAPSELECTION">UTUITABPAGE_MAPSELECTION</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_MUTATORS">UTUITABPAGE_MUTATORS</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_OPTIONS">UTUITABPAGE_OPTIONS</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_SERVERBROWSER">UTUITABPAGE_SERVERBROWSER</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#UTUITABPAGE_SERVERFILTER">UTUITABPAGE_SERVERFILTER</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.1 - RANDOM EVENT MUTATOR, PART I: INTRODUCTION  INITIAL CLASS SETUP">TUTORIAL 12.1 - RANDOM EVENT MUTATOR, PART I: INTRODUCTION &amp; INITIAL CLASS SETUP</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.2 - RANDOM EVENT MUTATOR, PART II: TIMING LOGIC">TUTORIAL 12.2 - RANDOM EVENT MUTATOR, PART II: TIMING LOGIC</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTROIAL 12.3 - RANDOM EVENT MUTATOR, PART III: USING DELEGATES">TUTROIAL 12.3 - RANDOM EVENT MUTATOR, PART III: USING DELEGATES</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.4 - RANDOM EVENT MUTATOR, PART IV: GIVEBONUSARMOR()">TUTORIAL 12.4 - RANDOM EVENT MUTATOR, PART IV: GIVEBONUSARMOR()</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.5 - RANDOM EVENT MUTATOR, PART V: GIVEREDEEMERTOALL">TUTORIAL 12.5 - RANDOM EVENT MUTATOR, PART V: GIVEREDEEMERTOALL</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.6 - RANDOM EVENT MUTATOR, PART VI: FORCERESPAWN">TUTORIAL 12.6 - RANDOM EVENT MUTATOR, PART VI: FORCERESPAWN</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.7 - RANDOM EVENT MUTATOR, TESTING">TUTORIAL 12.7 - RANDOM EVENT MUTATOR, TESTING</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.8 - WEAPON MUTATOR, PART I: INTRODUCTION  INITAL CLASS SETUP">TUTORIAL 12.8 - WEAPON MUTATOR, PART I: INTRODUCTION &amp; INITAL CLASS SETUP</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.9 - WEAPON MUTATOR, PART II: SETTING UP UTWEAP_MULTIENFORCER">TUTORIAL 12.9 - WEAPON MUTATOR, PART II: SETTING UP UTWEAP_MULTIENFORCER</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.10 – WEAPON MUTATOR, PART III: MULTIENFORCER_BASE">TUTORIAL 12.10 – WEAPON MUTATOR, PART III: MULTIENFORCER_BASE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.11 – WEAPON MUTATOR, PART IV: MULTIENFORCER_BIO">TUTORIAL 12.11 – WEAPON MUTATOR, PART IV: MULTIENFORCER_BIO</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.12 - WEAPON MUTATOR, PART V: MULTIENFORCER_FLAK">TUTORIAL 12.12 - WEAPON MUTATOR, PART V: MULTIENFORCER_FLAK</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.13 - WEAPON MUTATOR, PART VI: MULTIENFORCER_ROCKET">TUTORIAL 12.13 - WEAPON MUTATOR, PART VI: MULTIENFORCER_ROCKET</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.14 - WEAPON MUTATOR, PART VII: MULTIENFORCER_SHOCK">TUTORIAL 12.14 - WEAPON MUTATOR, PART VII: MULTIENFORCER_SHOCK</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.15 - WEAPON MUTATOR, TESTING">TUTORIAL 12.15 - WEAPON MUTATOR, TESTING</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.16 - DELEGATES  KISMET, PART I: INTRODUCTION  INITIAL CLASS SETUP">TUTORIAL 12.16 - DELEGATES &amp; KISMET, PART I: INTRODUCTION &amp; INITIAL CLASS SETUP</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.17 - DELEGATES  KISMET, PART II: UTEFFECTSGENERATOR">TUTORIAL 12.17 - DELEGATES &amp; KISMET, PART II: UTEFFECTSGENERATOR</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.18	- DELEGATES  KISMET, PART III: UTEFFECT">TUTORIAL 12.18	- DELEGATES &amp; KISMET, PART III: UTEFFECT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.19 - DELEGATES  KISMET, PART IV: SEQACT_SETEFFECT">TUTORIAL 12.19 - DELEGATES &amp; KISMET, PART IV: SEQACT_SETEFFECT</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.20 - DELEGATES  KISMET, PART V: SEQACT_USE">TUTORIAL 12.20 - DELEGATES &amp; KISMET, PART V: SEQACT_USE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.21 - DELEGATES  KISMET, PART VI: UTEFFECT_EXPLOSION">TUTORIAL 12.21 - DELEGATES &amp; KISMET, PART VI: UTEFFECT_EXPLOSION</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.22 - DELEGATES  KISMET, PART VII: UTEFFECT_GRENADERING">TUTORIAL 12.22 - DELEGATES &amp; KISMET, PART VII: UTEFFECT_GRENADERING</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.23 - DELEGATES  KISMET, PART VIII: UTEFFECT_GIBBAGE">TUTORIAL 12.23 - DELEGATES &amp; KISMET, PART VIII: UTEFFECT_GIBBAGE</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#TUTORIAL 12.24 - DELEGATES  KISMET, PART IX: SETTING UP THE TEST BED">TUTORIAL 12.24 - DELEGATES &amp; KISMET, PART IX: SETTING UP THE TEST BED</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#12.10 - SUMMARY">12.10 - SUMMARY</a>
</li> <li> <a href="MasteringUnrealScriptDelegates.html#SUPPLEMENTAL FILES">SUPPLEMENTAL FILES</a>
</li></ul>
</li></ul>
</div>
<p />
<h1><a name="CHAPTER 12 - DELEGATES"></a> CHAPTER 12 - DELEGATES </h1>
<p />
Delegates are a reference to a function within an instance. Delegates are a combination of two programming concepts, functions and variables. You have seen how variables hold a value of a specific type and how it can be changed during runtime. In a way, delegates are like variables in that they hold a value and can be changed during runtime. In the case of delegates, though, that value is another function declared within a class. Delegates also behave like functions in that they can be executed. It is this combination of variables and functions that makes delegates such a powerful tool under the right circumstances.
<p />
<h2><a name="12.1 - OVERVIEW"></a> 12.1 - OVERVIEW </h2>
<p />
Delegates are commonly used when the execution of code is required to be dynamic and agile during run time. Traditional methods are not agile, and are often limited. Consider:
<p />
<font face=consolas>
<pre>
var int GlobalVar;

function Foo(float value)
{
   GlobalVar &#61; value;
   Bar();
}

function Bar()
{
   switch (GlobalVar)
   {
      case 0:
         DoThis();
         break;
      case 1:
         DoThat();
         break;
      default:
         DoDefault();
         break;
   }
}
</pre>
</font>
<p />
This could be considered a dynamic way of changing the execution of code during runtime, however it is not an agile method of doing it. It is not agile because when more conditions are added, the effort to maintain Bar() increases. Consider:
<p />
<font face=consolas>
<pre>
delegate Bar();

function Foo(float value)
{
   switch (value)
   {
      case 0:
         Bar &#61; DoThis();
         break;
      case 1:
         Bar &#61; DoThat();
         break;
      default:
         Bar &#61; DoDefault();
         break;
   }

   Bar();
}
</pre>
</font>
<p />
This is better than before because two problems have been resolved. First the global variable is removed, as well as the need to check it when running Bar(). However, because the switch statement still exists, it will suffer the same maintenance problems as before. Instead of Bar() becoming hard to maintain, Foo() will now become hard to maintain. Consider:
<p />
<font face=consolas>
<pre>
delegate Bar();

function Foo(delegate&#60;Bar&#62; BarDelegate)
{
   Bar &#61; BarDelegate;
   Bar();
}
</pre>
</font>
<p />
This is even better than before as the switch statement has now been removed. No matter how many different conditions are added in future, Foo() or Bar() will never need maintenance.
<p />
<h2><a name="12.2 - DECLARING A DELEGATE"></a> 12.2 - DECLARING A DELEGATE </h2>
<p />
Delegates are declared in the same way functions are declared, however instead of using the keyword function, delegate is used instead.
<p />
<font face=consolas>
<pre>
delegate Foo();
</pre>
</font>
<p />
The class now has a delegate named Foo().
<p />
<h3><a name="DELEGATE PARAMETERS"></a> DELEGATE PARAMETERS </h3>
<p />
Delegates, like functions, are allowed to have parameters. When functions are used in conjunction with delegates, functions must also contain the same parameters as the delegate. Consider:
<p />
<font face=consolas>
<pre>
delegate Foo(const float Bar, const float Doh);

function FooBoom(const float Bar, const float Doh);

function FooFail(const float Bar);
</pre>
</font>
<p />
Assigning FooBoom() to Foo() is valid, but assigning FooFail() to Foo() is invalid. The one exception to this rule is optional parameters. Consider:
<p />
<font face=consolas>
<pre>
delegate Foo(const float Bar, const float Doh, optional float Moe);

function FooBoom(const float Bar, const float Doh);
</pre>
</font>
<p />
Assigning FooBoom() to Foo() is still valid, except that you could not use Moe within FooBoom(). Delegates are also allowed to have return parameters as well.
<p />
<h3><a name="DEFAULT BEHAVIOR"></a> DEFAULT BEHAVIOR </h3>
<p />
Defining a body for a delegate sets the default behavior, when the delegate has not been assigned to a function. Consider:
<p />
<font face=consolas>
<pre>
delegate Foo()
{
   `Log(“Default behavior.”);
}

function Bar()
{
   `Log(“Non default behavior.”);
}

function Bing()
{
   Foo &#61; Bar;
   Foo();
   Foo &#61; none;
   Foo();
}
</pre>
</font>
<p />
This would write to the script log like so,
<p />
<font face=consolas>
<pre>
ScriptLog: Non default behavior.
ScriptLog: Default behavior.
</pre>
</font>
<p />
<h2><a name="12.3 - DELEGATES AS VARIABLES"></a> 12.3 - DELEGATES AS VARIABLES </h2>
<p />
Delegates can be used like variables. While they cannot be used arithmetically like floats or integers, they can be assigned to and compared with. The syntax is exactly the same as assigning any other variable in Unrealscript. Consider:
<p />
<font face=consolas>
<pre>
delegate Foo();

function Bar();

function PostBeginPlay()
{
   Foo &#61; Bar;
}
</pre>
</font>
<p />
Sometimes it is useful to compare delegates to see what function they are currently referencing to. Consider:
<p />
<font face=consolas>
<pre>
delegate Foo();

function Bar();

function Rod();

function PostBeginPlay()
{
   Foo &#61; Bar;

   if (Foo &#61;&#61; Bar)
      `Log(“Foo is assigned to Bar()”);

   Foo &#61; Rod;

   if (Foo !&#61; Bar)
      `Log(“Foo is not assigned to Bar()”);
}
</pre>
</font>
<p />
Using comparison functions like so, may help eliminate other global variables used to track down what delegates are pointing to.
<p />
<h2><a name="12.4 - PASSING A DELEGATE TO A FUNCTION"></a> 12.4 - PASSING A DELEGATE TO A FUNCTION </h2>
<p />
As delegates are like variables, we are also able to use them within function parameters. This can be useful when you want to pass delegates between functions and instances. Consider:
<p />
<font face=consolas>
<pre>
delegate Foo();

function Bar();

function PassDelegate()
{
   ReceiveDelegate(Bar);
}

function ReceiveDelegate(delegate&#60;Foo&#62; FooDelegate)
{
   Foo &#61; FooDelegate;
}
</pre>
</font>
<p />
This method of assigning delegates is important when the delegates themselves are protected or privatized from other classes. Since the delegate is private or protected, other classes would not normally have access to the delegate. Consider:
<p />
<font face=consolas>
<pre>
class Pizza extends Object;

private delegate Eat();

function EatMe()
{
   Eat();
}

function HowToEat(delegate&#60;Eat&#62; EatDelegate)
{
   Eat &#61; EatDelegate;
}

class Mushroom extends Object;

function SpitOut()
{
   `Log(“I spit out the mushrooms, as they are disgusting.”);
}

function EatPizza(Pizza pizza)
{
   if (pizza !&#61; none)
   {
      pizza.HowToEat(SpitOut);
      pizza.EatMe();
   }
}
</pre>
</font>
<p />
<h2><a name="12.5 - DELEGATES AND MEMORY"></a> 12.5 - DELEGATES AND MEMORY </h2>
<p />
When a delegate references a function which exists in another actor instance within the world, it is safe to destroy the actor instance. However, if a delegate references a function which exists in another object instance, the delegate must be set to none. Since Unrealscript is unable to destroy object instances on demand, all circular references must  be removed. Otherwise the object instance cannot be garbage collected, and a memory leak will occur when the level changes, or when the game exits.
<p />
<h2><a name="12.6 - UISCENE AND UIOBJECT DELEGATES"></a> 12.6 - UISCENE AND UIOBJECT DELEGATES </h2>
<p />
UIScenes and the UIObjects used within them make use of delegates to provide easy methods of customizing the functionality of those elements. Because delegates are most commonly used in this context by modders, the delegates found within these classes are listed and explained below.
<p />
<h3><a name="UISCENE DELEGATES"></a> UISCENE DELEGATES </h3>
<p /> <ul>
<li> OnSceneActivated(UIScene ActivatedScene, bool bInitialActivation) - This is called when the scene becomes the active scene. ActivatedScene is the UIScene that became activated, bInitialActivation is set true if this is the first time the scene is being activated.
</li></ul>
<p /> <ul>
<li> OnSceneDeactivated(UIScene DeactivatedScene) - This is called when the scene becomes deactivated. DeactivatedScene is the UIScene that became deactivated.
</li></ul>
<p /> <ul>
<li> OnTopSceneChanged(UIScene NewTopScene) - This is called when this UIScene is used to be the top most scene, and another UIScene is going to become the top most scene. NewTopScene is the UIScene that is about to become the new top mose scene. UIScenes can be stacked on top of each other, this layering property allows you to combine different scenes together. For example a background UIScene can be made which changes rarely, and the interactive UIScene can be layered on top.
</li></ul>
<p /> <ul>
<li> bool ShouldModulateBackgroundAlpha(out float AlphaModulationPercent) - Provides UIScenes a way to alter the amount of transparency used when rendering the parent scene. AlphaModulationPercent is the value that will be used for modulating the alpha when rendering the scene below this one. Returns true if the alpha modulation should be applied when rendering the scene below this one.
</li></ul>
<p />
<h3><a name="UIOBJECT DELEGATES"></a> UIOBJECT DELEGATES </h3>
<p /> <ul>
<li> OnCreate(UIObject CreatedWidget, UIScreenObject CreatorContainer) - This is called when the UIObject is created. CreatedWidget is the UIObject that was created, UIScreenObject is the container that created the widget.
</li></ul>
<p /> <ul>
<li> OnValueChanged(UIObject Sender, int PlayerIndex) - This is called when the value of this UIObject has changed. This is only relevant to UIObjects that contain data values. Sender is the UIObject who invoked this delegate, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> bool OnRefreshSubscriberValue(UIObject Sender, int BindingIndex) - This is called when the UIObject receives a call to RefreshSubscriberValue. Sender is the UIObject that invoked this delegate, BindingIndex indicates which data store binding is being refreshed, for those UIObjects that have multiple data store bindings. It is up to the class which implements this delegate to use it. Return true if this UIObject is going to refresh its value manually.
</li></ul>
<p /> <ul>
<li> OnPressed(UIScreenObject EventObject, int PlayerIndex) - This is called when the UIObject is pressed. This is not implemented in all UIObject types. EventObject is the UIScreenObject that invoked this delegate, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnPressRepeat(UIScreenObject EventObject, int PlayerIndex) - This is called when the widgets has been pressed and the user is holding the button down. Not implemented by all widget types. EventObject is the UIScreenObject that invoked this delegate. PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnPressRelease(UIScreenObject EventObject, int PlayerIndex) - This is called when the widget is no longer being pressed. Not implemented by all widget types. EventObject is the UIScreenObject that invoked this delegate. PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> bool OnClicked(UIScreenObject EventObject, int PlayerIndex) - This is called when the widget is no longer being pressed. Not implemented by all widget types. This differs to OnPressRelease in that this will only be called on the UIObject that received the matching key press. OnPressRelease is called on which ever UIObject was under the cursor the key was released, which may not be the UIObject that received the key press. EventObject is the UIObject that invoked this delegate. PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnDoubleClick(UIScreenObject EventObject, int PlayerIndex) - This is called when the widget has received a double-click event. Not implemented by all widget types.  EventObject Is the UIScreenObject that invoked this delegate.
</li></ul>
<p /> <ul>
<li> bool OnQueryToolTip(UIObject Sender, out UIToolTip CustomToolTip) - This provides a way for child classes or containers to override the standard tool tip that is shown. Sender if the UIObject that will be displaying the tool tip. CustomToolTip is the tool tip that will be shown. Return true to show the tool tip, or false to prevent a tool tip from showing.
</li></ul>
<p /> <ul>
<li> bool OnOpenContextMenu(UIObject Sender, int PlayerIndex, out UIContextMenu CustomContextMenu) - This provides a way for script to show a custom context menu, which is a menu that pops up when the user right clicks. Sender is the UIObject that will be displaying the context menu. PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.  CustomContextMenu is the custom context menu that will be displayed. Return true to show the custom context menu, or return false to prevent a context menu from being displayed.
</li></ul>
<p /> <ul>
<li> OnCloseContextMenu(UIContextMenu ContextMenu, int PlayerIndex) - This is called when the system wants to close the currently activated context menu. ContextMenu is the context menu that will be closed. PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnContextMenuItemSelected(UIContextMenu ContextMenu, int PlayerIndex, int ItemIndex) - This is called when the user selects a choice from a context menu. ContextMenu is the context menu that invoked this delegate. PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event. ItemIndex is the index into the context menu's MenuItems array.
</li></ul>
<p /> <ul>
<li> OnUIAnimEnd(UIObject AnimTarget, int AnimIndex, UIAnimationSeq AnimSeq) - This is called when ever an UI animation has finished. AnimTarget is the UIObject that invoked this delegate, AnimIndex is the animation index, UIAnimationSeq is the animation sequence.
</li></ul>
<p />
<h2><a name="12.7 – OTHER DELEGATES IN UNREAL ENGINE 3 AND UNREAL TOURNAMENT 3"></a> 12.7 – OTHER DELEGATES IN UNREAL ENGINE 3 AND UNREAL TOURNAMENT 3 </h2>
<p />
There are important delegates within Unreal Engine 3 and Unreal Tournament 3 that are good to know, because they provide useful hooks for doing many things. This sub section will provide a list of delegates that exist in Unreal Engine 3 and Unreal Tournament 3.
<p />
<h3><a name="AUDIOCOMPONENT"></a> AUDIOCOMPONENT </h3>
<p /> <ul>
<li> OnAudioFinished(AudioComponent AC) - This is called when the AudioComponent has finished playing back its current SoundCue, because either it has completed the playback or Stop() was called. AC references to the AudioComponent that invoked this delegate.
</li></ul>
<p />
<h3><a name="GAMEINFO"></a> GAMEINFO </h3>
<p /> <ul>
<li> bool CanUnpause() - This is useful when you need to implement a more specific condition of whether the game can be unpaused or not. By default, it is just a toggle.
</li></ul>
<p />
<h3><a name="GAMEVIEWPORTCLIENT"></a> GAMEVIEWPORTCLIENT </h3>
<p /> <ul>
<li> bool HandleInputKey(int ControllerId, name Key, EInputEvent EventType, float AmountDepressed, optional bool bGamepad) - This provides child classes an opportunity to handle key input events received from the view port. It is called before the key event is passed off to the interactions array for processing. ControllerId points to the controller that triggered the event, Key is the key pressed, EventType defines what sort of event occurred, AmountDepressed is used for analog type controller and bGamepad will be True if it was from a game pad device.
</li></ul>
<p /> <ul>
<li> bool HandleInputAxis(int ControllerId, name Key, float Delta, float DeltaTime, bool bGamepad) - This provides child classes an opportunity to handle axis input events received from the view port. It is called before the axis event is passed off to the interactions array for processing. ControllerId points to the controller that triggered the event, Key is the key involved, Delta is the movement delta, DeltaTime is the time passed (in seconds) since the last axis was updated and bGamepad will be True if it was from a game pad device.
</li></ul>
<p /> <ul>
<li> bool HandleInputChar(int ControllerId, string Unicode) - This provides child classes an opportunity to handle character input events received from the viewport. It is called before the character event is passed off to the interactions array for processing. ControllerId points to the controller that triggered the event, and Unicode is the character that was typed.
</li></ul>
<p />
<h3><a name="INTERACTION"></a> INTERACTION </h3>
<p /> <ul>
<li> bool OnReceivedNativeInputKey(int ControllerId, name Key, EInputEvent EventType, optional float AmountDepressed = 1.f, optional bool bGamepad) - Same as GameViewportClient.HandleInputKey, however it is only called when invoked natively from the GameViewportClient.
</li></ul>
<p /> <ul>
<li> bool OnReceivedNativeInputAxis(int ControllerId, name Key, float Delta, float DeltaTime, optional bool bGamepad) - Same as GameViewportClient.HandleInputAxis, however it is only called when invoked natively from the GameViewportClient.
</li></ul>
<p /> <ul>
<li> bool OnReceivedNativeInputChar(int ControllerId, string Unicode) - Same as GameViewportClient.HandleInputChar, however it is only called when invoked natively from the GameViewportClient.
</li></ul>
<p /> <ul>
<li> OnInitialize() - This is called from within the natively implemented Init() function, after native initialization is complete.
</li></ul>
<p />
<h3><a name="ONLINEACCOUNTINTERFACE"></a> ONLINEACCOUNTINTERFACE </h3>
<p /> <ul>
<li> OnCreateOnlineAccountCompleted(EOnlineAccountCreateStatus ErrorStatus) - This is called when the account creation routine has been completed. ErrorStatus will declare whether the account was created successfully or not.
</li></ul>
<p />
<h3><a name="ONLINECONTENTINTERFACE"></a> ONLINECONTENTINTERFACE </h3>
<p /> <ul>
<li> OnContentChange() - This is called when any content has changed for any of the users.
</li></ul>
<p /> <ul>
<li> OnReadContentComplete(bool bWasSuccessful) - This is called when the content read request has been completed. bWasSuccessful will be set true if reading was successful.
</li></ul>
<p /> <ul>
<li> OnQueryAvailableDownloadsComplete(bool bWasSuccessful) - This is called when the content download query has been completed. bWasSuccessful will be set true if the query was successful.
</li></ul>
<p />
<h3><a name="ONLINEGAMEINTERFACE"></a> ONLINEGAMEINTERFACE </h3>
<p /> <ul>
<li> OnCreateOnlineGameComplete(bool bWasSuccessful) - This is called when the online game creation routine has completed. bWasSuccessful will be set true if the game was created successfully.
</li></ul>
<p /> <ul>
<li> OnDestroyOnlineGameComplete(bool bWasSuccessful) - This is called when the online game destruction routine has completed. bWasSuccessful will be set true if the game was destroyed successfully.
</li></ul>
<p /> <ul>
<li> OnFindOnlineGamesComplete(bool bWasSuccessful) - This is called when the online game finding routine has completed. bWasSuccessful will be set true if the game finding routine was successful.
</li></ul>
<p /> <ul>
<li> OnCancelFindOnlineGamesComplete(bool bWasSuccessful) - This is called when the online game finding routine was canceled. bWasSuccessful will be set true if the game finding routine was canceled successfully.
</li></ul>
<p /> <ul>
<li> OnJoinOnlineGameComplete(bool bWasSuccessful) - This is called when joining an online game routine was completed. bWasSuccessful will be set true if joining the game was successful.
</li></ul>
<p /> <ul>
<li> OnRegisterPlayerComplete(bool bWasSuccessful) - This is called when the player registration routine was completed. bWasSuccessful will be set true if the registration was successful.
</li></ul>
<p /> <ul>
<li> OnUnregisterPlayerComplete(bool bWasSuccessful) - This is called when the player unregistration routine was completed. bWasSuccessful will be set true if the unregistration was successful.
</li></ul>
<p /> <ul>
<li> OnStartOnlineGameComplete(bool bWasSuccessful) - This is called when the game state has changed to started. bWasSuccessful will be set true if the asynchronous routine was successful.
</li></ul>
<p /> <ul>
<li> OnEndOnlineGameComplete(bool bWasSuccessful) - This is called when the game state has changed to ended. bWasSuccessful will be set true if the asynchronous routine was successful.
</li></ul>
<p /> <ul>
<li> OnArbitrationRegistrationComplete(bool bWasSuccessful) - This is called when the game has completed registration for arbitration. bWasSuccessful will be set true if the asynchronous routine was successful.
</li></ul>
<p /> <ul>
<li> OnGameInviteAccepted(OnlineGameSettings GameInviteSettings) - This is called when the user accepts a game invitation. This provides an opportunity for code to clean up any existing states before accepting the invite.
</li></ul>
<p />
<h3><a name="ONLINENEWSINTERFACE"></a> ONLINENEWSINTERFACE </h3>
<p /> <ul>
<li> OnReadGameNewsCompleted(bool bWasSuccessful) - This is called when the news read routine was completed. bWasSuccessful will be set true if the routine was successful.
</li></ul>
<p /> <ul>
<li> OnReadContentAnnouncementsCompleted(bool bWasSuccessful) - This is called when the content announcements routine was completed. bWasSuccessful will be set true if the routine was successful.
</li></ul>
<p />
<h3><a name="ONLINEPLAYERINTERFACE"></a> ONLINEPLAYERINTERFACE </h3>
<p /> <ul>
<li> OnLoginChange() - This is called when the login changes.
</li></ul>
<p /> <ul>
<li> OnLoginCancelled() - This is called when a login request is canceled.
</li></ul>
<p /> <ul>
<li> OnMutingChange() - This is called when the mute list changes.
</li></ul>
<p /> <ul>
<li> OnFriendsChange() - This is called when the friends list changes.
</li></ul>
<p /> <ul>
<li> OnLoginFailed(byte LocalUserNum, EOnlineServerConnectionStatus ErrorCode) - This is called when the login failed for any reason. LocalUserNum points to the controller id. ErrorCode represents the error that occurred.
</li></ul>
<p /> <ul>
<li> OnLogoutCompleted(bool bWasSuccessful) - This is called when logging out was completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p /> <ul>
<li> OnReadProfileSettingsComplete(bool bWasSuccessful) - This is called when the last read profile settings request has completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p /> <ul>
<li> OnWriteProfileSettingsComplete(bool bWasSuccessful) - This is called when the last write profile settings request has completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p /> <ul>
<li> OnReadFriendsComplete(bool bWasSuccessful) - This is called when the friends read request has completed. bWasSuccessful is set true if the read request was completed properly.
</li></ul>
<p /> <ul>
<li> OnKeyboardInputComplete(bool bWasSuccessful) - This is called when the keyboard input request has completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p /> <ul>
<li> OnAddFriendByNameComplete(bool bWasSuccessful) - This is called when adding a friend by name has completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p /> <ul>
<li> OnFriendInviteReceived(byte LocalUserNum, UniqueNetId RequestingPlayer, string RequestingNick, string Message) -  This is called when the friend invite arrives for a local player. LocalUserNum points to the local user, RequestingPlayer is a unique identifier for the player who sent the invite to the local user, RequestingNick is the nick name of the player who sent the request, Message is an additional message.
</li></ul>
<p /> <ul>
<li> OnReceivedGameInvite(byte LocalUserNum, string InviterName) - This is called when the local user receives a game invite. LocalUserNum points to the local user, InviterName is the name of the person inviting.
</li></ul>
<p /> <ul>
<li> OnJoinFriendGameComplete(bool bWasSuccessful) - This is called when the local users finishes joining to a friend's game. bWasSuccessful is set true if the session was found and joined.
</li></ul>
<p /> <ul>
<li> OnFriendMessageReceived(byte LocalUserNum, UniqueNetId SendingPlayer, string SendingNick, string Message) - This is called when a friends message arrives for the local user. LocalUserNum points to the local user, RequestingPlayer is a unique identifier for the player who sent the invite to the local user, RequestingNick is the nick name of the player who sent the request, Message is an additional message.
</li></ul>
<p />
<h3><a name="ONLINEPLAYERINTERFACEEX"></a> ONLINEPLAYERINTERFACEEX </h3>
<p /> <ul>
<li> OnDeviceSelectionComplete(bool bWasSuccessful) - This is called when the device selection request has completed. bWasSuccessful is set true if the device selection has completed successful.
</li></ul>
<p /> <ul>
<li> OnUnlockAchievementComplete(bool bWasSuccessful) - This is called when the achievement unlocking request has completed. bWasSuccessful is set true if the unlock achievement has completed successful.
</li></ul>
<p /> <ul>
<li> OnProfileDataChanged() - This is called when an external change to the player profile data has completed.
</li></ul>
<p />
<h3><a name="ONLINESTATSINTERFACE"></a> ONLINESTATSINTERFACE </h3>
<p /> <ul>
<li> OnReadOnlineStatsComplete(bool bWasSuccessful) - This is called when reading the online stats has completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p /> <ul>
<li> OnFlushOnlineStatsComplete(bool bWasSuccessful) - This is called when flushing the online stats has completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p /> <ul>
<li> OnRegisterHostStatGuidComplete(bool bWasSuccessful) - This is called when the host stats guid registration has completed. bWasSuccessful is set true if the asynchronous call completed properly.
</li></ul>
<p />
<h3><a name="ONLINESTATSREAD"></a> ONLINESTATSREAD </h3>
<p /> <ul>
<li> OnStatsReadComplete() - This is called when reading the stats has completed.
</li></ul>
<p />
<h3><a name="ONLINESTATSWRITE"></a> ONLINESTATSWRITE </h3>
<p /> <ul>
<li> OnStatsWriteComplete() - This is called when writing the stats has completed.
</li></ul>
<p />
<h3><a name="ONLINESYSTEMINTERFACE"></a> ONLINESYSTEMINTERFACE </h3>
<p /> <ul>
<li> OnLinkStatusChange(bool bIsConnected) - This is called when the network link status changes. bIsConnected will be set true if a connection of some sort is found.
</li></ul>
<p /> <ul>
<li> OnExternalUIChange(bool bIsOpening) - This is called when the external UI display changes state. bIsOpening is set true if the UI is opening.
</li></ul>
<p /> <ul>
<li> OnControllerChange(int ControllerId, bool bIsConnected) - This is called when the controller connection state changes. ControllerId points to the controller whose connection state has changed, bIsConnected is set true if the controller is connected.
</li></ul>
<p /> <ul>
<li> OnConnectionStatusChange(EOnlineServerConnectionStatus ConnectionStatus) - This is called when the online server connection state changes. ConnectionStatus contains information about the new connection status.
</li></ul>
<p /> <ul>
<li> OnStorageDeviceChange() - This is called when a storage device change is detected.
</li></ul>
<p />
<h3><a name="ONLINEVOICEINTERFACE"></a> ONLINEVOICEINTERFACE </h3>
<p /> <ul>
<li> OnPlayerTalking(UniqueNetId Player) - This is called when a player is talking either locally or remotely. This will be called once for each active talker, each frame. Player points to the player who is talking.
</li></ul>
<p /> <ul>
<li> OnRecognitionComplete() - This is called when the speech recognition for a given player has completed. You can then call GetRecognitionResults() to get the words that were recognised.
</li></ul>
<p />
<h3><a name="PARTICLESYSTEMCOMPONENT"></a> PARTICLESYSTEMCOMPONENT </h3>
<p /> <ul>
<li> OnSystemFinished(ParticleSystemComponent Psystem) - This is called when the particle system has finished 'playing' the particle effect. Psystem points to itself, so that if you over ride this delegate within another instance you have access to the ParticleSystemComponent which invoked the delegate.
</li></ul>
<p />
<h3><a name="PLAYERCONTROLLER"></a> PLAYERCONTROLLER </h3>
<p /> <ul>
<li> bool CanUnpause() - Override this when you need different logic to determine when a player controller is able to unpause the game.
</li></ul>
<p />
<h3><a name="UICOMBOBOX"></a> UICOMBOBOX </h3>
<p /> <ul>
<li> UIEditBox CreateCustomComboEditbox(UIComboBox EditboxOwner) - Override this when you need different logic for creating an edit box. EditboxOwner is the UIComboBox who invoked the delegate. Returns the edit box that was created.
</li></ul>
<p /> <ul>
<li> UIToggleButton CreateCustomComboButton(UIComboBox ButtonOwner) - Override this when you need different logic for creating a toggle combo button. ButtonOwner is the UIComboBox who invoked the delegate. Returns the toggle button that was created.
</li></ul>
<p /> <ul>
<li> UIList CreateCustomComboList(UIComboBox ListOwner) - Override this when you need different logic for creating a list. ListOwner is the UIComboBox who invoked the delegate. Returns the list was created.
</li></ul>
<p />
<h3><a name="UICOMP_DRAWCOMPONENTS"></a> UICOMP_DRAWCOMPONENTS </h3>
<p /> <ul>
<li> OnFadeComplete(UIComp_DrawComponents Sender) - This is called when the fade has been completed. Sender is the UIComp_DrawComponent who invoked the delegate.
</li></ul>
<p />
<h3><a name="UIDATAPROVIDER"></a> UIDATAPROVIDER </h3>
<p /> <ul>
<li> OnDataProviderPropertyChange(UIDataProvider SourceProvider, optional name PropTag) - This is called when a property has changed. Designed to be used between data providers and their owning data stores, as there are other call backs that you could use instead. SourceProvider is the UIDataProvider that invoked the delegate, PropTag is the name of the property that was changed.
</li></ul>
<p />
<h3><a name="UIDATASTORE"></a> UIDATASTORE </h3>
<p /> <ul>
<li> OnDataStoreValueUpdated(UIDataStore SourceDataStore, bool bValuesInvalidated, name PropertyTag, UIDataProvider SourceProvider, int ArrayIndex) - This is called when  the value exposed by this data store has been updated. Provides data stores a way to notify subscribers when they should refresh their values from this data store. SourceDataStore is the data store that invoked the delegate, bValuesInvalidated is true if all the data values are invalid thus requiring a full refresh, PropertyTag is the tag of the data field that was updated, SourceProvider is the data store that contains the data that was changed, ArrayIndex points to which array element was changed if the data field is a collection of data otherwise this will be INDEX_NONE (-1).
</li></ul>
<p />
<h3><a name="UIDATASTORE_GAMESTATE"></a> UIDATASTORE_GAMESTATE </h3>
<p /> <ul>
<li> OnRefreshDataFieldValue() - This is called when a data field was refreshed.
</li></ul>
<p />
<h3><a name="UIEDITBOX"></a> UIEDITBOX </h3>
<p /> <ul>
<li> bool OnSubmitText(UIEditBox Sender, int PlayerIndex) - This is called when the user presses enter or invokes any other action bound to UIKey_SubmitText while the edit box has focus. Sender is the edit box that invoked this delegate, the PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event. Return true if you wish to clear the edit box when finished.
</li></ul>
<p />
<h3><a name="UIEVENT"></a> UIEVENT </h3>
<p /> <ul>
<li> AllowEventActivation(int ControllerIndex, UIScreenObject InEventOwner, Object InEventActivator, bool bActivateImmediately, out const array<int> IndicesToActivate) - UILIST
</li></ul>
<p /> <ul>
<li> OnSubmitSelection(UIList Sender, optional int PlayerIndex = GetBestPlayerIndex()) - This is called when the user presses enter of invokes any other action bound to UIKey_SubmitText while the list has focus. Sender is the list that invoked this delegate, the PlayerIndex is the index within Engine.GamePlayers pointing to the player who generated the event.
</li></ul>
<p /> <ul>
<li> OnListElementsSorted(UIList Sender) - This is called after the list's elements have been sorted. Sender is the list that invoked this delegate.
</li></ul>
<p />
<h3><a name="UIOPTIONLISTBASE"></a> UIOPTIONLISTBASE </h3>
<p /> <ul>
<li> UIOptionListButton CreateCustomDecrementButton(UIOptionListBase ButtonOwner) - Override this when you wish to create your own decrement button. ButtonOwner is the option list base who invoked this delegate. Returns the UIOptionListButton that you created.
</li></ul>
<p /> <ul>
<li> UIOptionListButton CreateCustomIncrementButton(UIOptionListBase ButtonOwner) - Override this when you wish to create your own increment button. ButtonOwner is the option list base who invoked this delegate. Returns the UIOptionListButton that you created.
</li></ul>
<p />
<h3><a name="UISCREENOBJECT"></a> UISCREENOBJECT </h3>
<p /> <ul>
<li> NotifyActiveSkinChanged() - This is called when the active skin has changed. It will reapply this widget's style and propagate the notification to all of its children. This delegate is only called if it is actually assigned to a member function!
</li></ul>
<p /> <ul>
<li> bool OnRawInputKey(const out InputEventParameters EventParms) - Provides an opportunity for Unrealscript to respond to input using actual input key names. This is called when an input key event is received which this widget responds to and is in the correct state to process the event. They keys and states widgets receive input for is managed through the UI editor's key binding dialog (F8). This delegate is called before Kismet. EventParams contains information about the input event. Return true to indicate that this input key was processed and stop all further processing.
</li></ul>
<p /> <ul>
<li> bool OnRawInputAxis(const out InputEventParameters EventParms) - Same as OnRawInputKey.
</li></ul>
<p /> <ul>
<li> OnProcessInputKey(const out SubscribedInputEventParameters EventParms) - Provides an opportunity for Unrealscript to respond to input using UI input aliases. This is called when an input key event is received which this widget responds to and is in the correct state to process the event. They keys and states widgets receive input for is managed through the UI editor's key binding dialog (F8). This delegate is called after Kismet and before native code processes the input. EventParams contains information about the event. Return true to indicate that this key was processed and stop further processing.
</li></ul>
<p /> <ul>
<li> OnProcessInputAxis(const out SubscribedInputEventParameters EventParms) - Same as OnProcessInputKey.
</li></ul>
<p /> <ul>
<li> NotifyPositionChanged(UIScreenObject Sender) - This is called when the UIScreenObject has changed position. Sender is the UIScreenObject that changed its position.
</li></ul>
<p /> <ul>
<li> NotifyResolutionChanged(const out Vector2D OldViewportsize, const out Vector2D NewViewportSize) - This is called when the view port rendering this UIScreenObject has changed resolution. OldViewportSize is the previous resolution, where as NewViewportSize is the new resolution.
</li></ul>
<p /> <ul>
<li> NotifyActiveStateChanged(UIScreenObject Sender, int PlayerIndex, UIState NewlyActiveState, optional UIState PreviouslyActiveState) - This is called when the UIState of the UIScreenObject has changed, after all the activation logic has occurred. Sender is the UIScreenObject that changed states, PlayerIndex is the index within Engine.GamePlayers pointing to the player who activated this state, NewlyActiveState is the state that is now active, PreviouslyActiveState is the previous state the UIScreenObject was in.
</li></ul>
<p /> <ul>
<li> NotifyVisibilityChanged(UIScreenObject SourceWidget, bool bIsVisible) - This is called when the UIScreenObject has changed visibility. SourceWidget is the widget that changed visibility, bIsVisible is set true if the UIScreenObject is visible.
</li></ul>
<p /> <ul>
<li> OnPreRenderCallBack() - This is called before rendering.
</li></ul>
<p />
<h3><a name="UISCROLLBAR"></a> UISCROLLBAR </h3>
<p /> <ul>
<li> OnScrollActivity(UIScrollbar Sender, float PositionChange, optional bool bPositionMaxed = false) - This is called when any scrolling activity is detected. Sender is the UIScrollBar that sent the event, PositionChange is the number of nudge values that the scroll button changed to, bPositionMaxed is true if the marker has reached the maximum position. The return value is unused at the moment.
</li></ul>
<p /> <ul>
<li> OnClickedScrollZone(UIScrollbar Sender, float PositionPerc, int PlayerIndex) - This is called when the user click anywhere within the scroll zone. Sender is the UIScrollBar that sent the event, PositionPerc is a value between 0.f and 1.f representing the position of the click between the increment and decrement button. 0.f is near the decrement button, where 1.f is the increment button. PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p />
<h3><a name="UISCROLLBARMARKERBUTTON"></a> UISCROLLBARMARKERBUTTON </h3>
<p /> <ul>
<li> OnButtonDragged(UIScrollbarMarkerButton Sender, int PlayerIndex) - This is called when the user presses the button and drags it with the mouse. Sender is the UIScrollbarMarkerButton that invoked the delegate, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p />
<h3><a name="UITABBUTTON"></a> UITABBUTTON </h3>
<p /> <ul>
<li> IsActivationAllowed(UITabButton Sender, int PlayerIndex) - This provides an opportunity for other UI widgets to override activation of this button. Sender is the UITabButton being activated, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p />
<h3><a name="UITABCONTROL"></a> UITABCONTROL </h3>
<p /> <ul>
<li> OnPageActivated(UITabControl Sender, UITabPage NewlyActivePage, int PlayerIndex) - This is called when a new page is activated. Sender is the UITabControl that invoked this delegate, NewlyActivePage is the new activated UITabPage, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnPageInserted(UITabControl Sender, UITabPage NewPage, int PlayerIndex) - This is called when a new page is inserted. Sender is the UITabControl that invoked this delegate, NewPage is the newly inserted UITabPage, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnPageRemoved(UITabControl Sender, UITabPage OldPage, int PlayerIndex) - This is called when a page has been removed. Sender is the UITabControl that invoked this delegate, OldPage is the UITabPage about to be removed, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p />
<h3><a name="UITOOLTIP"></a> UITOOLTIP </h3>
<p /> <ul>
<li> ActivateToolTip(UIToolTip Sender) - This is called when the tool tip is about to be activated. Sender is the UIToolTip that invoked the delegate.
</li></ul>
<p /> <ul>
<li> DeactivateToolTip() - This is called when the tool tip is about to be deactivated.
</li></ul>
<p /> <ul>
<li> bool CanShowToolTip(UIToolTip Sender) - This is called when a tool tip needs to know if it can be shown or not. Provides an opportunity for other widgets to prevent a tool tip from being shown. Sender is the UIToolTip in question. Return true if you wish to display the tool tip.
</li></ul>
<p />
<h3><a name="ONLINEGAMEINTERFACEIMPL"></a> ONLINEGAMEINTERFACEIMPL </h3>
<p /> <ul>
<li> OnFindOnlineGamesComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnFindOnlineGamesComplete().
</li></ul>
<p /> <ul>
<li> OnCreateOnlineGameComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnCreateOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnDestroyOnlineGameComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnDestroyOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnCancelFindOnlineGamesComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnCancelFindOnlineGamesComplete().
</li></ul>
<p /> <ul>
<li> OnJoinOnlineGameComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnJoinOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnRegisterPlayerComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnRegisterPlayerComplete().
</li></ul>
<p /> <ul>
<li> OnUnregisterPlayerComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnUnregisterPlayerComplete().
</li></ul>
<p /> <ul>
<li> OnStartOnlineGameComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnStartOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnEndOnlineGameComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnEndOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnArbitrationRegistrationComplete(bool bWasSuccessful) - Same as Engine.OnlineGameInterface.OnArbitrationRegistrationComplete().
</li></ul>
<p /> <ul>
<li> OnGameInviteAccepted(OnlineGameSettings GameInviteSettings) - Same as Engine.OnlineGameInterface.OnGameInviteAccepted().
</li></ul>
<p />
<h3><a name="ONLINEGAMEINTERFACEGAMESPY"></a> ONLINEGAMEINTERFACEGAMESPY </h3>
<p /> <ul>
<li> OnGameInviteAccepted(OnlineGameSettings GameInviteSettings) - This is the same as Engine.OnlineGameInterface.OnGameInviteAccepted().
</li></ul>
<p /> <ul>
<li> OnRegisterPlayerComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnRegisterPlayerComplete().
</li></ul>
<p /> <ul>
<li> OnUnregisterPlayerComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnUnregisterPlayerComplete().
</li></ul>
<p />
<h3><a name="ONLINESUBSYSTEMGAMESPY"></a> ONLINESUBSYSTEMGAMESPY </h3>
<p /> <ul>
<li> OnLoginChange() - This is the same as Engine.OnlinePlayerInterface.OnLoginChange().
</li></ul>
<p /> <ul>
<li> OnLoginCancelled() - This is the same as Engine.OnlinePlayerInterface.OnLoginCancelled().
</li></ul>
<p /> <ul>
<li> OnMutingChange() - This is the same as Engine.OnlinePlayerInterface.OnMutingChange().
</li></ul>
<p /> <ul>
<li> OnFriendsChange() - This is the same as Engine.OnlinePlayerInterface.OnFriendsChange().
</li></ul>
<p /> <ul>
<li> OnLoginFailed(byte LocalUserNum,EOnlineServerConnectionStatus ErrorCode) - This is the same as Engine.OnlinePlayerInterface.OnLoginFailed().
</li></ul>
<p /> <ul>
<li> OnLogoutCompleted(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnLogoutCompleted().
</li></ul>
<p /> <ul>
<li> OnReadProfileSettingsComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnReadProfileSettingsComplete().
</li></ul>
<p /> <ul>
<li> OnWriteProfileSettingsComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnWriteProfileSettingsComplete().
</li></ul>
<p /> <ul>
<li> OnReadFriendsComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnReadFriendsComplete().
</li></ul>
<p /> <ul>
<li> OnPlayerTalking(UniqueNetId Player) - This is the same as Engine.OnlineVoiceInterface.OnPlayerTalking().
</li></ul>
<p /> <ul>
<li> OnRecognitionComplete() - This is the same as Engine.OnlineVoiceInterface.OnRecognitionComplete().
</li></ul>
<p /> <ul>
<li> OnReadOnlineStatsComplete(bool bWasSuccessful) - This is the same as Engine.OnlineStatsInterface.OnReadOnlineStatsComplete().
</li></ul>
<p /> <ul>
<li> OnFlushOnlineStatsComplete(bool bWasSuccessful) - This is the same as Engine.OnlineStatsInterface.OnFlushOnlineStatsComplete().
</li></ul>
<p /> <ul>
<li> OnLinkStatusChange(bool bIsConnected) - This is the same as Engine.OnlineSystemInterface.OnLinkStatusChange().
</li></ul>
<p /> <ul>
<li> OnExternalUIChange(bool bIsOpening - This is the same as Engine.OnlineSystemInterface.OnExternalUIChange().
</li></ul>
<p /> <ul>
<li> OnControllerChange(int ControllerId, bool bIsConnected) - This is the same as Engine.OnlineSystemInterface.OnControllerChange().
</li></ul>
<p /> <ul>
<li> OnConnectionStatusChange(EOnlineServerConnectionStatus ConnectionStatus) - This is the same as Engine.OnlineSystemInterface.OnConnectionStatusChange().
</li></ul>
<p /> <ul>
<li> OnStorageDeviceChange() - This is the same as Engine.OnlineSystemInterface.OnStorageDeviceChange().
</li></ul>
<p /> <ul>
<li> OnCreateOnlineAccountCompleted(EOnlineAccountCreateStatus ErrorStatus) - This is the same as Engine.OnlineAccountInterface.OnCreateOnlineAccountCompleted().
</li></ul>
<p /> <ul>
<li> OnKeyboardInputComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnKeyboardInputComplete().
</li></ul>
<p /> <ul>
<li> OnAddFriendByNameComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnAddFriendByNameComplete().
</li></ul>
<p /> <ul>
<li> OnFriendInviteReceived(byte LocalUserNum, UniqueNetId RequestingPlayer, string RequestingNick, string Message) - This is the same as Engine.OnlinePlayerInterface.OnFriendInviteReceived().
</li></ul>
<p /> <ul>
<li> OnReceivedGameInvite(byte LocalUserNum, string InviterName) - This is the same as Engine.OnlinePlayerInterface.OnReceivedGameInvite().
</li></ul>
<p /> <ul>
<li> OnJoinFriendGameComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnJoinFriendGameComplete().
</li></ul>
<p /> <ul>
<li> OnFriendMessageReceived(byte LocalUserNum, UniqueNetId SendingPlayer, string SendingNick, string Message) - This is the same as Engine.OnlinePlayerInterface.OnJoinFriendGameComplete().
</li></ul>
<p /> <ul>
<li> OnRegisterHostStatGuidComplete(bool bWasSuccessful) - This is the same as Engine.OnlineStatsInterface.OnRegisterHostStatGuidComplete().
</li></ul>
<p /> <ul>
<li> OnReadGameNewsCompleted(bool bWasSuccessful) - This is the same as Engine.OnlineNewsInterface.OnReadGameNewsCompleted().
</li></ul>
<p /> <ul>
<li> OnReadContentAnnouncementsCompleted(bool bWasSuccessful) - This is the same as Engine.OnlineNewsInterface.OnReadContentAnnouncementsCompleted().
</li></ul>
<p />
<h3><a name="ONLINESUBSYSTEMLIVE"></a> ONLINESUBSYSTEMLIVE </h3>
<p /> <ul>
<li> OnLoginChange() - This is the same as Engine.OnlinePlayerInterface.OnLoginChange().
</li></ul>
<p /> <ul>
<li> OnLoginCancelled() - This is the same as Engine.OnlinePlayerInterface.OnLoginCancelled().
</li></ul>
<p /> <ul>
<li> OnMutingChange() - This is the same as Engine.OnlinePlayerInterface.OnMutingChange().
</li></ul>
<p /> <ul>
<li> OnFriendsChange() - This is the same as Engine.OnlinePlayerInterface.OnFriendsChange().
</li></ul>
<p /> <ul>
<li> OnLoginFailed(byte LocalUserNum,EOnlineServerConnectionStatus ErrorCode) - This is the same as Engine.OnlinePlayerInterface.OnLoginFailed().
</li></ul>
<p /> <ul>
<li> OnLogoutCompleted(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnLogoutCompleted().
</li></ul>
<p /> <ul>
<li> OnKeyboardInputComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnKeyboardInputComplete().
</li></ul>
<p /> <ul>
<li> OnLinkStatusChange(bool bIsConnected) - This is the same as Engine.OnlineSystemInterface.OnLinkStatusChange().
</li></ul>
<p /> <ul>
<li> OnExternalUIChange(bool bIsOpening) - This is the same as Engine.OnlineSystemInterface.OnExternalUIChange().
</li></ul>
<p /> <ul>
<li> OnControllerChange(int ControllerId, bool bIsConnected) - This is the same as Engine.OnlineSystemInterface.OnControllerChange().
</li></ul>
<p /> <ul>
<li> OnConnectionStatusChange(EOnlineServerConnectionStatus ConnectionStatus) - This is the same as Engine.OnlineSystemInterface.OnConnectionStatusChange().
</li></ul>
<p /> <ul>
<li> OnStorageDeviceChange() - This is the same as Engine.OnlineSystemInterface.OnStorageDeviceChange().
</li></ul>
<p /> <ul>
<li> OnFindOnlineGamesComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnFindOnlineGamesComplete().
</li></ul>
<p /> <ul>
<li> OnCreateOnlineGameComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnCreateOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnDestroyOnlineGameComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnDestroyOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnCancelFindOnlineGamesComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnCancelFindOnlineGamesComplete().
</li></ul>
<p /> <ul>
<li> OnJoinOnlineGameComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnJoinOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnRegisterPlayerComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnRegisterPlayerComplete().
</li></ul>
<p /> <ul>
<li> OnUnregisterPlayerComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnUnregisterPlayerComplete().
</li></ul>
<p /> <ul>
<li> OnReadProfileSettingsComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnReadProfileSettingsComplete().
</li></ul>
<p /> <ul>
<li> OnWriteProfileSettingsComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnWriteProfileSettingsComplete().
</li></ul>
<p /> <ul>
<li> OnDeviceSelectionComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterfaceEx.OnDeviceSelectionComplete().
</li></ul>
<p /> <ul>
<li> OnUnlockAchievementComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterfaceEx.OnUnlockAchievementComplete().
</li></ul>
<p /> <ul>
<li> OnProfileDataChanged() - This is the same as Engine.OnlinePlayerInterfaceEx.OnProfileDataChanged().
</li></ul>
<p /> <ul>
<li> OnStartOnlineGameComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnStartOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnEndOnlineGameComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnEndOnlineGameComplete().
</li></ul>
<p /> <ul>
<li> OnArbitrationRegistrationComplete(bool bWasSuccessful) - This is the same as Engine.OnlineGameInterface.OnArbitrationRegistrationComplete().
</li></ul>
<p /> <ul>
<li> OnReadFriendsComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnReadFriendsComplete().
</li></ul>
<p /> <ul>
<li> OnGameInviteAccepted(OnlineGameSettings InviteSettings) - This is the same as Engine.OnlineGameInterface.OnGameInviteAccepted().
</li></ul>
<p /> <ul>
<li> OnContentChange() - This is the same as Engine.OnlineContentInterface.OnContentChange().
</li></ul>
<p /> <ul>
<li> OnReadContentComplete(bool bWasSuccessful) - This is the same as Engine.OnlineContentInterface.OnReadContentComplete().
</li></ul>
<p /> <ul>
<li> OnQueryAvailableDownloadsComplete(bool bWasSuccessful) - This is the same as Engine.OnlineContentInterface.OnQueryAvailableDownloadsComplete().
</li></ul>
<p /> <ul>
<li> OnPlayerTalking(UniqueNetId Player) - This is the same as Engine.OnlineVoiceInterface.OnPlayerTalking().
</li></ul>
<p /> <ul>
<li> OnRecognitionComplete() - This is the same as Engine.OnlineVoiceInterface.OnRecognitionComplete().
</li></ul>
<p /> <ul>
<li> OnReadOnlineStatsComplete(bool bWasSuccessful) - This is the same as Engine.OnlineStatsInterface.OnReadOnlineStatsComplete().
</li></ul>
<p /> <ul>
<li> OnFlushOnlineStatsComplete(bool bWasSuccessful) - This is the same as Engine.OnlineStatsInterface.OnFlushOnlineStatsComplete().
</li></ul>
<p /> <ul>
<li> OnAddFriendByNameComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnAddFriendByNameComplete().
</li></ul>
<p /> <ul>
<li> OnFriendInviteReceived(byte LocalUserNum, UniqueNetId RequestingPlayer, string RequestingNick, string Message) - This is the same as Engine.OnlinePlayerInterface.OnFriendInviteReceived().
</li></ul>
<p /> <ul>
<li> OnReceivedGameInvite(byte LocalUserNum,string InviterName) - This is the same as Engine.OnlinePlayerInterface.OnReceivedGameInvite().
</li></ul>
<p /> <ul>
<li> OnJoinFriendGameComplete(bool bWasSuccessful) - This is the same as Engine.OnlinePlayerInterface.OnJoinFriendGameComplete().
</li></ul>
<p /> <ul>
<li> OnFriendMessageReceived(byte LocalUserNum, UniqueNetId SendingPlayer, string SendingNick, string Message) - This is the same as Engine.OnlinePlayerInterface.OnFriendMessageReceived().
</li></ul>
<p /> <ul>
<li> OnRegisterHostStatGuidComplete(bool bWasSuccessful) - This is the same as Engine.OnlineStatsInterface.OnRegisterHostStatGuidComplete().
</li></ul>
<p />
<h3><a name="UTBOT"></a> UTBOT </h3>
<p /> <ul>
<li> bool CustomActionFunc(UTBot B) - This is called when the bot is within the CustomAction state. B is the bot that invoked this delegate.
</li></ul>
<p />
<h3><a name="UTDATASTORE_ONLINESTATS"></a> UTDATASTORE_ONLINESTATS </h3>
<p /> <ul>
<li> OnStatsReadComplete(bool bWasSuccessful) - This is call when reading the stats has completed. bWasSuccessful is set true if the asynchronous call completed successfully.
</li></ul>
<p />
<h3><a name="UTDEPLOYEDACTOR"></a> UTDEPLOYEDACTOR </h3>
<p /> <ul>
<li> OnDeployableUsedUp(actor ChildDeployable) - This is called when the deployed actor is going to be destroyed. ChildDeployable is the actor that is destroying itself.
</li></ul>
<p />
<h3><a name="UTDRAWMAPPANEL"></a> UTDRAWMAPPANEL </h3>
<p /> <ul>
<li> OnActorSelected(Actor Selected, UTPlayerController SelectedBy) - This is called when a node is double clicked on. Selected is the actor that was selected, SelectedBy is the UTPlayerController that did the selection.
</li></ul>
<p />
<h3><a name="UTEXPLOSIONLIGHT"></a> UTEXPLOSIONLIGHT </h3>
<p /> <ul>
<li> OnLightFinished(UTExplosionLight Light) - This is called when the light has finished and is no longer emitting light. Light is the actor that invoked this delegate.
</li></ul>
<p />
<h3><a name="UTKACTOR"></a> UTKACTOR </h3>
<p /> <ul>
<li> OnBreakApart() - This is called when the physics actor is breaking apart.
</li></ul>
<p /> <ul>
<li> bool OnEncroach(actor Other) - This is called when the physics actor is being encroached on. Other is the actor that this physics actor is being encroached by.
</li></ul>
<p />
<h3><a name="UTMISSIONGRI"></a> UTMISSIONGRI </h3>
<p /> <ul>
<li> OnBinkMovieFinished() - This is called when the movie has finished playing.
</li></ul>
<p />
<h3><a name="UTSCOREBOARDPANEL"></a> UTSCOREBOARDPANEL </h3>
<p /> <ul>
<li> OnSelectionChange(UTScoreboardPanel TargetScoreboard, UTPlayerReplicationInfo PRI) - This is called when the selection has changed. TargetScoreboard is the scoreboard that invoked this delegate, PRI is the player replication info that was selected.
</li></ul>
<p />
<h3><a name="UTSIMPLEIMAGELIST"></a> UTSIMPLEIMAGELIST </h3>
<p /> <ul>
<li> bool OnDrawItem(UTSimpleImageList SimpleList, int ItemIndex, float Xpos, out float Ypos) - This is called when the item is going be drawn. SimpleList is the list that invoked the delegate, ItemIndex is an index into the List array, Xpos is the x coordinate to draw the item, Ypos is the y coordinate to draw the item. Return false to render the item using the default method.
</li></ul>
<p /> <ul>
<li> OnItemChosen(UTSimpleImageList SourceList, int SelectedIndex, int PlayerIndex) - This is called when an item within the list has been chosen. SourceList is the list that invoked the delegate, SelectedIndex is the new selection index, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnSelectionChange(UTSimpleImageList SourceList, int NewSelectedIndex) - This is called when the selection index changes. SourceList is the list that invoked the delegate, NewSelectedIndex is the new selection index.
</li></ul>
<p />
<h3><a name="UTSIMPLELIST"></a> UTSIMPLELIST </h3>
<p /> <ul>
<li> bool OnDrawItem(UTSimpleList SimpleList, int ItemIndex, float XPos, out float Ypos) - This is called when the item is going be drawn. SimpleList is the list that invoked the delegate, ItemIndex is an index into the List array, Xpos is the x coordinate to draw the item, Ypos is the y coordinate to draw the item. Return false to render the item using the default method.
</li></ul>
<p /> <ul>
<li> bool OnDrawSelectionBar(UTSimpleList SimpleList, float Ypos) - This is called when the selection bar is going to be drawn. SimpleList is the list that invoked the delegate, Ypos is the y coordinate to draw the item. Return false to draw the selection bar using the default method.
</li></ul>
<p /> <ul>
<li> bool OnPostDrawSelectionBar(UTSimpleList SimpleList, float YPos, float Width, float Height) - This is called after the selection bar is drawn. SimpleList is the list that invoked the delegate, Ypos was the y coordinate the selection bar was drawn at, Width was the width the selection bar was drawn at, Height was the height the selection bar was drawn at. Return value is not used.
</li></ul>
<p /> <ul>
<li> OnItemChosen(UTSimpleList SourceList, int SelectedIndex, int PlayerIndex) - This is called when an item within the list has been chosen. SourceList is the list that invoked the delegate, SelectedIndex is the new selection index, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnSelectionChange(UTSimpleList SourceList, int NewSelectedIndex) - This is called when the selection index changes. SourceList is the list that invoked the delegate, NewSelectedIndex is the new selection index.
</li></ul>
<p />
<h3><a name="UTSKELCONTROL_CANTILEVERBEAM"></a> UTSKELCONTROL_CANTILEVERBEAM </h3>
<p /> <ul>
<li> vector EntireBeamVelocity() - This returns the speed the entire beam is travelling at.
</li></ul>
<p />
<h3><a name="UTSKELCONTROL_TURRETCONSTRAINED"></a> UTSKELCONTROL_TURRETCONSTRAINED </h3>
<p /> <ul>
<li> OnTurretStatusChange(bool bIsMoving) - This is called when the turrets status has changed. bIsMoving is set true if the turret is considered to be moving.
</li></ul>
<p />
<h3><a name="UTSLOWVOLUME"></a> UTSLOWVOLUME </h3>
<p /> <ul>
<li> OnDeployableUsedUp(actor ChildDeployable) - This is the same as UTGame.UTDeployedActor.OnDeployableUsedUp().
</li></ul>
<p />
<h3><a name="UTTABPAGE.UC"></a> UTTABPAGE.UC </h3>
<p /> <ul>
<li> OnTick(float DeltaTime) - This is called on each tick. DeltaTime is the time, in seconds, between each tick event.
</li></ul>
<p />
<h3><a name="UTUIFRONTEND_BINDKEYS360"></a> UTUIFRONTEND_BINDKEYS360 </h3>
<p /> <ul>
<li> MarkDirty() - This is called to mark the profile as dirty.
</li></ul>
<p />
<h3><a name="UTUIFRONTEND_BINDKEYSPC"></a> UTUIFRONTEND_BINDKEYSPC </h3>
<p /> <ul>
<li> MarkDirty() - This is called to mark the profile as dirty.
</li></ul>
<p />
<h3><a name="UTUIFRONTEND_BINDKEYSPS3"></a> UTUIFRONTEND_BINDKEYSPS3 </h3>
<p /> <ul>
<li> MarkDirty() - This is called to mark the profile as dirty.
</li></ul>
<p />
<h3><a name="UTUIFRONTEND_BOTSELECTION"></a> UTUIFRONTEND_BOTSELECTION </h3>
<p /> <ul>
<li> OnAcceptedBots() - This is called when the user accepts their current bot selection set.
</li></ul>
<p />
<h3><a name="UTUIFRONTEND_SETTINGSPANELS"></a> UTUIFRONTEND_SETTINGSPANELS </h3>
<p /> <ul>
<li> OnMarkProfileDirty(optional bool bDirty = true) - This is called when the profile has been modified by something other than the user changing the value of an option. Set bDirty true to mark the profile as dirty.
</li></ul>
<p /> <ul>
<li> OnNotifyOptionChanged(UIScreenObject InObject, name OptionName, int PlayerIndex) - This is called when the user changes one of the options in an option list. InObject is the UIScreenObject that invoked this delegate, OptionName is the name of the option changed, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event. - UTUIFRONTEND_WEAPONPREFERENCE
</li></ul>
<p /> <ul>
<li> MarkDirty() - This is called to mark the profile as dirty.
</li></ul>
<p />
<h3><a name="UTUIMENULIST"></a> UTUIMENULIST </h3>
<p /> <ul>
<li> OnSubmitSelection(UIObject Sender, optional int PlayerIndex = GetBestPlayerIndex()) - This is called when the user presses enter or any other action button bound to UIKey_SubmitListSelection while this list has focus. Sender is the UIObject that invoked this delegate, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p />
<h3><a name="UTUIOPTIONLIST"></a> UTUIOPTIONLIST </h3>
<p /> <ul>
<li> OnOptionFocused(UIScreenObject InObject, UIDataProvider OptionProvider) - This is called when an option gains focus. InObject is the UIScreenObject which invoked this delegate, OptionProvider is the data provider for the option.
</li></ul>
<p /> <ul>
<li> OnOptionChanged(UIScreenObject InObject, name OptionName, int PlayerIndex) - This is called when an option has changed. InObject is the UIScreenObject which invoked this delegate, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnAcceptOptions(UIScreenObject InObject, int PlayerIndex) - This is called when the accept button was pressed on the option list. InObject is the UIScreenObject which invoked this delegate, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p />
<h3><a name="UTUIPANEL_MAPCYCLE"></a> UTUIPANEL_MAPCYCLE </h3>
<p /> <ul>
<li> OnMapSelected() - This is called when the user selects a map on this page.
</li></ul>
<p />
<h3><a name="UTUIPANEL_SINGLEMAP"></a> UTUIPANEL_SINGLEMAP </h3>
<p /> <ul>
<li> OnMapSelected() - This is called when the user selects a map on this page.
</li></ul>
<p />
<h3><a name="UTUIPRESSBUTTON"></a> UTUIPRESSBUTTON </h3>
<p /> <ul>
<li> OnBeginPress(UIScreenObject InObject, int InPlayerIndex) - This is called when the user just pressed the button. InObject is the UIScreenObject that invoked this delegate, InPlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnEndPress(UIScreenObject InObject, int InPlayerIndex) - This is called when the user just released the left mouse button on the button. InObject is the UIScreenObject that invoked this delegate, InPlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p />
<h3><a name="UTUISCENE"></a> UTUISCENE </h3>
<p /> <ul>
<li> OnShowAnimationEnded() - This is called when the scene's show animation has ended.
</li></ul>
<p /> <ul>
<li> OnHideAnimationEnded() - This is called when the scene's hide animation has ended.
</li></ul>
<p /> <ul>
<li> OnSceneOpened(UIScene OpenedScene, bool bInitialActivation) - This is called when the scene has opened after hiding the top most scene. OpenedScene is the scene that invoked this delegate, bInitialActivation is set true if this is the first time the opened scene has been activated.
</li></ul>
<p />
<h3><a name="UTUISCENE_MESSAGEBOX"></a> UTUISCENE_MESSAGEBOX </h3>
<p /> <ul>
<li> OnSelection(UTUIScene_MessageBox MessageBox, int SelectedOption, int PlayerIndex) - This is called when the user has made a selection from the choices available to them. MessageBox is the UTUIScene_MessageBox that invoked this function, SelectionOption is the selection chosen, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnClosed() - This is called after the message box has been completely closed.
</li></ul>
<p /> <ul>
<li> bool OnMBInputKey(const out InputEventParameters EventParms) - This is called when any input has been received by the message box. EventParams contains information about the input event. Return true if the input has been processed and does not require any more processing.
</li></ul>
<p />
<h3><a name="UTUISCENE_SAVEPROFILE"></a> UTUISCENE_SAVEPROFILE </h3>
<p /> <ul>
<li> OnSaveFinished() - This is called when the profile has finished saving.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_CHARACTERPART"></a> UTUITABPAGE_CHARACTERPART </h3>
<p /> <ul>
<li> transient OnPartSelected(ECharPart PartType, string InPartID) - This is called when the user selects a part on this page. PartType contains information about the part that was selected, PartID is the ID of said PartType.
</li></ul>
<p /> <ul>
<li> transient OnPreviewPartChanged(ECharPart PartType, string InPartID) - This is called when the user changes the selected part on this page. PartType contains information about the part that was selected, PartID is the ID of said PartType.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_FINDQUICKMATCH"></a> UTUITABPAGE_FINDQUICKMATCH </h3>
<p /> <ul>
<li> OnSearchComplete(bool bWasSuccessful) - This is called when the search has completed. bWasSuccessful is set true if the asynchronous call completed successfully.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_GAMEMODESELECTION"></a> UTUITABPAGE_GAMEMODESELECTION </h3>
<p /> <ul>
<li> OnGameModeSelected(string InGameMode, string InDefaultMap, string GameSettingsClass, bool bSelectionSubmitted) - This is called when the game mode gets selected from this page. InGameMode is the game mode selected, InDefaultMap is the default map for the game mode selected, GameSettingsClass is the class name of the game settings, bSelectionSubmitted is true if the selection was submitted.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_MAPSELECTION"></a> UTUITABPAGE_MAPSELECTION </h3>
<p /> <ul>
<li> OnMapSelected() - This is called when the user selects a map on this page.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_MUTATORS"></a> UTUITABPAGE_MUTATORS </h3>
<p /> <ul>
<li> OnAcceptMutators(string InEnabledMutators) - This is called when the user accepts the current set of mutators. InEnabledMutators is the list of mutators that have been accepted.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_OPTIONS"></a> UTUITABPAGE_OPTIONS </h3>
<p /> <ul>
<li> OnAcceptOptions(UIScreenObject InObject, int PlayerIndex) - This is called when the current options have been accepted. InObject is the UIScreenObject that invoked this delegate, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnOptionChanged(UIScreenObject InObject, name OptionName, int PlayerIndex) - This is called when one of the options on the page has changed. InObject is the UIScreenObject that invoked this delegate, OptionName is the name of the option, PlayerIndex is the index within Engine.GamePlayers pointing to the player who triggered the event.
</li></ul>
<p /> <ul>
<li> OnOptionFocused(UIScreenObject InObject, UIDataProvider OptionProvider) - This is called when one of the options gains focus. InObject is the UIScreenObject that invoked this delegate, OptionProvider is the data provider of the option that gained focus.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_SERVERBROWSER"></a> UTUITABPAGE_SERVERBROWSER </h3>
<p /> <ul>
<li> transient OnBack() - This is called when the user wants to go back.
</li></ul>
<p /> <ul>
<li> transient OnSwitchedGameType() - This is called when the user changes the game type using the combo box.
</li></ul>
<p /> <ul>
<li> transient OnPrepareToSubmitQuery(UTUITabPage_ServerBrowser Sender) - This is called when the user is about to submit a server query. Sender is the UTUITabPage_ServerBrowser that invoked this delegate.
</li></ul>
<p />
<h3><a name="UTUITABPAGE_SERVERFILTER"></a> UTUITABPAGE_SERVERFILTER </h3>
<p /> <ul>
<li> transient OnSwitchedGameType() - This is called when the user changes the game type.
</li></ul>
<p />
<h2><a name="TUTORIAL 12.1 - RANDOM EVENT MUTATOR, PART I: INTRODUCTION  INITIAL CLASS SETUP"></a> TUTORIAL 12.1 - RANDOM EVENT MUTATOR, PART I: INTRODUCTION &amp; INITIAL CLASS SETUP </h2>
<p />
Over this series of these tutorials, you will be creating a mutator which will create random events for the players in the match.
<p />
<strong>1.</strong>	Open up your favorite text editor and create a new file called UTMutator_RandomEvents.uc.
<p />
<strong>2.</strong>	Start by declaring the class for the script. Since we are making a mutator, we will subclass Mutator class found in Engine. Your first line should like this:
<p />
<font face=consolas>
<pre>
class UTMutator&#95;RandomEvent extends UTMutator;
</pre>
</font>
<p />
<strong>3.</strong>	Before continuing, we need to think of events that will make Unreal Tournament 3 more interesting. To save you some time, here are some that I have come up with.
<p /> <ul>
<li> All players receive a redeemer.
</li> <li> Check all the players and see if their current health is above 50 and if it is, give them some armor.
</li> <li> Force re spawning of all the items on the map.
</li></ul>
<p />
<strong>4.</strong>	Let's create our defaultproperties block as well. We don't have any global variables in our mutator, so it will look rather empty.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   Name&#61;”Default&#95;&#95;UTMutator&#95;RandomEvent”
}
</pre>
</font>
<p />
You can now compile this class.
<p />
<h2><a name="TUTORIAL 12.2 - RANDOM EVENT MUTATOR, PART II: TIMING LOGIC"></a> TUTORIAL 12.2 - RANDOM EVENT MUTATOR, PART II: TIMING LOGIC </h2>
<p />
From here we need to write the timing code. The mutator itself is responsible for triggering a random event every 60 seconds.
<p />
<strong>1.</strong>	To start off with, we will override the  PostBeginPlay() function. Remember that PostBeginPlay() is called when the level is initialized and ready to go, just before the game has started but after the game has loaded.
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
   super.PostBeginPlay();
}
</pre>
</font>
<p />
<strong>2.</strong>	We will use a timer to trigger the random events.
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
   super.PostBeginPlay();
   SetTimer(60.f, true);
}
</pre>
</font>
<p />
<strong>3.</strong>	Then create a new function called Timer, and write it out like so:
<p />
<font face=consolas>
<pre>
function Timer()
{
}
</pre>
</font>
<p />
When the mutator calls PostBeginPlay(), it will create and assign a new timer that will trigger every 60 seconds. The true argument is provided so that the timer will loop continuously until we tell it to stop. By default SetTimer() will call a function named Timer() within the instance that it was called from.
<p />
<h2><a name="TUTROIAL 12.3 - RANDOM EVENT MUTATOR, PART III: USING DELEGATES"></a> TUTROIAL 12.3 - RANDOM EVENT MUTATOR, PART III: USING DELEGATES </h2>
<p />
<strong>1.</strong>	Now we create our delegate function, and modify our Timer function.
<p />
<font face=consolas>
<pre>
delegate RandomEvent();

function Timer()
{
   RandomEvent();
}
</pre>
</font>
<p />
When the Timer() function is called, we will call our delegate RandomEvent().
<p />
<strong>2.</strong>	From here, we will create the three functions which handle the logic of each random event as described above. We will also handle the logic to alter which event gets run as well.
<p />
<font face=consolas>
<pre>
function GiveBonusArmor()
{
}

function GiveRedeemerToAll()
{
}

function ForceRespawn()
{
}
</pre>
</font>
<p />
<strong>3.</strong>	And we shall now alter our Timer() function which handles the random selection of events.
<p />
<font face=consolas>
<pre>
function Timer()
{
   switch (Rand(3))
   {
      case 0:
         RandomEvent &#61; GiveBonusArmor;
         break;

      case 1:
         RandomEvent &#61; GiveRedeemerToAll;
         break;

      case 2:
         RandomEvent &#61; ForceRespawn;
         break;

      default:
         RandomEvent &#61; GiveBonusArmor;
         break;
   }

   RandomEvent();
}
</pre>
</font>
<p />
As you can see, when ever Timer() gets called, we will run a random call within a switch. Depending on the results of the randomization, we will then assign RandomEvent() to one of the functions. We then call RandomEvent(), which will in turn calls the function that we've assigned the delegate to.
<p />
<h2><a name="TUTORIAL 12.4 - RANDOM EVENT MUTATOR, PART IV: GIVEBONUSARMOR()"></a> TUTORIAL 12.4 - RANDOM EVENT MUTATOR, PART IV: GIVEBONUSARMOR() </h2>
<p />
<strong>1.</strong>	Within the WorldInfo instance, there is an iterator function which allows us to iterate through all the existing pawns in the world. We will use this iterator to find all of the player pawns within the map. Let's modify the GiveBonusArmor() function, like so:
<p />
<font face=consolas>
<pre>
function GiveBonusArmor()
{
   local UTPawn P;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
   }
}
</pre>
</font>
<p />
Thus, when the GiveBonusArmor() function is run, it will start by iterating through all the pawns in the level that are of class UTPawn or a child class of UTPawn and output the result into our local variable P.
<p />
<strong>2.</strong>	So now, we need to filter out the pawns we get from the iterator to match the conditions that we want. The conditions were that pawns must have over 50 health in order to be given the bonus armor reward. Thus, we add the conditional if statement in, like so:
<p />
<font face=consolas>
<pre>
function GiveBonusArmor()
{
   local UTPawn P;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
      if (P !&#61; none &#38;&#38; P.Health &#62;&#61; 50)
      {
      }
   }
}
</pre>
</font>
<p />
Even though P should usually never be none when returned by the iterator, it is still good practice to check for none every time. This is a good habit to get into since the check does not cost that much and will prevent access none errors. Once we have checked for none, we then check that health of the pawn.
<p />
<strong>3.</strong>	In Unreal Tournament 3, there are three types of armor that players can have. We can reward the player more armor when he has more health.
<p />
<font face=consolas>
<pre>
function GiveBonusArmor()
{
   local UTPawn P;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
      if (P !&#61; none &#38;&#38; P.Health &#62;&#61; 50)
      {
         P.ThighpadArmor &#61; Max(class&#39;UTArmorPickup&#95;Thighpads&#39;.default.ShieldAmount, P.ThighpadArmor);

         if (P.Health &#62;&#61; 80)
            P.VestArmor &#61; Max(class&#39;UTArmorPickup&#95;Vest&#39;.default.ShieldAmount, P.VestArmor);

         if (P.Health &#62;&#61; 90)
            P.HelmetArmor &#61; Max(class&#39;UTArmorPickup&#95;Helmet&#39;.default.ShieldAmount, P.HelmetArmor);
      }
   }
}
</pre>
</font>
<p />
Thus we will always give players some thigh pads if they meet the first requirement of having over 50 health. If their health is above 80, then we reward some vest armor as well, and lastly, if their health is above 90, then we reward some helmet armor as well.
<p />
<strong>4.</strong>	Let's add some sound as well so that the player that received the bonus can hear something as well. Let's alter the function like so:
<p />
<font face=consolas>
<pre>
function GiveBonusArmor()
{
   local UTPawn P;
   local SoundCue S;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
      if (P !&#61; none &#38;&#38; P.Health &#62;&#61; 50)
      {
         P.ThighpadArmor &#61; Max(class&#39;UTArmorPickup&#95;Thighpads&#39;.default.ShieldAmount, P.ThighpadArmor);
         S &#61; class&#39;UTArmorPickup&#95;Thighpads&#39;.default.PickupSound;

         if (P.Health &#62;&#61; 80)
         {
            P.VestArmor &#61; Max(class&#39;UTArmorPickup&#95;Vest&#39;.default.ShieldAmount, P.VestArmor);
            S &#61; class&#39;UTArmorPickup&#95;Vest&#39;.default.PickupSound;
         }

         if (P.Health &#62;&#61; 90)
         {
            P.HelmetArmor &#61; Max(class&#39;UTArmorPickup&#95;Helmet&#39;.default.ShieldAmount, P.HelmetArmor);
            S &#61; class&#39;UTArmorPickup&#95;Helmet&#39;.default.PickupSound;
         }

         if (S !&#61; none)
            P.PlaySound(S);
      }
   }
}
</pre>
</font>
<p />
We added a local SoundCue variable, so we can set it when we give the armor. As the player meets the various requirements, the SoundCue gets set to the one we would like to play in the end. Lastly, we check if there was a sound cue assigned to our variable S (remember default variables do not necessarily have to hold a value other than none) and if there was we ask our bonused pawn to play the sound.
<p />
<h2><a name="TUTORIAL 12.5 - RANDOM EVENT MUTATOR, PART V: GIVEREDEEMERTOALL"></a> TUTORIAL 12.5 - RANDOM EVENT MUTATOR, PART V: GIVEREDEEMERTOALL </h2>
<p />
<strong>1.</strong>	Much like the GiveBonusArmor() function, this function too will start off with the function iterating through all of the pawns within the world. So let's start with that:
<p />
<font face=consolas>
<pre>
function GiveRedeemerToAll()
{
   locale UTPawn P;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
   }
}
</pre>
</font>
<p />
<strong>2.</strong>	Since all players just receive a redeemer, we don't need to actually write any conditions at all. We simply just give every one a redeemer. In order to do that, we would need to spawn a redeemer inventory item and then give it to each pawn. So, we need to spawn the redeemer and hold a reference in a variable so we can use it. So we'll modify the function, like so:
<p />
<font face=consolas>
<pre>
function GiveRedeemerToAll()
{
   local UTPawn P;
   local UTWeap&#95;Redeemer&#95;Content R;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
      R &#61; Spawn(class&#39;UTWeap&#95;Redeemer&#95;Content&#39;);
   }
}
</pre>
</font>
<p />
That won't quite accomplish much though. That'll just spawn redeemers in the middle of no where, where perhaps one lucky person might stumble across them all (although probably not, since players pick up weapon pick ups and not the weapon itself!).
<p />
<strong>3.</strong>	So now that we've spawned a redeemer, we need to give it to a player. First of all, we should in fact check if there is indeed a player to give the redeemer to. Since we will check for a pawn's existence, we may as well check if it is a valid pawn too. Lastly, we might as well spawn the redeemer with the appropriate parameters.
<p />
<font face=consolas>
<pre>
function GiveRedeemerToAll()
{
   local UTPawn P;
   local UTWeap&#95;Redeemer&#95;Content R;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
      if (P !&#61; none &#38;&#38; P.bCanPickupInventory &#38;&#38; P.Health &#62; 0 &#38;&#38; P.Controller !&#61; none)
         R &#61; Spawn(class&#39;UTWeap&#95;Redeemer&#95;Content&#39;, P,, P.Location, P.Rotation);
   }
}
</pre>
</font>
<p />
The conditionals look pretty complex, so let's walk through them:
<p /> <ul>
<li> Is P none or not?
</li> <li> Is P able to pickup inventory items or not?
</li> <li> Does P have any health?
</li> <li> Does P have a valid controller?
</li></ul>
<p />
<strong>4.</strong>	We can finally give the redeemer to the player now. This is done like so:
<p />
<font face=consolas>
<pre>
function GiveRedeemerToAll()
{
   local UTPawn P;
   local UTWeap&#95;Redeemer&#95;Content R;

   foreach WorldInfo.AllPawns(class&#39;UTPawn&#39;, P)
   {
      if (P !&#61; none &#38;&#38; P.bCanPickupInventory &#38;&#38; P.Health &#62; 0 &#38;&#38; P.Controller !&#61; none)
      {
         R &#61; Spawn(class&#39;UTWeap&#95;Redeemer&#95;Content&#39;, P,, P.Location, P.Rotation);

         if (R !&#61; none)
         {
            if (WorldInfo.Game.PickupQuery(P, class&#39;UTWeap&#95;Redeemer&#95;Content&#39;, R))
               R.GiveTo(P);
            else
               R.Destroy();
         }
      }
   }
}
</pre>
</font>
<p />
Again we check to see if R was actually spawned or not. Sometimes a spawn can fail for various reasons, so it is possible that R could be none. To avoid any access none errors, we check for the validity of R. We finally do one last check, and the check verifies whether the pawn is able to pick up a redeemer or not. If the pawn is able to, then we give it to the pawn, otherwise we destroy the spawned redeemer.
<p />
<h2><a name="TUTORIAL 12.6 - RANDOM EVENT MUTATOR, PART VI: FORCERESPAWN"></a> TUTORIAL 12.6 - RANDOM EVENT MUTATOR, PART VI: FORCERESPAWN </h2>
<p />
<strong>1.</strong>	One of the first things we should do, is to create a dynamic array and fill it up with pickup factory references. So, let's begin by adding a global dynamic array to our mutator class.
<p />
<font face=consolas>
<pre>
class UTMutator&#95;RandomEvent extends UTMutator;

private var array&#60;UTPickupFactory&#62; PickupFactories;
</pre>
</font>
<p />
The reason why we make this global variable private is that we don't really want other classes to be able to alter the array.
<p />
<strong>2.</strong>	Now that we have a global variable to store pickup factory references, we then alter PostBeginPlay() so that we fill up this dynamic array.
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
   local UTPickupFactory pickup&#95;factory;

   super.PostBeginPlay();
   SetTimer(60.f, true);

   foreach AllActors(class&#39;UTPickupFactory&#39;, pickup&#95;factory)
   {
   }
}
</pre>
</font>
<p />
This will now iterate the entire level for all actors that are either a UTPickupFactory or a subclass of it.
<p />
<strong>3.</strong>	Within this iteration we should store each result after validating it.
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
   local UTPickupFactory pickup&#95;factory;

   super.PostBeginPlay();
   SetTimer(60.f, true);

   foreach AllActors(class&#39;UTPickupFactory&#39;, pickup&#95;factory)
   {
      if (pickup&#95;factory !&#61; none)
         PickupFactories.AddItem(pickup&#95;factory);
   }
}
</pre>
</font>
<p />
Now we have setup a dynamic array of pick up factories for us to use. The reason why we do this, is because the AllActors iterator is quite slow. And doing it every time we want to force respawn is pointless.
<p />
<strong>4.</strong>	Now we write our ForceRespawn function.
<p />
<font face=consolas>
<pre>
function ForceRespawn()
{
   local int i;

   for (i &#61; 0; i &#60; PickupFactories.length; ++i)
   {
   }
}
</pre>
</font>
<p />
<strong>5.</strong>	And finally we tell all of the pickup factories to reset themselves.
<p />
<font face=consolas>
<pre>
function ForceRespawn()
{
   locale int i;

   for (i &#61; 0; i &#60; PickupFactories.length; ++i)
      if (PickupFactories&#91;i] !&#61; none)
         PickupFactories&#91;i].Reset();
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.7 - RANDOM EVENT MUTATOR, TESTING"></a> TUTORIAL 12.7 - RANDOM EVENT MUTATOR, TESTING </h2>
<p />
<strong>1.</strong>	Compile the code, and then start up Unreal Tournament 3.
<p />
<strong>2.</strong>	Log in or choose to play offline.
<p />
<strong>3.</strong>	Then, select an Instant Action game.
<p />
<strong>4.</strong>	Choose Deathmatch as the gametype and select any map you choose.
<p />
<strong>5.</strong>	Go to the Settings panel and press the Mutators button
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_001.jpg"/><br/> <strong><font color=blue>Figure 12.1 – The Mutators button takes you to the Mutator selection and configuration screen.</font></strong>
<p />
<strong>6.</strong>	Add the UTMutator_RandomEvent mutator to the list of Enabled Mutators.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_002.jpg"/><br/> <strong><font color=blue>Figure 12.2 – The mutator is has been added.</font></strong>
<p />
<strong>7.</strong>	Wait for a while and you may get one of the three random events occurring. In this case, the shield reward was given.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_003.jpg"/><br/> <strong><font color=blue>Figure 12.3 – The shield reward has been given to the player.</font></strong>
<p />
In this tutorial we looked at how to create and use delegates in a single instance. In this situation it's very easy to extend this Mutator to make more events that could occur over time. Since we don't need to worry too much about the maintenance of the timing logic, this is quite a flexible way of doing things.
<p />
<h2><a name="TUTORIAL 12.8 - WEAPON MUTATOR, PART I: INTRODUCTION  INITAL CLASS SETUP"></a> TUTORIAL 12.8 - WEAPON MUTATOR, PART I: INTRODUCTION &amp; INITAL CLASS SETUP </h2>
<p />
In this tutorial we will be making a weapon which the player can change the fire type. Each fire type mimics an existing weapon being the rocket launcher, flak cannon, shock rifle and the bio rifle. The rocket launcher style results in an instant hit explosive. The flak cannon results in an instant hit explosive that also launches some flak. The shock rifle style results in an instant hit shock combo. The bio rifle style results in an instant hit goo explosive that also drops some goo blobs.
<p />
<strong>1.</strong>	Start by creating new Unrealscript files in the ..\MasteringUnrealScript\Classes folder called UTWeap_MultiEnforcer.uc, MultiEnforcer_Base.uc, MultiEnforcer_Bio.uc, MultiEnforcer_Flak.uc, MultiEnforcer_Rocket.uc and MultiEnforcer_Shock.uc.
<p />
<strong>2.</strong>	Declare our class and default properties for UTWeap_MultiEnforcer. We are sub classing from UTWeap_Enforcer as we want to do as little work as possible in setting up a new weapon.
<p />
<font face=consolas>
<pre>
class UTWeap&#95;MultiEnforcer extends UTWeap&#95;Enforcer

defaultproperties
{
   Name&#61;”Default&#95;&#95; UTWeap&#95;MultiEnforcer”
}
</pre>
</font>
<p />
<strong>3.</strong>	Declare our class and default properties for MultiEnforcer_Base.
<p />
<font face=consolas>
<pre>
class MultiEnforcer&#95;Base extends Object;

defaultproperties
{
   Name&#61;”Default&#95;&#95;MultiEnforcer&#95;Base&#34;
}
</pre>
</font>
<p />
<strong>4.</strong>	Declare our class and default properties for MultiEnforcer_Bio. We are sub classing from MultiEnforcer_Base because the base functionality is handled within MultiEnforcer_Base.
<p />
<font face=consolas>
<pre>
class MultiEnforcer&#95;Bio extends MultiEnforcer&#95;Base;

defaultproperties
{
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Bio&#34;
}
</pre>
</font>
<p />
<strong>5.</strong>	Declare our class and default properties for MultiEnforcer_Flak.
<p />
<font face=consolas>
<pre>
class MultiEnforcer&#95;Flak extends MultiEnforcer&#95;Base;

defaultproperties
{
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Flak&#34;
}
</pre>
</font>
<p />
<strong>6.</strong>	Declare our class and default properties for MultiEnforcer_Rocket.
<p />
<font face=consolas>
<pre>
class MultiEnforcer&#95;Rocket extends MultiEnforcer&#95;Base;

defaultproperties
{
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Rocket&#34;
}
</pre>
</font>
<p />
<strong>7.</strong>	Declare our class and default properties for MultiEnforcer_Shock.
<p />
<font face=consolas>
<pre>
class MultiEnforcer&#95;Shock extends MultiEnforcer&#95;Base;

defaultproperties
{
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Shock&#34;
}
</pre>
</font>
<p />
<strong>8.</strong>	Save all of the new scripts.
<p />
<h2><a name="TUTORIAL 12.9 - WEAPON MUTATOR, PART II: SETTING UP UTWEAP_MULTIENFORCER"></a> TUTORIAL 12.9 - WEAPON MUTATOR, PART II: SETTING UP UTWEAP_MULTIENFORCER </h2>
<p />
This class represents the weapon itself, and handles almost everything related to the weapon. This includes the visuals such as displaying the mesh so it looks like the weapon is being held by the player, the sound effects created by the weapon and the management of weapon firing and so forth. Since we have sub classed from UTWeap_Enforcer the majority of the work has already been done for us. This gives us a lot of time to focus on just changing the behavior of the weapon to what we'd like to do with it.
<p />
<strong>1.</strong>	This weapon is going to be dependent on the four firing classes, MultiEnforcer_Bio, MultiEnforcer_Flak, MultiEnforcer_Rocket and MultiEnforcer_Shock. Since they all are subclasses of MultiEnforcer_Base, we can just set the dependency to MultiEnforcer_Base.
<p />
<font face=consolas>
<pre>
class UTWeap&#95;MultiEnforcer extends UTWeap&#95;Enforcer
   dependson(MultiEnforcer&#95;Base);
</pre>
</font>
<p />
<strong>2.</strong>	We will need to hold a few global variables to store data about our fire types.
<p />
<font face=consolas>
<pre>
var private array&#60;MultiEnforcer&#95;Base&#62; FireTypes;
var private int CurrentIndex;
var const array&#60; class&#60;MultiEnforcer&#95;Base&#62; &#62; FireTypeClasses;
</pre>
</font>
<p />
FireTypes is a private array which will hold object instances of MultiEnforcer_Base. FireTypes can also hold any child classes of MultiEnforcer_Base as well. FireTypes is private because we want to block access to other classes. CurrentIndex is an integer which holds what the current index within FireTypes. We use CurrentIndex to set which fire type the player wants to use. CurrentIndex is private because we want to block access to other classes. FireTypeClasses is an array which holds the classes of fire types that the weapon is able to use. FireTypeClasses is constant because this array doesn't need to be modified during run time. Note the spaces between the &gt;'s. This space is required as the Unrealscript compiler will generate an error otherwise.
<p />
<strong>3.</strong>	Let's add some definitions to our default properties.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   CurrentIndex&#61;0
   FireTypeClasses(0)&#61;class&#39;MultiEnforcer&#95;Rocket&#39;
   FireTypeClasses(1)&#61;class&#39;MultiEnforcer&#95;Shock&#39;
   FireTypeClasses(2)&#61;class&#39;MultiEnforcer&#95;Flak&#39;
   FireTypeClasses(3)&#61;class&#39;MultiEnforcer&#95;Bio&#39;
   InventoryGroup&#61;3
   ItemName&#61;&#34;MultiEnforcer&#34;
   PickupMessage&#61;&#34;MultiEnforcer&#34;
   FiringStatesArray(1)&#61;&#34;WeaponSwitching&#34;
   Name&#61;&#34;Default&#95;&#95;UTWeap&#95;MultiEnforcer&#34;
   ObjectArchetype&#61;UTWeap&#95;Enforcer&#39;UTGame.Default&#95;&#95;UTWeap&#95;Enforcer&#39;
}
</pre>
</font>
<p />
CurrentIndex is initially set to zero. FireTypeClasses has all of the array items defined here as it is constant during run time. InventoryGroup is a variable that is defined in the parent class, and it determines which group this weapon is in. ItemName is the name of the weapon. PickupMessage is the message given when picking up the weapon, in this case we just call it MultiEnforcer anyways. FiringStatesArray are the list of state names that a weapon will initiate when firing a fire mode. We will make a new secondary firing state called WeaponSwitching, hence why we have put it in here. Name is the name of this object, which we can reference to in other classes. ObjectArchetype is this object's parental class from which we can derive most of our other default properties from.
<p />
<strong>4.</strong>	Let's start by writing our PostBeginPlay() function which will handle the initial setup of the weapon.
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
   super.PostBeginPlay();
}
</pre>
</font>
<p />
<strong>5.</strong>	For this weapon to work properly, we will need to create instances of our fire type objects within PostBeginPlay().
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
   local int i;

   super.PostBeginPlay();

   if (FireTypeClasses.length &#62; 0)
   {
      for (i &#61; 0; i &#60; FireTypeClasses.length; ++i)
         if (FireTypeClasses&#91;i] !&#61; none)
            FireTypes.AddItem(new FireTypeClasses&#91;i]);
   }
}
</pre>
</font>
<p />
We first check if the FireTypeClasses array has any items in it. If there aren't any, theres no real reason to carry on is there? From there, we just iterate through the array and create new object instances of each fire type while adding them into our FireTypes array. We use the keyword new here, as these classes are ultimately derived from object and not Actor (which we would then use Spawn()).
<p />
<strong>6.</strong>	Because we will eventually bind to our fire type objects using delegates, we will need to clean that up in way that won't leak memory. Refer to 12.5 where delegates and memory was discussed. So we will also override the Destroyed() function. Destroyed() is called automatically when the instance has been destroyed using Destroy(), or when the instance is destroyed by Unreal Engine.
<p />
<font face=consolas>
<pre>
simulated function Destroyed()
{
   super.Destroyed();
}
</pre>
</font>
<p />
<strong>7.</strong>	Since we cannot destroy object instances, all we need to do is to remove any references to them so that Unreal Engine can garbage collect them and then delete them from memory.
<p />
<font face=consolas>
<pre>
simulated function Destroyed()
{
   local int i;

   super.Destroyed();

   if (FireTypes.length &#62; 0)
   {
      for (i &#61; 0; i &#60; FireTypes.length; ++i)
         FireTypes&#91;i] &#61; none;
   }
}
</pre>
</font>
<p />
<strong>8.</strong>	Now that we've handled the issue of memory, we then progress to altering the way the weapon will fire. The Enforcer is set as an hit scan weapon, thus it will call ProcessInstantHit() when the weapon has completed a trace. We override this, to have add new logic to how our weapon will act when a hit needs to be processed.
<p />
<font face=consolas>
<pre>
simulated function ProcessInstantHit(byte FiringMode, ImpactInfo Impact)
{
}
</pre>
</font>
<p />
In this particular case, we do not add a super call here because we do not require the parents logic to occur.
<p />
<strong>9.</strong>	Let's declare our delegate now. This delegate will be called when the weapon needs to process a hit.
<p />
<font face=consolas>
<pre>
delegate OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact);

simulated function ProcessInstantHit(byte FiringMode, ImpactInfo Impact)
{
   OnProcessInstantHit(self, FiringMode, Impact);
}
</pre>
</font>
<p />
<strong>10.</strong>	Now that we have handled what happens when this weapon is fired, we can now tackle the task of adding the code which handles how the player changes between fire types. Remember in our default properties when we added a line that changed the second firing state to WeaponSwitching? This default property is the name of the state the weapon goes in when the secondary fire mode is activated. Since this is typically bound to the right mouse button, we will use this to handle how the player changes between fire types.
<p />
<font face=consolas>
<pre>
simulated state WeaponSwitching
{
}
</pre>
</font>
<p />
<strong>11.</strong>	We will need to do some house keeping inside this state, so we'll just add in the same subset of functions inside WeaponBursting inside UTWeap_Enforcer.
<p />
<font face=consolas>
<pre>
simulated state WeaponSwitching
{
   simulated function TrackShotCount();

   simulated function RefireCheckTimer();

   simulated function bool TryPutDown()
   {
      bWeaponPutDown &#61; true;
      return true;
   }
}
</pre>
</font>
<p />
<strong>12.</strong>	Weapons use timers to handle animation. Timers allow us to create an event based architecture inside Unrealscript without having to resort to expensive tracking within Tick() for example. What we would like to happen when a player changes fire type, is for the player to put down his enforcer and then reload it again by putting in a new clip. Luckily for us, Unreal Tournament 3 has such an animation with the enforcer.
<p />
<font face=consolas>
<pre>
simulated state WeaponSwitching
{
   simulated function TrackShotCount();

   simulated function RefireCheckTimer();

   simulated function bool TryPutDown()
   {
      bWeaponPutDown &#61; true;
      return true;
   }

   simulated function BeginState(name PrevStateName)
   {
      TimeWeaponPutDown();
   }
}
</pre>
</font>
<p />
TimeWeaponPutDown() is a function that exists in the parent classes. It sets a timer to trigger as well as playing the weapon put down animation. This function is implemented within UTWeapon and Weapon. In short, it handles the animation for putting down the weapon, and when the animation is finished, WeaponIsDown() will be called.
<p />
<strong>13.</strong>	Now that we know that WeaponIsDown() will be triggered once the weapon has been put down, we then want the weapon to come back up with a reloading animation. During this stage, we need to also handle the fire type changing state.
<p />
<font face=consolas>
<pre>
simulated state WeaponSwitching
{
   simulated function TrackShotCount();
   simulated function RefireCheckTimer();

   simulated function bool TryPutDown()
   {
      bWeaponPutDown &#61; true;
      return true;
   }

   simulated function WeaponIsDown()
   {
      ClearTimer(&#39;WeaponIsDown&#39;);
      bLoaded &#61; false;
      TimeWeaponEquipping();
      CurrentIndex++;

      if (CurrentIndex &#62;&#61; FireTypes.length)
         CurrentIndex &#61; 0;

      AssignFireType();
   }

   simulated function BeginState(name PrevStateName)
   {
      TimeWeaponPutDown();
   }
}
</pre>
</font>
<p />
Here we have added a WeaponIsDown() function which is specific for this state. As soon as that function is called, we clear the timer associated with this function. bLoaded is set to false because in UTWeap_Enforcer, when this is set to false the weapon reloading animation is played. We then call TimeWeaponEquipping() which is the same as TimeWeaponPutDown(), in that it will also play an animation and will trigger a function based on a timer. This function is called WeaponEquipped(). We also increment the CurrentIndex variable to shift the index of which fire type we are using. We reset CurrentIndex when it is greater or equal to the length of the FireTypes array. This will create a looping selection system for the player to use. We then call an undefined function called AssignFireType(). I did this portion inside another function because it is possible that we may need to handle assigning the fire type based on CurrentIndex in different places.
<p />
<strong>14.</strong>	Finally, once the weapon reloading animation is done, we should then go back into the active state. If we do not do this, then the weapon will be stuck in this state forever and will never be able to fire again.
<p />
<font face=consolas>
<pre>
simulated state WeaponSwitching
{
   simulated function TrackShotCount();
   simulated function RefireCheckTimer();

   simulated function bool TryPutDown()
   {
      bWeaponPutDown &#61; true;
      return true;
   }

   simulated function WeaponIsDown()
   {
      ClearTimer(&#39;WeaponIsDown&#39;);
      bLoaded &#61; false;
      TimeWeaponEquipping();
      CurrentIndex++;

      if (CurrentIndex &#62;&#61; FireTypes.length)
         CurrentIndex &#61; 0;

      AssignFireType();
   }

   simulated function WeaponEquipped()
   {
      ClearTimer(&#39;WeaponEquipped&#39;);
      bLoaded &#61; true;
      GotoState(&#39;Active&#39;);
   }

   simulated function BeginState(name PrevStateName)
   {
      TimeWeaponPutDown();
   }
}
</pre>
</font>
<p />
And thus we added a new function called WeaponEquipped() which simply clears the timer associated with it, sets bLoaded to true (this is so that if the player switches to another weapon and switches back to this, we won't replay the reloading animation), and then goes to the Active state.
<p />
<strong>15.</strong>	We should now define our AssignFireType() function. All this function does, is check that the CurrentIndex is valid to be used as an index within FireTypes and if the FireType that CurrentIndex is pointing to, is valid or not.
<p />
<font face=consolas>
<pre>
function AssignFireType()
{
   if (CurrentIndex &#62;&#61; 0 &#38;&#38; CurrentIndex &#60; FireTypes.length &#38;&#38; FireTypes&#91;CurrentIndex] !&#61; none &#38;&#38; FireTypes&#91;CurrentIndex].WeaponClass !&#61; none)
   {
   }
}
</pre>
</font>
<p />
<strong>16.</strong>	It's all well and good that we check that, but in order for this to have any real effect we need to assign to our delegate here.
<p />
<font face=consolas>
<pre>
function AssignFireType()
{
   if (CurrentIndex &#62;&#61; 0 &#38;&#38; CurrentIndex &#60; FireTypes.length &#38;&#38; FireTypes&#91;CurrentIndex] !&#61; none &#38;&#38; FireTypes&#91;CurrentIndex].WeaponClass !&#61; none)
      OnProcessInstantHit &#61; FireTypes&#91;CurrentIndex].OnProcessInstantHit;
}
</pre>
</font>
<p />
Remember that when the weapon is first created, even though our CurrentIndex is zero, the weapon hasn't been assigned to any of the fire types. Thus, in our PostBeginPlay() function, we also make a call to AssignFireType() to do this.
<p />
<font face=consolas>
<pre>
simulated function PostBeginPlay()
{
   local int i;

   super.PostBeginPlay();

   if (FireTypeClasses.length &#62; 0)
   {
      for (i &#61; 0; i &#60; FireTypeClasses.length; ++i)
         if (FireTypeClasses&#91;i] !&#61; none)
            FireTypes.AddItem(new FireTypeClasses&#91;i]);
   }

   AssignFireType();
}
</pre>
</font>
<p />
<strong>17.</strong>	We've now completed all the logic we require. However, we don't really have anything which will inform the player what fire type this weapon is set to. Luckily for us, it appears that Weapon has created hooks for us to use to allow us to draw things onto the HUD.
<p />
<font face=consolas>
<pre>
simulated function ActiveRenderOverlays(HUD H)
{
   super.ActiveRenderOverlays(H);
}
</pre>
</font>
<p />
<strong>18.</strong>	To allow the player to know what fire type is selected, we will draw an icon of the weapon that the fire type mimics. Where we will draw this icon is on the HUD where the ammo clip is. This means that we'll need to get the bone location of the ammo clip, project it onto the HUD to get valid HUD coordinates, and then we can render it. First of all, we need to get access to the skeletal mesh component of the first person mesh.
<p />
<font face=consolas>
<pre>
simulated function ActiveRenderOverlays(HUD H)
{
   local SkeletalMeshComponent SkelMesh;

   super.ActiveRenderOverlays(H);

   if (H !&#61; none &#38;&#38; H.Canvas !&#61; none)
   {
      SkelMesh &#61; SkeletalMeshComponent(Mesh);

      if (SkelMesh !&#61; none)
      {
      }
   }
}
</pre>
</font>
<p />
<strong>19.</strong>	Now that we the skeletal mesh, we get the location of the bone named Bullet5 (If you start Unreal Editor and view the skeletal mesh inside the Animation Editor, you can find out the names of bones in there) and project onto the HUD. Calculating the best width and height by doing a percentage based on the resolution will give us the best results when drawing the icon. After centering the icon based on the position calculated earlier, we then draw the icon on the screen. Weapon classes contain the coordinates of the icon, which itself is stored within a composite icon texture.
<p />
<font face=consolas>
<pre>
simulated function ActiveRenderOverlays(HUD H)
{
   local SkeletalMeshComponent SkelMesh;
   local vector BoneLocation;
   local float i&#95;w;
   local float i&#95;h;
   local color CanvasColor;

   super.ActiveRenderOverlays(H);

   if (H !&#61; none &#38;&#38; H.Canvas !&#61; none)
   {
      SkelMesh &#61; SkeletalMeshComponent(Mesh);

      if (SkelMesh !&#61; none)
      {
         BoneLocation &#61; H.Canvas.Project(SkelMesh.GetBoneLocation(&#39;Bullet5&#39;, 0));
         i&#95;w &#61; H.Canvas.ClipX &#42; 0.05f;
         i&#95;h &#61; H.Canvas.ClipY &#42; 0.05f;

         CanvasColor &#61; H.Canvas.DrawColor;
         H.Canvas.DrawColor &#61;  class&#39;UTHUD&#39;.default.WhiteColor;
         H.Canvas.SetPos(BoneLocation.x - (i&#95;w &#42; 0.5f), BoneLocation.y - (i&#95;h &#42; 0.5f));
         H.Canvas.DrawTile(class&#39;UTHUD&#39;.default.IconHudTexture, i&#95;w, i&#95;h, FireTypes&#91;CurrentIndex].WeaponClass.default.IconCoordinates.U, FireTypes&#91;CurrentIndex].WeaponClass.default.IconCoordinates.V, FireTypes&#91;CurrentIndex].WeaponClass.default.IconCoordinates.UL, FireTypes&#91;CurrentIndex].WeaponClass.default.IconCoordinates.VL);
         H.Canvas.DrawColor &#61; CanvasColor;
      }
   }
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.10 – WEAPON MUTATOR, PART III: MULTIENFORCER_BASE"></a> TUTORIAL 12.10 – WEAPON MUTATOR, PART III: MULTIENFORCER_BASE </h2>
<p />
The base class itself isn't very complex at all. After all, it's just a base class for other classes to sub class.
<p />
<strong>1.</strong>	When UTWeap_MultiEnforcer wants to render the icon on the screen, you'll notice that it asks the fire type for a weapon class. We'll define it as a global constant variable so that the subclasses can define it in their default properties.
<p />
<font face=consolas>
<pre>
var const class&#60;UTWeapon&#62; WeaponClass;
</pre>
</font>
<p />
<strong>2.</strong>	We also need to define the function which UTWeap_MultiEnforcer uses to assign to its delegate.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact);
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.11 – WEAPON MUTATOR, PART IV: MULTIENFORCER_BIO"></a> TUTORIAL 12.11 – WEAPON MUTATOR, PART IV: MULTIENFORCER_BIO </h2>
<p />
This is the bio fire type. When the bullet hits anything, it creates a small bio goo explosion and will drop some bio goo.
<p />
<strong>1.</strong>	First we set WeaponClass in the default properties.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   WeaponClass&#61;class&#39;UTWeap&#95;BioRifle&#95;Content&#39;
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Bio&#34;
}
</pre>
</font>
<p />
<strong>2.</strong>	Now we override the OnProcessInstantHit() function.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	First we need to check if we've got a valid HitActor from the impact.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   if (Impact.HitActor !&#61; none)
   {
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	Let's start by creating the explosion particle effect.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;BioRifle.Particles.P&#95;WP&#95;Bio&#95;Alt&#95;Blob&#95;POP&#39;);
   }
}
</pre>
</font>
<p />
We use the Weapon to spawn our EmitterSpawnable because the Spawn() function is available within Actor and not Object.
<p />
<strong>5.</strong>	Then we add in the explosion sound.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;BioRifle.Weapon.A&#95;BioRifle&#95;FireAltImpactExplode&#95;Cue&#39;,,,, Impact.HitLocation);
      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;BioRifle.Particles.P&#95;WP&#95;Bio&#95;Alt&#95;Blob&#95;POP&#39;);
   }
}
</pre>
</font>
<p />
<strong>6.</strong>	Next we add in some radial damage.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;BioRifle.Weapon.A&#95;BioRifle&#95;FireAltImpactExplode&#95;Cue&#39;,,,, Impact.HitLocation);
      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;BioRifle.Particles.P&#95;WP&#95;Bio&#95;Alt&#95;Blob&#95;POP&#39;);

      Weapon.HurtRadius(class&#39;UTProj&#95;BioGlob&#39;.default.Damage, class&#39;UTProj&#95;BioGlob&#39;.default.DamageRadius, class&#39;UTProj&#95;BioGlob&#39;.default.MyDamageType, class&#39;UTProj&#95;BioGlob&#39;.default.MomentumTransfer, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
<strong>7.</strong>	Lastly we spawn in some bio goo to complete the fire type.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local int g;
   local UTProj&#95;BioShot NewGlob;
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;BioRifle.Weapon.A&#95;BioRifle&#95;FireAltImpactExplode&#95;Cue&#39;,,,, Impact.HitLocation);
      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;BioRifle.Particles.P&#95;WP&#95;Bio&#95;Alt&#95;Blob&#95;POP&#39;);

      for (g &#61; 0; g &#60; 6; ++g)
      {
         NewGlob &#61; Weapon.Spawn(class&#39;UTProj&#95;BioGlobling&#39;,,, Impact.HitLocation);

         if (NewGlob !&#61; None)
            NewGlob.Velocity &#61; (FRand() &#42; 150.f) &#42; (VRand() &#42; 0.8f);
      }

      Weapon.HurtRadius(class&#39;UTProj&#95;BioGlob&#39;.default.Damage, class&#39;UTProj&#95;BioGlob&#39;.default.DamageRadius, class&#39;UTProj&#95;BioGlob&#39;.default.MyDamageType, class&#39;UTProj&#95;BioGlob&#39;.default.MomentumTransfer, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.12 - WEAPON MUTATOR, PART V: MULTIENFORCER_FLAK"></a> TUTORIAL 12.12 - WEAPON MUTATOR, PART V: MULTIENFORCER_FLAK </h2>
<p />
This is the flak fire type. When the bullet hits anything, it creates a flak shell explosion and sends flak flying all over the place.
<p />
<strong>1.</strong>	First we set WeaponClass variable in the default properties.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   WeaponClass&#61;class&#39;UTWeap&#95;FlakCannon&#39;
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Flak&#34;
}
</pre>
</font>
<p />
<strong>2.</strong>	Now we override the OnProcessInstantHit() function.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	First we need to check if we've got a valid HitActor from the impact.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   if (Impact.HitActor !&#61; none)
   {
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	We'll start by adding in the explosion particle effect.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;FlakCannon.Effects.P&#95;WP&#95;Flak&#95;Alt&#95;Explosion&#39;);
   }
}
</pre>
</font>
<p />
We use the Weapon to spawn our EmitterSpawnable because the Spawn() function is available within Actor and not Object.
<p />
<strong>5.</strong>	We then add in the sound to be played back.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;FlakCannon.Weapons.A&#95;FlakCannon&#95;FireAltImpactExplodeCue&#39;,,,, Impact.HitLocation);

   if (Impact.HitActor !&#61; none)
   {
      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;FlakCannon.Effects.P&#95;WP&#95;Flak&#95;Alt&#95;Explosion&#39;);
   }
}
</pre>
</font>
<p />
<strong>6.</strong>	Next we add in the radial damage.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;FlakCannon.Weapons.A&#95;FlakCannon&#95;FireAltImpactExplodeCue&#39;,,,, Impact.HitLocation);

   if (Impact.HitActor !&#61; none)
   {
      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;FlakCannon.Effects.P&#95;WP&#95;Flak&#95;Alt&#95;Explosion&#39;);
   }

   Weapon.HurtRadius(class&#39;UTProj&#95;FlakShell&#39;.default.Damage, class&#39;UTProj&#95;FlakShell&#39;.default.DamageRadius, class&#39;UTProj&#95;FlakShell&#39;.default.MyDamageType, class&#39;UTProj&#95;FlakShell&#39;.default.MomentumTransfer, Impact.HitLocation);
}
</pre>
</font>
<p />
<strong>7.</strong>	Finally, we'll spawn some random flak chunks to go flying all over the place. To do this, we setup a small iterator so that we spawn five flak projectiles.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local int i;
   local UTProj&#95;FlakShard NewChunk;
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;FlakCannon.Weapons.A&#95;FlakCannon&#95;FireAltImpactExplodeCue&#39;,,,, Impact.HitLocation);

      es &#61; Weapon.Spawn(class&#39;EmitterSpawnable&#39;,,, Impact.HitLocation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;FlakCannon.Effects.P&#95;WP&#95;Flak&#95;Alt&#95;Explosion&#39;);

      for (i &#61; 0; i &#60; 5; ++i)
      {
         NewChunk &#61; Weapon.Spawn(class&#39;UTProj&#95;FlakShard&#39;,,, Impact.HitLocation);

         if (NewChunk !&#61; None)
         {
            NewChunk.bCheckShortRangeKill &#61; false;
            NewChunk.Init((FRand() &#42; 150.f) &#42; (VRand() &#42; 0.8f));
         }
      }

      Weapon.HurtRadius(class&#39;UTProj&#95;FlakShell&#39;.default.Damage, class&#39;UTProj&#95;FlakShell&#39;.default.DamageRadius, class&#39;UTProj&#95;FlakShell&#39;.default.MyDamageType, class&#39;UTProj&#95;FlakShell&#39;.default.MomentumTransfer, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.13 - WEAPON MUTATOR, PART VI: MULTIENFORCER_ROCKET"></a> TUTORIAL 12.13 - WEAPON MUTATOR, PART VI: MULTIENFORCER_ROCKET </h2>
<p />
This is the rocket fire type. When the bullet hits anything, it creates a powerful explosion.
<p />
<strong>1.</strong>	First we set WeaponClass in the default properties.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   WeaponClass&#61;class&#39;UTWeap&#95;RocketLauncher&#39;
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Rocket&#34;
}
</pre>
</font>
<p />
<strong>2.</strong>	Now we override the OnProcessInstantHit() function.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	First we need to check if we've got a valid HitActor from the impact.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   if (Impact.HitActor !&#61; none)
   {
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	Spawn in our explosion particle effect.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      es &#61; Weapon.Spawn(class&#39;Engine.EmitterSpawnable&#39;,,, Impact.HitLocation, Rotator(Impact.HitNormal));

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;RocketLauncher.Effects.P&#95;WP&#95;RocketLauncher&#95;RocketExplosion&#39;);
   }
}
</pre>
</font>
<p />
We use the Weapon to spawn our EmitterSpawnable because the Spawn() function is available within Actor and not Object.
<p />
<strong>5.</strong>	Next we'll play the big explosion sound.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      es &#61; Weapon.Spawn(class&#39;Engine.EmitterSpawnable&#39;,,, Impact.HitLocation, Rotator(Impact.HitNormal));

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;RocketLauncher.Effects.P&#95;WP&#95;RocketLauncher&#95;RocketExplosion&#39;);

      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;RocketLauncher.Cue.A&#95;Weapon&#95;RL&#95;Impact&#95;Cue&#39;,,,, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
<strong>6.</strong>	To complete this fire type, we then do some radial damage.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   local EmitterSpawnable es;

   if (Impact.HitActor !&#61; none)
   {
      es &#61; Weapon.Spawn(class&#39;Engine.EmitterSpawnable&#39;,,, Impact.HitLocation, Rotator(Impact.HitNormal));

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;RocketLauncher.Effects.P&#95;WP&#95;RocketLauncher&#95;RocketExplosion&#39;);

      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;RocketLauncher.Cue.A&#95;Weapon&#95;RL&#95;Impact&#95;Cue&#39;,,,, Impact.HitLocation);
      Weapon.HurtRadius(class&#39;UTProj&#95;Rocket&#39;.default.Damage, class&#39;UTProj&#95;Rocket&#39;.default.DamageRadius, class&#39;UTProj&#95;Rocket&#39;.default.MyDamageType, class&#39;UTProj&#95;Rocket&#39;.default.MomentumTransfer, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.14 - WEAPON MUTATOR, PART VII: MULTIENFORCER_SHOCK"></a> TUTORIAL 12.14 - WEAPON MUTATOR, PART VII: MULTIENFORCER_SHOCK </h2>
<p />
This is the shock fire type. When the bullet hits anything, it creates a powerful shock combo explosion.
<p />
<strong>1.</strong>	First we set WeaponClass in the default properties.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   WeaponClass&#61;class&#39;UTWeap&#95;ShockRifle&#39;
   Name&#61;&#34;Default&#95;&#95;MultiEnforcer&#95;Shock&#34;
}
</pre>
</font>
<p />
<strong>2.</strong>	Now we override the OnProcessInstantHit() function.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	First we need to check if we've got a valid HitActor from the impact.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   if (Impact.HitActor !&#61; none)
   {
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	Let's start by spawning in the combo explosion particle effect.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   if (Impact.HitActor !&#61; none)
   {
      Weapon.Spawn(Class&#39;UTGame.UTEmit&#95;ShockCombo&#39;,,, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
We needed to use Weapon to spawn the particle effect in, because Spawn() is a native function that is in Actor and not Object. Impact is a struct which contains a lot of useful data that we can use. In this case, we used HitLocation.
<p />
<strong>5.</strong>	We play the sound now, otherwise having a silent explosion is rather boring.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   if (Impact.HitActor !&#61; none)
   {
      Weapon.Spawn(Class&#39;UTGame.UTEmit&#95;ShockCombo&#39;,,, Impact.HitLocation);
      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;ShockRifle.Cue.A&#95;Weapon&#95;SR&#95;ComboExplosionCue&#39;,,,, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
<strong>6.</strong>	To complete this fire type, we also do some radial damage.
<p />
<font face=consolas>
<pre>
function OnProcessInstantHit(UTWeapon Weapon, byte FiringMode, ImpactInfo Impact)
{
   if (Impact.HitActor !&#61; none)
   {
      Weapon.Spawn(Class&#39;UTGame.UTEmit&#95;ShockCombo&#39;,,, Impact.HitLocation);
      Weapon.PlaySound(SoundCue&#39;A&#95;Weapon&#95;ShockRifle.Cue.A&#95;Weapon&#95;SR&#95;ComboExplosionCue&#39;,,,, Impact.HitLocation);
      Weapon.HurtRadius(class&#39;UTProj&#95;ShockBall&#39;.default.ComboDamage, class&#39;UTProj&#95;ShockBall&#39;.default.ComboRadius, class&#39;UTProj&#95;ShockBall&#39;.default.ComboDamageType, class&#39;UTProj&#95;ShockBall&#39;.default.ComboMomentumTransfer, Impact.HitLocation);
   }
}
</pre>
</font>
<p />
By using the class default values we save ourselves a little effort of copying the values over.
<p />
<h2><a name="TUTORIAL 12.15 - WEAPON MUTATOR, TESTING"></a> TUTORIAL 12.15 - WEAPON MUTATOR, TESTING </h2>
<p />
<strong>1.</strong>	Start up an instant action death match game.
<p />
<strong>2.</strong>	Press 'Tab' to open up the console. From the console, type in 'giveweapon MasteringUnrealScript.UTWeap_Multienforcer'. This command will give the weapon to you.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_004.jpg"/><br/> <strong><font color=blue>Figure 12.4 – The console command instantly gives the player the desired weapon.</font></strong>
<p />
<strong>3.</strong>	You will now have the weapon given to you, so press the 3 key to switch to it.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_005.jpg"/><br/> <strong><font color=blue>Figure 12.5 – The MultiEnforcer weapon is now active.</font></strong>
<p />
<strong>4.</strong>	Now that you've selected the weapon, we can see that a few things are already working. First the HUD icon is appearing informing us that we have the rocket fire type selected. Fire the weapon to make sure.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_006.jpg"/><br/> <strong><font color=blue>Figure 12.6 – The weapon fires the rocket fire type.</font></strong>
<p />
<strong>5.</strong>	Now, let's test the fire type switching functionality. Right click to switch to a different fire type.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_007.jpg"/><br/> <strong><font color=blue>Figure 12.7 – The weapon switches fire types.</font></strong>
<p />
<strong>6.</strong>	Great, it looks like we've switched to the shock fire type. Fire to make sure that it is working.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_008.jpg"/><br/> <strong><font color=blue>Figure 12.8 – The weapon now fires the shock fire type.</font></strong>
<p />
In this tutorial you have made a weapon which the player can change between different fire types using the secondary fire button. Using delegates is one way of doing this, but there are of course many other ways of doing it as well. The main lesson to learn from this example is to see how important it is to make sure you clean up references when using delegates with objects.
<p />
<h2><a name="TUTORIAL 12.16 - DELEGATES  KISMET, PART I: INTRODUCTION  INITIAL CLASS SETUP"></a> TUTORIAL 12.16 - DELEGATES &amp; KISMET, PART I: INTRODUCTION &amp; INITIAL CLASS SETUP </h2>
<p />
In this tutorial we will discuss how to use delegates in a way that  can be used within Kismet. Specifically, we will create an effects generator for the level designer. The kismet logic will allow level designers to change the effects that are generated on the fly. The first things we need to think about, is how this will all work on the grand scheme of things. Kismet and level designers are often used to working with placeable actors and brushes, thus we should probably avoid using anything that level designers can't place within the level and tweak. Thus, an effects generator that is placeable, and its effects that are also placeable is probably the best way of handling this. This helps to solve a few things. Level designers can place a single effect generator some where which will define the location and rotation of where to spawn the effects. Level designers can place effects within the map and tweak the effects to achieve the desired effect. Level designers are quite used to this methodology of doing things. We will also need to write a Kismet ready node which allows the level design to set the delegates within the effects generator. Looking at the list of Kismet nodes, there isn't a Kismet node that will 'use' an actor either, so we'll need to make that as well. So, all up, we will have to make the effects generator class, effect base class, set effect Kismet class, use actor Kismet class and classes for the effects we wish to create. For this tutorial we will be making three effects, an explosion, grenades the spawn in a ring formation and a gib spawner.
<p />
<strong>1.</strong>	Open up your favorite text editor and create new Unrealscript files in the ..\MasteringUnrealScript\Classes directory called UTEffectsGenerator.uc, UTEffect.uc, SeqAct_SetEffect.uc, SeqAct_Use.uc, UTEffect_Explosion.uc, UTEffect_GrenadeRing.uc and UTEffect_Gibbage.uc.
<p />
<strong>2.</strong>	Declare our class and default properties for UTEffectsGenerator.
<p />
<font face=consolas>
<pre>
class UTEffectsGenerator extends Actor
   placeable;

defaultproperties
{
   Name&#61;”Default&#95;&#95;UTEffectsGenerator”
}
</pre>
</font>
<p />
UTEffectsGenerator is placeable as we would like level designers to be able to place this within their levels.
<p />
<strong>3.</strong>	Declare our class and default properties for UTEffect.
<p />
<font face=consolas>
<pre>
class UTEffect extends Actor
   abstract;

defaultproperties
{
   Name&#61;”Default&#95;&#95;UTEffect”
}
</pre>
</font>
<p />
UTEffect is abstract because we will be creating child classes UTEffect_Explosion, UTEffect_GrenadeRing and UTEffect_Gibbage, and thus UTEffect should never be spawned or placed by level designers or programmers.
<p />
<strong>4.</strong>	Declare our class and default properties for SeqAct_SetEffect.
<p />
<font face=consolas>
<pre>
class SeqAct&#95;SetEffect extends SeqAct&#95;SetSequenceVariable;

defaultproperties
{
   VariableLinks(1)&#61;(ExpectedType&#61;Class&#39;Engine.SeqVar&#95;Object&#39;,LinkDesc&#61;&#34;Effect&#34;,PropertyName&#61;&#34;Value&#34;,MinVars&#61;1,MaxVars&#61;255)
   ObjClassVersion&#61;2
   ObjName&#61;&#34;Set Effect&#34;
   ObjCategory&#61;”Effect Generator”
   Name&#61;”Default&#95;&#95; SeqAct&#95;SetEffect”
   ObjectArchetype&#61;SeqAct&#95;SetSequenceVariable&#39;Engine.Default&#95;&#95;SeqAct&#95;SetSequenceVariable&#39;
}
</pre>
</font>
<p />
SeqAct_SetEffect is a child class of SeqAct_SetSequenceVariable since we are using it in Kismet in a similar way. VariableLinks(1) specifies a link slot that the Kismet editor in Unreal Editor can use. ObjName is the name of the Kismet node that will appear inside the Kismet editor.
<p />
<strong>5.</strong>	Declare our class and default properties for SeqAct_Use.
<p />
<font face=consolas>
<pre>
class SeqAct&#95;Use extends SequenceAction;

defaultproperties
{
   ObjName&#61;”Use”
   ObjCategory&#61;”Effect Generator”
   Name&#61;”Default&#95;&#95;SeqAct&#95;Use”
   ObjectArchetype&#61;SequenceAction&#39;Engine.Default&#95;&#95;SequenceAction&#39;
}
</pre>
</font>
<p />
SeqAct_Use is a child class of SequenceAction since we are using it in Kismet in a similar way. ObjName is the name of the Kismet node that will appear inside the Kismet editor, ObjCategory is used for sorting the Kismet nodes within the Kismet editor.
<p />
<strong>6.</strong>	Declare our class and default properties for UTEffect_Explosion.
<p />
<font face=consolas>
<pre>
class UTEffect&#95;Explosion extends UTEffect
   placeable;

defaultproperties
{
   Name&#61;”Default&#95;UTEffect&#95;Explosion”
}
</pre>
</font>
<p />
UTEffect_Explosion is placeable since we intend this to be placed by level designers.
<p />
<strong>7.</strong>	Declare our class and default properties for UTEffect_GrenadeRing.
<p />
<font face=consolas>
<pre>
class UTEffect&#95;GrenadeRing extends UTEffect
   placeable;

defaultproperties
{
   Name&#61;”Default&#95;&#95;UTEffect&#95;GrenadeRing”
}
</pre>
</font>
<p />
UTEffect_GrenadeRing is placeable since we intend this to be placed by level designers.
<p />
<strong>8.</strong>	Declare our class and default properties for UTEffect_Gibbage.
<p />
<font face=consolas>
<pre>
class UTEffect&#95;Gibbage extends UTEffect
   placeable;

defaultproperties
{
   Name&#61;”Default&#95;&#95;UTEffect&#95;Gibbage”
}
</pre>
</font>
<p />
UTEffect_Gibbage is placeable since we intend this to be placed by level designers.
<p />
<h2><a name="TUTORIAL 12.17 - DELEGATES  KISMET, PART II: UTEFFECTSGENERATOR"></a> TUTORIAL 12.17 - DELEGATES &amp; KISMET, PART II: UTEFFECTSGENERATOR </h2>
<p />
<strong>1.</strong>	We first start by declaring our delegate function that will be used by the effect generator.
<p />
<font face=consolas>
<pre>
delegate OnGenerateEffects(UTEffectsGenerator InGenerator);
</pre>
</font>
<p />
This delegate contains a parameter which holds a reference to a UTEffectsGenerator. In this case, it will always hold a reference to the UTEffectsGenerator that invoked that delegate. This will allow other class instances to have access to who invoked the delegate in the first place
<p />
<strong>2.</strong>	Now that we have our delegate function, we'll need to write some of logic that actually calls it.
<p />
<font face=consolas>
<pre>
function GenerateEffects()
{
   OnGenerateEffects(self);
}
</pre>
</font>
<p />
The reason why we encapsulate the call to OnGenerateEffects() within GenerateEffects() is for future proofing really. While it doesn't matter right now, if perhaps we wanted a method to disable the effect generation, or whatever else. This means that we only need to adjust GenerateEffects() and thats all, without having to alter the child classes.
<p />
<strong>3.</strong>	Now we need a method to call the GenerateEffects() function. In this particular case, we will use the UsedBy() hook that exists within Actor. UsedBy() is called when a player uses the actor by pressing the Use button. In our case though, we just need a common hook so Kismet can interact with it.
<p />
<font face=consolas>
<pre>
function bool UsedBy(Pawn User)
{
   GenerateEffects();
   return super.UsedBy(User);
}
</pre>
</font>
<p />
Thus when the effects generator gets used by a player, the effects generator will call GenerateEffects() which then invokes the OnGenerateEffects() delegate.
<p />
<strong>4.</strong>	Now we need a way to be able to set the delegate when ever we like.
<p />
<font face=consolas>
<pre>
function SetEffect(delegate&#60;OnGenerateEffects&#62; NewEffect)
{
   OnGenerateEffects &#61; NewEffect;
}
</pre>
</font>
<p />
Technically speaking, there wasn't a reason why I had to encapsulate that within a function, since I could access the delegate like a variable from other classes. However, if you were to ever change this delegate into a private or protected delegate, you would have to then alter all of the classes that used the delegate like that.
<p />
<strong>5.</strong>	Since a level designer is going to be placing this actor into the world, the level designer is going to need to be able to see the effects generator. Thus we add some rendering components into the default properties that are only visible within the editor.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   Begin Object Class&#61;SpriteComponent Name&#61;Sprite ObjName&#61;Sprite Archetype&#61;SpriteComponent&#39;Engine.Default&#95;&#95;SpriteComponent&#39;
      HiddenGame&#61;True
          AlwaysLoadOnClient&#61;False
          AlwaysLoadOnServer&#61;False
          Name&#61;&#34;Sprite&#34;
          ObjectArchetype&#61;SpriteComponent&#39;Engine.Default&#95;&#95;SpriteComponent&#39;
     End Object
     Components(0)&#61;Sprite

   Begin Object Class&#61;ArrowComponent Name&#61;Arrow ObjName&#61;Arrow Archetype&#61;ArrowComponent&#39;Engine.Default&#95;&#95;ArrowComponent&#39;
      ArrowColor&#61;(B&#61;255,G&#61;200,R&#61;150,A&#61;255)
      Name&#61;&#34;Arrow&#34;
      ObjectArchetype&#61;ArrowComponent&#39;Engine.Default&#95;&#95;ArrowComponent&#39;
   End Object
   Components(1)&#61;Arrow

   Name&#61;”Default&#95;&#95;UTEffectsGenerator”
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.18	- DELEGATES  KISMET, PART III: UTEFFECT"></a> TUTORIAL 12.18	- DELEGATES &amp; KISMET, PART III: UTEFFECT </h2>
<p />
<strong>1.</strong>	The first thing we will need to do is to make sure that UTEffectGenerator is always compiled before this class. Thus we add a dependson(UTEffectsGenerator) to the class definition.
<p />
<font face=consolas>
<pre>
class UTEffect extends Actor
   dependson(UTEffectsGenerator)
   abstract;
</pre>
</font>
<p />
<strong>2.</strong>	Now we need to create a function which will act as our stub function for all of the child classes. This stub function will also be used as the delegate override to the delegate that is defined within UTEffectsGenerator.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator);
</pre>
</font>
<p />
<strong>3.</strong>	Next we create a function which Kismet will call to set this effect to the effect generator.
<p />
<font face=consolas>
<pre>
function SetEffect(UTEffectsGenerator InGenerator)
{
   if (InGenerator !&#61; none)
      InGenerator.SetEffect(Effect);
}
</pre>
</font>
<p />
As stated previous, delegate assigning could have been done as InGenerator.OnGenerateEffects = Effect. However, it isn't really that flexible because if the delegate was changed to private or protected, then this class would no longer have access to it. Thus, to be on the safe side an assigning function was used instead.
<p />
<strong>4.</strong>	In the same case as UTEffectsGenerator, since the level designer needs to be able to place these within his or her level, we will need to add some rendering components to the default properties.
<p />
<font face=consolas>
<pre>
defaultproperties
{
     Begin Object Class&#61;SpriteComponent Name&#61;Sprite ObjName&#61;Sprite Archetype&#61;SpriteComponent&#39;Engine.Default&#95;&#95;SpriteComponent&#39;
      HiddenGame&#61;True
      AlwaysLoadOnClient&#61;False
      AlwaysLoadOnServer&#61;False
      Name&#61;&#34;Sprite&#34;
      ObjectArchetype&#61;SpriteComponent&#39;Engine.Default&#95;&#95;SpriteComponent&#39;
   End Object
   Components(0)&#61;Sprite

   Name&#61;&#34;Default&#95;UTEffect&#34;
}
</pre>
</font>
<p />
<h2><a name="TUTORIAL 12.19 - DELEGATES  KISMET, PART IV: SEQACT_SETEFFECT"></a> TUTORIAL 12.19 - DELEGATES &amp; KISMET, PART IV: SEQACT_SETEFFECT </h2>
<p />
<strong>1.</strong>	Kismet nodes are controlled predominately by native code. However, there are some events that are called by native code which we can use in Unrealscript. In this particular case, the event named Activated() is called by native code when ever the node is activated. Thus we override it to gain access to it.
<p />
<font face=consolas>
<pre>
event Activated()
{
}
</pre>
</font>
<p />
<strong>2.</strong>	When Kismet nodes are linked to within the Editor the LinkedVariables (within each VariableLinks) will hold reference to those object variables. These object variables should contain the UTEffectsGenerator and the UTEffect object references that we need. So to start off, we just check if these assumptions are correct.
<p />
<font face=consolas>
<pre>
event Activated()
{
   if (VariableLinks.length &#62;&#61; 2 &#38;&#38; VariableLinks&#91;0].LinkedVariables.length &#62; 0 &#38;&#38; VariableLinks&#91;0].LinkedVariables&#91;0] !&#61; none &#38;&#38; VariableLinks&#91;1].LinkedVariables.length &#62; 0 &#38;&#38; VariableLinks&#91;1].LinkedVariables&#91;0] !&#61; none)
   {
   }
}
</pre>
</font>
<p />
In this if statement, we first check if the VariableLinks array is greater or equal to two. Since we need two objects (UTEffectsGenerator and UTEffect), there should be two VariableLinks present. In each of these VariableLinks the LinkedVariables array should be greater than zero. Lastly, in the first index within LinkedVariables there should be an object reference there.
<p />
<strong>3.</strong>	Because LinkedVariables are stored as SequenceVariables, but are actually SeqVar_Objects we first need to type cast the LinkedVariables we've found into SeqVar_Objects. Hopefully then, SeqVar_Objects will contain references to UTEffectGenerators and UTEffect.
<p />
<font face=consolas>
<pre>
event Activated()
{
   local SeqVar&#95;Object sv&#95;obj;

   if (VariableLinks.length &#62;&#61; 2 &#38;&#38; VariableLinks&#91;0].LinkedVariables.length &#62; 0 &#38;&#38; VariableLinks&#91;0].LinkedVariables&#91;0] !&#61; none &#38;&#38; VariableLinks&#91;1].LinkedVariables.length &#62; 0 &#38;&#38; VariableLinks&#91;1].LinkedVariables&#91;0] !&#61; none)
   {
      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;0].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
      {
      }

      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;1].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
      {
      }
   }
}
</pre>
</font>
<p />
As seen here, we've added a local variable to temporarily store the results of the type cast. This is done so we can actually check if the type cast was valid or not, and it would save a lot of headaches in future (if a level designer was to put something into the link that wasn't what we expected for example).
<p />
<strong>4.</strong>	Now that we have type casted to SeqVar_Object's, we can then try to retrieve the level instances of UTEffectsGenerator and UTEffect that have been linked to this Kismet node. We create two local variables that will hold references to UTEffectsGenerator and UTEffect, and we attempt to retrieve them from sv_obj via the GetObjectValue() function. GetObjectValue() returns an object reference, so we will need to type cast these to the appropriate types.
<p />
<font face=consolas>
<pre>
event Activated()
{
   local SeqVar&#95;Object sv&#95;obj;
   local UTEffectsGenerator ut&#95;effects&#95;generator;
   local UTEffect ut&#95;effects;

   if (VariableLinks.length &#62;&#61; 2 &#38;&#38; VariableLinks&#91;0].LinkedVariables&#91;0] !&#61; none &#38;&#38; VariableLinks&#91;1].LinkedVariables&#91;0] !&#61; none)
   {
      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;0].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
         ut&#95;effects&#95;generator &#61; UTEffectsGenerator(sv&#95;obj.GetObjectValue());

      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;1].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
         ut&#95;effects &#61; UTEffect(sv&#95;obj.GetObjectValue());
   }
}
</pre>
</font>
<p />
<strong>5.</strong>	Finally, we have the level instances of UTEffectsGenerator and UTEffect. However, before we use them it is good practice to still check that these references are actually valid. Thus we do a check for none and if they aren't none, we tell the reference to UTEffect to set its effect onto the reference of UTEffectsGenerator. We do this by calling our SetEffect() function within UTEffect, which in turn will call the SetEffect() function within UTEffectsGenerator.
<p />
<font face=consolas>
<pre>
event Activated()
{
   local SeqVar&#95;Object sv&#95;obj;
   local UTEffectsGenerator ut&#95;effects&#95;generator;
   local UTEffect ut&#95;effects;

   if (VariableLinks.length &#62;&#61; 2 &#38;&#38; VariableLinks&#91;0].LinkedVariables&#91;0] !&#61; none &#38;&#38; VariableLinks&#91;1].LinkedVariables&#91;0] !&#61; none)
   {
      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;0].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
         ut&#95;effects&#95;generator &#61; UTEffectsGenerator(sv&#95;obj.GetObjectValue());

      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;1].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
         ut&#95;effects &#61; UTEffect(sv&#95;obj.GetObjectValue());

      if (ut&#95;effects&#95;generator !&#61; none &#38;&#38; ut&#95;effects !&#61; none)
         ut&#95;effects.SetEffect(ut&#95;effects&#95;generator);
   }
}
</pre>
</font>
<p />
And then, we're done with this Kismet node.
<p />
<h2><a name="TUTORIAL 12.20 - DELEGATES  KISMET, PART V: SEQACT_USE"></a> TUTORIAL 12.20 - DELEGATES &amp; KISMET, PART V: SEQACT_USE </h2>
<p />
<strong>1.</strong>	Much like in SeqAct_SetEffect, we once again override the Activated() event.
<p />
<font face=consolas>
<pre>
event Activated()
{
}
</pre>
</font>
<p />
<strong>2.</strong>	Much like in SeqAct_SetEffect, we traverse our VariableLinks and their LinkedVariables to find the Actor instance that is connected to this Kismet node.
<p />
<font face=consolas>
<pre>
event Activated()
{
   local SeqVar&#95;Object sv&#95;obj;
   local Actor a;

   if (VariableLinks.length &#62;&#61; 1 &#38;&#38; VariableLinks&#91;0].LinkedVariables.length &#62; 0 &#38;&#38; VariableLinks&#91;0].LinkedVariables&#91;0] !&#61; none)
   {
      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;0].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
      {
         a &#61; Actor(sv&#95;obj.GetObjectValue());
      }
   }
}
</pre>
</font>
<p />
<strong>3.</strong>	Now that we have the actor reference, we check for none and call the UsedBy() function. This is a utility Kismet node and can be used for any Actor that implements that function.
<p />
<font face=consolas>
<pre>
event Activated()
{
   local SeqVar&#95;Object sv&#95;obj;
   local Actor a;

   if (VariableLinks.length &#62;&#61; 1 &#38;&#38; VariableLinks&#91;0].LinkedVariables.length &#62; 0 &#38;&#38; VariableLinks&#91;0].LinkedVariables&#91;0] !&#61; none)
   {
      sv&#95;obj &#61; SeqVar&#95;Object(VariableLinks&#91;0].LinkedVariables&#91;0]);

      if (sv&#95;obj !&#61; none)
      {
         a &#61; Actor(sv&#95;obj.GetObjectValue());

         if (a !&#61; none)
            a.UsedBy(none);
      }
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	Now that we've finished our base classes and the Kismet nodes we require, we now move onto the fun parts … creating the effects!
<p />
<h2><a name="TUTORIAL 12.21 - DELEGATES  KISMET, PART VI: UTEFFECT_EXPLOSION"></a> TUTORIAL 12.21 - DELEGATES &amp; KISMET, PART VI: UTEFFECT_EXPLOSION </h2>
<p />
<strong>1.</strong>	To start, we override the Effect function that is present in the parent class (UTEffect).
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
}
</pre>
</font>
<p />
<strong>2.</strong>	For this effect, all we want to do is to spawn an explosion particle effect similar to the rocket explosion and play an explosion sound as well. This effect would work well for doing timed explosions for certain things such as collapsing buildings for example. So, we create a local variable to hold a reference to the emitter which handles our particle spawning.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local EmitterSpawnable es;
}
</pre>
</font>
<p />
<strong>3.</strong>	From here, lets spawn our emitter and set the particle system template. Since we want to spawn the emitter where the UTEffectsGenerator is, we will use UTEffectsGenerator's location and rotation. Again, before using it, we check to see if it is none.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local EmitterSpawnable es;

   if (InGenerator !&#61; none)
   {
      es &#61; Spawn(class&#39;EmitterSpawnable&#39;,,, InGenerator.Location, InGenerator.Rotation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;RocketLauncher.Effects.P&#95;WP&#95;RocketLauncher&#95;RocketExplosion&#39;);
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	And to complete the effect all we need to do now is to add the explosion sound effect.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local EmitterSpawnable es;

   if (InGenerator !&#61; none)
   {
      InGenerator.PlaySound(SoundCue&#39;A&#95;Weapon&#95;RocketLauncher.Cue.A&#95;Weapon&#95;RL&#95;Impact&#95;Cue&#39;);
      es &#61; Spawn(class&#39;EmitterSpawnable&#39;,,, InGenerator.Location, InGenerator.Rotation);

      if (es !&#61; none)
         es.SetTemplate(ParticleSystem&#39;WP&#95;RocketLauncher.Effects.P&#95;WP&#95;RocketLauncher&#95;RocketExplosion&#39;);
   }
}
</pre>
</font>
<p />
<strong>5.</strong>	First effect is all done. As an extra exercise, you could perhaps try to make both the sound cue and the particle system configurable for the Editor.
<p />
Hint: you would do this by making global variables holding references to the sound cue and the particle system which are editable
<p />
<h2><a name="TUTORIAL 12.22 - DELEGATES  KISMET, PART VII: UTEFFECT_GRENADERING"></a> TUTORIAL 12.22 - DELEGATES &amp; KISMET, PART VII: UTEFFECT_GRENADERING </h2>
<p />
In this effect, we will be throwing grenades in a ring pattern from the UTEffectsGenerator. The step angle of each grenade is configurable by the level designer.
<p />
<strong>1.</strong>	So to start, we will declare an Editor global variable.
<p />
<font face=consolas>
<pre>
var(GrenadeRing) int Angle;
</pre>
</font>
<p />
This will put Angle inside the GrenadeRing category when the level designer opens the properties window.
<p />
<strong>2.</strong>	As before, we again override the Effect function from the parent class.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Since we wish to center the spawning ring within the UTEffectsGenerator, we will check for none and also check our Angle value as the level designer may have put in a value we can't use.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   if (InGenerator !&#61; none &#38;&#38; Angle &#62; 0 &#38;&#38; Angle &#60; 65535)
   {
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	Let's sort out the sound effect first.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   if (InGenerator !&#61; none &#38;&#38; Angle &#62; 0 &#38;&#38; Angle &#60; 65535)
   {
      InGenerator.PlaySound(SoundCue&#39;A&#95;Weapon&#95;RocketLauncher.Cue.A&#95;Weapon&#95;RL&#95;GrenadeFire&#95;Cue&#39;);
   }
}
</pre>
</font>
<p />
<strong>5.</strong>	The first thing we need to do is generate the ring based on the angle step that the level designer. Since grenades are going to be thrown, we might as well just spawn them in a single place and just ensure that their velocities make it look like they were spawned in a ring pattern. (You could if you really wanted, spawn the grenades in a ring start position as well). Remembering that the maximum rotation value within Unreal Engine is 65535, we add a for iterator that counts up to 65535. Each iteration will plus the angle step.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local int i;

   if (InGenerator !&#61; none &#38;&#38; Angle &#62; 0 &#38;&#38; Angle &#60; 65535)
   {
      InGenerator.PlaySound(SoundCue&#39;A&#95;Weapon&#95;RocketLauncher.Cue.A&#95;Weapon&#95;RL&#95;GrenadeFire&#95;Cue&#39;);

      for (i &#61; 0; i &#60; 65535; i &#61; i + Angle)
      {
      }
   }
}
</pre>
</font>
<p />
<strong>6.</strong>	Perfect, now that we have the iterator setup we can then spawn each grenade and calculate its rotation. We setup a local variable to hold the rotation value at each iteration. On each iteration, we only need to alter the Yaw value of the rotator. We also create a local grenade variable to hold a reference to the grenade we spawn.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local int i;
   local rotator r;
   local UTProj&#95;Grenade grenade;

   if (InGenerator !&#61; none &#38;&#38; Angle &#62; 0 &#38;&#38; Angle &#60; 65535)
   {
      InGenerator.PlaySound(SoundCue&#39;A&#95;Weapon&#95;RocketLauncher.Cue.A&#95;Weapon&#95;RL&#95;GrenadeFire&#95;Cue&#39;);
      r.Pitch &#61; 0;
      r.Roll &#61; 0;

      for (i &#61; 0; i &#60; 65535; i &#61; i + Angle)
      {
         r.Yaw &#61; i;
         grenade &#61; Spawn(class&#39;UTGame.UTProj&#95;Grenade&#39;,,, InGenerator.Location, r);
      }
   }
}
</pre>
</font>
<p />
<strong>7.</strong>	Finally we set the velocity of each grenade. Using our rotator value, we convert it to a vector and multiply it by a float to obtain a velocity value. Setting the float higher or lower will increase or decrease how far a grenade is launched.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local int i;
   local rotator r;
   local UTProj&#95;Grenade grenade;

   if (InGenerator !&#61; none &#38;&#38; Angle &#62; 0 &#38;&#38; Angle &#60; 65535)
   {
      InGenerator.PlaySound(SoundCue&#39;A&#95;Weapon&#95;RocketLauncher.Cue.A&#95;Weapon&#95;RL&#95;GrenadeFire&#95;Cue&#39;);
      r.Pitch &#61; 0;
      r.Roll &#61; 0;

      for (i &#61; 0; i &#60; 65535; i &#61; i + Angle)
      {
         r.Yaw &#61; i;
         grenade &#61; Spawn(class&#39;UTGame.UTProj&#95;Grenade&#39;,,, InGenerator.Location, r);

         if (grenade !&#61; none)
            grenade.Velocity &#61; vector(r) &#42; 300.f;
      }
   }
}
</pre>
</font>
<p />
And with that, we now have an effect which will throw grenades in a ring pattern.
<p />
<h2><a name="TUTORIAL 12.23 - DELEGATES  KISMET, PART VIII: UTEFFECT_GIBBAGE"></a> TUTORIAL 12.23 - DELEGATES &amp; KISMET, PART VIII: UTEFFECT_GIBBAGE </h2>
<p />
In this effect we will be spawning a number of gibs that will fly off in random directions. We would like to make the amount of gibs controllable by the level designer.
<p />
<strong>1.</strong>	So to start, we'll declare an Editor global variable.
<p />
<font face=consolas>
<pre>
var(Gibbage) int Amount;
</pre>
</font>
<p />
This will put the Amount variable within the Gibbage category when the level designer opens the properties window.
<p />
<strong>2.</strong>	As before, we override the Effect function from the parent class.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Since all of the gibs will spawn from the UTEffectsGenerator instance, we need to check for none. We will also need to check Amount to make sure it is above zero.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   if (InGenerator !&#61; none &#38;&#38; Amount &#62; 0)
   {
   }
}
</pre>
</font>
<p />
<strong>4.</strong>	We need to set up an iterator which will iterate from zero until Amount.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local int i;

   if (InGenerator !&#61; none &#38;&#38; Amount &#62; 0)
   {
      for (i &#61; 0; i &#60; Amount; ++i)
      {
      }
   }
}
</pre>
</font>
<p />
<strong>5.</strong>	Because we have a range of gibs we can spawn, let's make another function which will randomly select a gib class for us to use. Make a new function called GetRandomGibClass() which will return a UTGib_Human class.
<p />
<font face=consolas>
<pre>
function class&#60;UTGib&#95;Human&#62; GetRandomGibClass()
{
}
</pre>
</font>
<p />
<strong>6.</strong>	Add a switch statement with a Rand(5) as its parameter. We use five here since there are five types of human gibs available to us.
<p />
<font face=consolas>
<pre>
function class&#60;UTGib&#95;Human&#62; GetRandomGibClass()
{
   switch(Rand(5))
   {
   }
}
</pre>
</font>
<p />
<strong>7.</strong>	Since there are five types of human gibs to select from, just return all five classes depending on what the random value was.
<p />
<font face=consolas>
<pre>
function class&#60;UTGib&#95;Human&#62; GetRandomGibClass()
{
   switch(Rand(5))
   {
      case 0:
         return class&#39;UTGib&#95;HumanArm&#39;;

      case 1:
         return class&#39;UTGib&#95;HumanBone&#39;;

      case 2:
         return class&#39;UTGib&#95;HumanChunk&#39;;

      case 3:
         return class&#39;UTGib&#95;HumanHead&#39;;

      case 4:
      default:
         return class&#39;UTGib&#95;HumanTorso&#39;;
   }
}
</pre>
</font>
<p />
<strong>8.</strong>	Now, let's spawn some gibs!We made a local variable called gib so that we can hold a temporary reference to the gib we just created.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local int i;
   local UTGib&#95;Human gib;

   if (InGenerator !&#61; none &#38;&#38; Amount &#62; 0)
   {
      for (i &#61; 0; i &#60; Amount; ++i)
      {
         gib &#61; Spawn(GetRandomGibClass(),,, InGenerator.Location, InGenerator.Rotation);
      }
   }
}
</pre>
</font>
<p />
<strong>9.</strong>	In Unreal Tournament 3, gibs are actually simulated physically using the physics engine PhysX. This means they bounce around and collide with the world using some what realistic physics. This means that we'll have to set the gib's velocities and initialize them so PhysX will simulate them.
<p />
<font face=consolas>
<pre>
function Effect(UTEffectsGenerator InGenerator)
{
   local int i;
   local UTGib&#95;Human gib;

   if (InGenerator !&#61; none &#38;&#38; Amount &#62; 0)
   {
      for (i &#61; 0; i &#60; Amount; ++i)
      {
         gib &#61; Spawn(GetRandomGibClass(),,, InGenerator.Location, InGenerator.Rotation);

         if (gib !&#61; none)
         {
            gib.Velocity &#61; Vector(RotRand()) &#42; RandRange(200.f, 400.f);

            if (gib.GibMeshComp !&#61; none)
            {
               gib.GibMeshComp.WakeRigidBody();
               gib.GibMeshComp.SetRBLinearVelocity(gib.Velocity, false);
               gib.GibMeshComp.SetRBAngularVelocity(VRand() &#42; 50.f, false);
            }
         }
      }
   }
}
</pre>
</font>
<p />
We first set a random velocity for the gib, by getting a random rotation multiplied by a random value that will be between two hundred and four hundred. We then check if the gib has a mesh component which PhysX requires. If the gib has one, we then wake it up so that PhysX will take over and set random velocities. SetRBLinearVelocity() sets the linear traveling velocity of the object. SetRBAngularVelocity() sets the spinning velocity of the object. With that we have a rather neat gibbing effect.
<p />
<h2><a name="TUTORIAL 12.24 - DELEGATES  KISMET, PART IX: SETTING UP THE TEST BED"></a> TUTORIAL 12.24 - DELEGATES &amp; KISMET, PART IX: SETTING UP THE TEST BED </h2>
<p />
<strong>1.</strong>	Compile the code, and start up Unreal Editor.
<p />
<strong>2.</strong>	When Unreal Editor has loaded, open up DM-Chapter12-Kismet. As you can see it is just a small bare bones level with some decorative static meshes, some lights and a player start.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_009.jpg"/><br/> <strong><font color=blue>Figure 12.9 – The DM-CH_12_Kismet map.</font></strong>
<p />
<strong>3.</strong>	When the map has loaded up, we then need to the classes within our code package so that we can add the new classes (UTEffectsGenerator, UTEffect_Explosion, UTEffect_Gibbage, UTEffect_GrenadeRing) into the map. These should be available in the Actor Browser automatically. If not, we will need to load the script package. To do this, open up the Generic Browser, if it is not open, switch to the Actor Classes tab, click on File and then Open. This will bring up a file dialog from which you can select the package you wish to open.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_010.jpg"/><br/> <strong><font color=blue>Figure 12.10 – The File-&gt;Open command enables you to load script packages.</font></strong>
<p />
When the package has loaded, you should see the new classes within the Actor Browser.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_011.jpg"/><br/> <strong><font color=blue>Figure 12.11 – The classes are available within the Actor Browser class tree.</font></strong>
<p />
<strong>4.</strong>	From here we can now select and place our UTEffectGenerator some where within the map. We have this neat mesh sitting in the middle of the floor within the right room. So let's put our UTEffectsGenerator just above that. Select the UTEffectsGenerator within the ActorBrowser, then right click within the level viewport where you would like to place it. In the context menu, you will be able to do this by clicking 'Add UTEffectsGenerator Here'.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_012.jpg"/><br/> <strong><font color=blue>Figure 12.12 – The UTEffectGenerator is added to the map.</font></strong>
<p />
<strong>5.</strong>	The newly added UTEffectsGenerator should be sitting on top of the tube like mesh.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_013.jpg"/><br/> <strong><font color=blue>Figure 12.13 – The placement of the UTEffectGenerator actor.</font></strong>
<p />
<strong>6.</strong>	We'll need to tweak the rotation properties of the UTEffectsGenerator. Now that it is selected (or select it if it isn't), press F4 to bring up its properties window.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_014.jpg"/><br/> <strong><font color=blue>Figure 12.14 – The Rotation property of the UTEffectGenerator is adjusted.</font></strong>
<p />
<strong>7.</strong>	Next we need to add our UTEffect instances within the level. Let's place them in the corner of our level so that we can easily find them. Add them in the same way as you did with UTEffectsGenerator by selecting each one from the Actor Browser then right clicking to add them via the context menu.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_015.jpg"/><br/> <strong><font color=blue>Figure 12.15 – The UTEffect actors are palced outside the level geometry.</font></strong>
<p />
<strong>8.</strong>	For this example, we will need a Physics Volume to trigger our UTEffectsGenerator. Start by setting the building brush to cover the same area as the door way. Those settings should cover the door way pretty well.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_016.jpg"/><br/> <strong><font color=blue>Figure 12.16 – The placement of the red builder brush.</font></strong>
<p />
<strong>9.</strong>	Now that we have the building brush where we want it. Right click on the 'Add Volume' button from the left hand menu and select 'PhysicsVolume' to add it within the map.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_017.jpg"/><br/> <strong><font color=blue>Figure 12.17 – PhysicsVolume is selected from the Add Volume menu.</font></strong>
<p />
<strong>10.</strong>	We now have a Physics Volume within our map. Select it by clicking on it. If you have difficulty selecting it within the 3D viewport, switch to a 2D viewport and select it from there.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_018.jpg"/><br/> <strong><font color=blue>Figure 12.18 – The PhysicsVolume is selected.</font></strong>
<p />
<strong>11.</strong>	Open up Kismet by clicking on the Kismet button in the main toolbar of Unreal Editor. You should now see the Kismet editor.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_019.jpg"/><br/> <strong><font color=blue>Figure 12.19 – The Kismet Editor.</font></strong>
<p />
<strong>12.</strong>	Right click to bring up a context menu. Let's create a Touch event using the Physics Volume (remember to select the Physics Volume before you do this). This will create an event Kismet node which will trigger when the Physics Volume is touched. It responds to two specific engine events, being touched and untouched. Touched is triggered when an actor's collision touches within the owner's collision. Untouched is the reverse. Touched and Untouched are called once, meaning actors will not continually touch another actor.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_020.jpg"/><br/> <strong><font color=blue>Figure 12.20 – The Touch event has been created.</font></strong>
<p />
<strong>13.</strong>	We need to make an adjustment to the Touched event node. By default, it sets the MaxTriggerCount to 1, meaning that it will only ever trigger once and then disable itself. In this particular case, we'd like to make it triggerable forever. In the bottom left corner, there is a properties section for each node that is selected. If you scroll down, there is a value called MaxTriggerCount. Set this to 0.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_021.jpg"/><br/> <strong><font color=blue>Figure 12.21 – The MaxTriggerCount is set to 0.</font></strong>
<p />
<strong>14.</strong>	Now we want to do something when the physics volume has been touched. Let's create an Action node which uses something. This is actually the SeqAct_Use node that we created earlier. Once again, traversing through the context menu, add the Use action node from the Effect Generator category.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_022.jpg"/><br/> <strong><font color=blue>Figure 12.22 – The Use action is added.</font></strong>
<p />
<strong>15.</strong>	Now we selected our UTEffectsGenerator from one of the level viewports.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_023.jpg"/><br/> <strong><font color=blue>Figure 12.23 – The UTEffectGenerator is selected.</font></strong>
<p />
<strong>16.</strong>	Going back to the Kismet Editor window, we can now add a reference to the selected UTEffectsGenerator within Kismet by right-clicking in the workspace and choosing New Object Var Using UTEffectGenerator_0.
<p />
Note: The name of the actual actor may vary in your map.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_024.jpg"/><br/> <strong><font color=blue>Figure 12.24 – The UTEffectGenerator object variable has been created.</font></strong>
<p />
<strong>17.</strong>	Now lets link everything up. Click and drag on the black square box on the right hand size of Touched within the PhysicsVolume_0 Touch node and connect it to the black box on the left hand side of In within the Use node. Then click drag on the purple square box underneath Target within the Use node and connect this to UTEffectsGenerator_1. This tells Kismet to trigger the Use node when the Physics Volume is touched, and the Use node will then use UTEffectsGenerator_1.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_025.jpg"/><br/> <strong><font color=blue>Figure 12.25 – The proper connections have been made.</font></strong>
<p />
<strong>18.</strong>	Great, this will handle the basic action that we want. But we still need to handle the process of attaching an effect to UTEffectsGenerator. Since we have three effects, let's attach them randomly to the UTEffectsGenerator. We'll do this by using a random switch to select which one to attach. Right click to open up the context menu, and add a Random switch node by selecting Add Action-&gt;Switch-&gt;Random.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_026.jpg"/><br/> <strong><font color=blue>Figure 12.26 – The Random Swicth has been added.</font></strong>
<p />
<strong>19.</strong>	We'll need to alter the random switch node properties. Looking in the bottom left hand corner, scroll down and change the LinkCount value from 1 to 3.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_027.jpg"/><br/> <strong><font color=blue>Figure 12.27 – The LinkCount is set to 3.</font></strong>
<p />
<strong>20.</strong>	Right click to open the context menu, and add three Set Effect Kismet nodes from the Effect Generator category under Add Action. This is actually SeqAct_SetEffect that we made earlier. After adding three Set Effect Kismet nodes, link them up to the Random switch Kismet node, in the same way as before.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_028.jpg"/><br/> <strong><font color=blue>Figure 12.28 – The Set Effect actions are connected to the Random Switch.</font></strong>
<p />
<strong>21.</strong>	Let's link everything else up as well. All the of the Set Effect Kismet nodes need to be connected to the UTEffectsGenerator, so they know which UTEffectsGenerator to set the effect to. Also, we link Out within the Use Kismet node to In within the Random Kismet node. Thus, when the Use Kismet node is triggered, it will then trigger the Random Kismet node, which will then trigger one of the three Set Effect Kismet nodes.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_029.jpg"/><br/> <strong><font color=blue>Figure 12.29 – The remaining connections are made.</font></strong>
<p />
<strong>22.</strong>	Go back to the level viewport, and select one of the UTEffects that we placed within the level. When one is selected, add it as an object into Kismet in the same process as you did earlier with UTEffectsGenerator. Right click to open the context menu, and which ever UTEffect you selected should appear within the context menu.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_030.jpg"/><br/> <strong><font color=blue>Figure 12.30 – The UTEffect object variable is created.</font></strong>
<p />
<strong>23.</strong>	Repeat this with the other two UTEffects. Once all three have been placed within the Kismet Editor window, link each one up to a Set Effect Kismet node.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_031.jpg"/><br/> <strong><font color=blue>Figure 12.31 – All three UTEffect variables are linked to the Set Effect actions.</font></strong>
<p />
<strong>24.</strong>	 Great, now we have the majority of the logic in place. However, when the level first loads, the UTEffectsGenerator doesn't yet have a UTEffect assigned to it. So, let's fix that. Right click to open the context menu, and create a new event Kismet node which triggers when the level is loaded and visible.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_032.jpg"/><br/> <strong><font color=blue>Figure 12.32 – The Level Loaded and Visble event has been added.</font></strong>
<p />
<strong>25.</strong>	All we need to do now is to link up the Level Loaded And Visible Kistmet node to the Random Kismet node. We do this because we only need to set an effect to the UTEffectsGenerator and nothing else when the level is loaded.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_033.jpg"/><br/> <strong><font color=blue>Figure 12.33 – The new event is linked to the Random Switch.</font></strong>
<p />
<strong>26.</strong>	And that's all we will need to do with Kismet. Now we need to test everything. Press the Build All button in the main toolbar to build the entire level.
<p />
<strong>27.</strong>	Once the level has been built, click on the PIE button to launch a small window from which you can test this level out.
<p />
<strong>28.</strong>	Run through the volume placed in the level. You should see one of the effects. It works!
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_034.jpg"/><br/> <strong><font color=blue>Figure 12.34 – One of the effects is activated.</font></strong>
<p />
<strong>29.</strong>	Because we created editable variables within UTEffect_Gibbage and UTEffect_GrenadeRing, they both show up in Unreal Editor. Using this, the level designer is able to modify the way the effect works. By exposing more variables like this, your effects could wind up being very flexible for the programmer. Feel free to go back and adjust these variables to create different effects.
<p />
<img src="rsrc/Three/MasteringUnrealScriptDelegates/CH_12_FIGURE_035.jpg"/><br/> <strong><font color=blue>Figure 12.35 – The editable properties of the Gibbage and Grenade effects.</font></strong>
<p />
In this tutorial we looked at how we could use delegates together with Kismet. Because Kismet is more object orientated with its approach, the fact that delegates bind to a function within an instance allows this example to work the way it does. This is important because we also wanted to allow level designers not only to be able to alter what effect was generated by the effects generator, but also to tweak each effect in a way that was easy to use. While there are methods to do this, delegates not only made this task a lot easier to do, it was also done in a rather flexible way.
<p />
<h2><a name="12.10 - SUMMARY"></a> 12.10 - SUMMARY </h2>
<p />
Over this chapter we have looked into delegates in depth, and I hope that you have been able to take away something from this chapter. Typically delegates are used when the execution of code changes a lot, or if you just need to write some particularly flexible code. Delegates are useful tools within Unrealscript and definitely should always be considered a viable method of doing certain types of tasks. In Unreal Tournament 3 they were mostly used within the GUI, simply to allow third parties to modify and change the behavior of specific events. As shown by the tutorials in this chapter, delegates are useful almost anywhere really.
<p />
Unfortunately, when to use a delegate is largely decided upon experience. Since Unreal Engine has to determine which function the delegate maps to, this can be a relatively slow way of handling somethings, although it is a much cleaner method than a few other methods.
<p />
<h2><a name="SUPPLEMENTAL FILES"></a> SUPPLEMENTAL FILES </h2>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptDelegates/DM-Chapter12-Kismet.rar" target="_top">DM-Chapter12-Kismet.rar</a>: DM-Chapter12-Kismet.ut3 map
</li></ul>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptDelegates/Chapter12_CompleteSource.rar" target="_top">Chapter12_CompleteSource.rar</a>: Complete Source Files
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
