<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | VariableReplication    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">VariableReplication  </b></div>
<div id="tooltext">
<a href="https://udn.epicgames.com/Three/VariableReplicationJP" class="restricted" class="restricted" class="twikiLink">日本語訳</a><br><a href="https://udn.epicgames.com/Three/VariableReplicationCH" class="restricted" class="restricted" class="twikiLink">中国翻译</a><br><a href="VariableReplicationKR.html" class="twikiLink">한국어</a><br>

<!-- Three/VariableReplication -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="ReplicationHome.html" class="twikiLink">Networking &amp; Replication</a></b> &gt; Variable Replication
</div>
<hr size="1" noshade="noshade">
<p />
<h1><a name="Variable Replication"></a> Variable Replication </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="VariableReplication.html#Variable Replication"> Variable Replication</a> <ul>
<li> <a href="VariableReplication.html#Overview"> Overview</a>
</li> <li> <a href="VariableReplication.html#Reliability of variable data"> Reliability of variable data</a>
</li> <li> <a href="VariableReplication.html#Newly relevant actors (Spawning)"> Newly relevant actors (Spawning)</a>
</li> <li> <a href="VariableReplication.html#A time for variable replication"> A time for variable replication</a>
</li> <li> <a href="VariableReplication.html#Client to server replication"> Client to server replication</a>
</li> <li> <a href="VariableReplication.html#Native Replication"> Native Replication</a>
</li> <li> <a href="VariableReplication.html#Replication only when necessary"> Replication only when necessary</a>
</li> <li> <a href="VariableReplication.html#Special Replication Variables"> Special Replication Variables</a>
</li> <li> <a href="VariableReplication.html#Variable Replication Examples"> Variable Replication Examples</a> <ul>
<li> <a href="VariableReplication.html#PlayerPawn"> PlayerPawn</a> <ul>
<li> <a href="VariableReplication.html#Owner, Role, _RemoteRole"> Owner, Role, RemoteRole</a>
</li> <li> <a href="VariableReplication.html#b_NetOwner, Inventory"> bNetOwner, Inventory</a>
</li> <li> <a href="VariableReplication.html#Mesh, _PrePivot, b_MeshEnviroMap, Skin, _MultiSkins, Fatness, _AmbientGlow, _ScaleGlow, bUnlit"> Mesh, PrePivot, bMeshEnviroMap, Skin, MultiSkins, Fatness, AmbientGlow, ScaleGlow, bUnlit</a>
</li> <li> <a href="VariableReplication.html#b_FixedRotationDir, b_RotateToDesired, _RotationRate, _DesiredRotation"> bFixedRotationDir, bRotateToDesired, RotationRate, DesiredRotation</a>
</li> <li> <a href="VariableReplication.html#Physics, Acceleration, bBounce"> Physics, Acceleration, bBounce</a>
</li> <li> <a href="VariableReplication.html#Location"> Location</a>
</li> <li> <a href="VariableReplication.html#Rotation"> Rotation</a>
</li> <li> <a href="VariableReplication.html#Velocity"> Velocity</a>
</li> <li> <a href="VariableReplication.html#AnimSequence, _SimAnim, _AnimMinRate, b_AnimNotify"> AnimSequence, SimAnim, AnimMinRate, bAnimNotify</a>
</li></ul>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
Variables are one of two types of data that can be sent through replication statements, (the other being functions.) Here, we'll be discussing how data is replicated from one Unreal instance to another. There's a lot of little things that serve to complicate the process a bit more than may be expected at first.
<p />
Variables are replicated to keep the other machine updated about changes on the local machine. In most cases, this means the Unreal server replicates variables to the client to tell it about changed information. If the velocity of a player changes, it needs to replicate it to the client so that the client can properly simulate the behavior of this player for the time inbetween two network updates.
<p />
<p />
<h2><a name="Reliability of variable data"></a> Reliability of variable data </h2>
<hr size="1" noshade="noshade">
The simple answer, is that variables are always reliable. When an actor's variables are replicated, the retirement associated with the variable for that object gets a copy of the outgoing packetid. If a negative acknowledgement comes in for that packet, then the variables associated with that packetid are put in the channel's Dirty array. The next time the actor is replicated, it will add all of these variables if they weren't going to be replicated otherwise. So variable data is guaranteed to reach the other side, but it is not reliable in the sense that one must wait for update one before processing update two.
<p />
<p />
<h2><a name="Newly relevant actors (Spawning)"></a> Newly relevant actors (Spawning) </h2>
<hr size="1" noshade="noshade">
When an actor becomes relevant to a client, a new <strong>UActorChannel</strong> is created on the connection, which causes an actor of the appropriate class to be spawned on the client, with the defaultproperties of the actor. If the server set variables immediately after the spawning of the actor, (before the relevancy checks), then assuming those variables meet the replication statements, they will be sent to the client as an addendum to the actor's data. Since replication is not done until the end of the current tick, you have a lot of time in which to set the variables for their initial replication with the actor itself.
<p />
In deciding what vars to replicate initially, the server will send any variables that differ from the defaultproperties. If the server has a different idea of the defaultproperties of an actor versus the client, then the server will only replicate the variable if it differs from the server's version. (By the same token, if a variable is changed in client-side code, the server will not know about it, and so the server will not replicate changed data.)
<p />
<p />
<h2><a name="A time for variable replication"></a> A time for variable replication </h2>
<hr size="1" noshade="noshade">
Replicated variables are only replicated at the end of each tick. That means that if you change the variable repeatedly during a loop, or some other block of code, only the final value will be replicated. If you change a variable many times during a tick, and change it back to its original value when the tick completes, then no variable change will have been seen, and no network bandwidth will have been spent.
<p />
Of course, there is an exception to this. If you spawn a new actor on the server, you have until the end of the tick before the variables are replicated. However, if you call any replicated functions, those replicated functions get sent immediately, and in order for the other side to receive them, it must have an actor to operate on. So if the actor has not been replicated yet, Unreal will force-replicate the actor and it's variables when the first replicated function is called. At the end of the tick, it will then re-check the actor for what variables to send out.
<p />
<p />
<h2><a name="Client to server replication"></a> Client to server replication </h2>
<hr size="1" noshade="noshade">
Client to server replication can only be done through replication functions. Variables cannot be replicated from client to server.
<p />
<p />
<!--  -->
<p />
<p />
<h2><a name="Replication only when necessary"></a> Replication only when necessary </h2>
<hr size="1" noshade="noshade">
Further optimizations exist for variable replications as well. A variable will only be replicated to the client if the server thinks the client has the incorrect version compared to the server's latest version. When the server goes to replicate data, it compares the current value against the value that was last sent out, stored in the Recent array. If this is the first time being replicated, the code checks the current value against the value in the default properties of the actor. So the server will send out a changed variable regardless of what is on the client. If a value is changed in a simulated function that is run on both the client and the server, the server will not know about the client's value, and will still replicate it's own value. If this variable can guaranteed to be changed on both the client and server in all cases, then you could remove the replication conditions on this value. If this actor goes in and out of relevancy, then when it becomes relevant, it will be initialized on the client to the defaultproperties, as mentioned earlier. If this is incorrect, and you have no replication values, it will stay incorrect. One can use the <strong>bNetInitial</strong> variable to replicate something when the actor is first relevant, and then rely upon simulated functions executing on both the server and client to change the value from then on. The variable <strong>bNetInitial</strong>, and it's friends, is discussed next.
<p />
<p />
<h2><a name="Special Replication Variables"></a> Special Replication Variables </h2>
<hr size="1" noshade="noshade">
When writing replication conditionals, there are a few helpful variables which you can use in evaluating whether a function/variable should be replicated. These variables are defined in actor, and are:
<p /> <ul>
<li> <strong>bNetInitial</strong> - true if this is the first time this actor is being replicated across the network. Useful for variables that differ from the defaultproperties, yet will not change over the life of the actor.
</li> <li> <strong>bNetOwner</strong> - true if the player we are replicating to owns this actor directly.
</li> <li> <strong>bNetRelevant</strong> - Actor is currently relevant. Only valid server side.
</li> <li> <strong>bDemoRecording, bClientDemoRecording, bRepClientDemo, bClientDemoNetFunc, bDemoOwner</strong> - used for demo recording purposes.
</li></ul>
<p />
<p />
<h2><a name="Variable Replication Examples"></a> Variable Replication Examples </h2>
<hr size="1" noshade="noshade">
Now would probably be a good time to go through some important examples of replication and how it is used with variables, to give you a better idea of how things work, and to help give examples for your own adventures in coding.
<p />
Let's take a few examples, and describe exactly what they do. We'll start off with the easy ones, and gradually work our way up in complexity. The following examples are all taken from <strong>Actor</strong>, unless specified otherwise.
<p />
<img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note:</strong> these examples actually come from Unreal Tournament, the actual code is not relevant anymore. However the examples below are still useful to understand variable replication.
<p />
<p />
<h3><a name="PlayerPawn"></a> PlayerPawn </h3>
<h4><a name="Owner, Role, _RemoteRole"></a> Owner, Role, RemoteRole </h4>
<div class="codesnippet">
<pre>
  if (Role &#61;&#61; ROLE&#95;Authority)
    Owner, Role, RemoteRole;
</pre>
</div>
<p />
This ensures that the owner of an object is always replicated to the client. Remember that the owner's variables themselves are not replicated, (because there is no recursive replication,) but the actor itself is. This means that simple comparisons <strong>if (PlayerPawn == Owner)</strong> will work fine because the reference to the <strong>Owner</strong> is replicated to the client.
<p />
Replicating <strong>Role</strong> and <strong>RemoteRole</strong> may seem strange at first, since they should be reversed on the client. However, there's native code that causes that switch to be made. On the client, it will ensure that those two variables are reversed, so that <strong>RemoteRole</strong> is <strong>ROLE_Authority</strong>. You may wonder why they are even replicated in the first place. While the client never has any direct use for these variables in the code, there is one easy-to-overlook place where they are vitally important: Replication statements. When the client is evaluating whether it needs to replicate a certain function call to the server, or a PlayerPawn's variable to the server, the client needs accurate copies of what <strong>Role</strong> and <strong>RemoteRole</strong> are. Without those, it would be unable to make the necessary decisions on what to send to the server. And since the server checks the validity of the replication data sent to the server with <strong>Role/RemoteRole</strong>, the client needs the latest copy in order to successfully replicate that data.
<p />
<h4><a name="b_NetOwner, Inventory"></a> bNetOwner, Inventory </h4>
<div class="codesnippet">
<pre>
if (bNetOwner &#38;&#38; Role &#61;&#61; ROLE&#95;Authority)
  bNetOwner, Inventory;
</pre>
</div>
<p />
Inventory is the head of the linked list that lists the entire Inventory for the Actor (usually only utilized with <strong>Pawn</strong>). We want the inventory to be replicated to the client, so that he knows what Inventory he has, to display on his HUD, and stuff (makes sense, right?). Simply replicating the head of a linked list (where each object points to the next in the list) is not enough however. Each actor must itself be relevant (satisfied by the criterion that it must be owned by the current PlayerPawn), and each link itself must be replicated. And since Inventory subclass Actor somewhere in the chain, Inventory also has a replicated Inventory variable. And that's how you are able to see your Inventory client-side. And since I don't need to know the full Inventory list of what every other player in the game has (the current weapon and the Shield Belt effect are transferred via other means), the Inventory will only be replicated if the client is the owner.
<p />
The other variable in the above replication statement is <strong>bNetOwner</strong>. Since this is set natively on both the client and server, this variable does not need to be replicated. It could be argued that it adds a tiny amount to bandwidth, but its effect is probably negligible.
<p />
<h4><a name="Mesh, _PrePivot, b_MeshEnviroMap, Skin, _MultiSkins, Fatness, _AmbientGlow, _ScaleGlow, bUnlit"></a> Mesh, PrePivot, bMeshEnviroMap, Skin, MultiSkins, Fatness, AmbientGlow, ScaleGlow, bUnlit </h4>
<div class="codesnippet">
<pre>
if(DrawType &#61;&#61; DT&#95;Mesh &#38;&#38; Role &#61;&#61; ROLE&#95;Authority)
  Mesh, PrePivot, bMeshEnviroMap, Skin, MultiSkins, Fatness, AmbientGlow, ScaleGlow, bUnlit;
</pre>
</div>
<p />
Here we see that all these mesh-specific variables are <strong>only</strong> replicated if this actor is currently being displayed as a mesh. If it's a sprite, or a brush, or even no DrawType at all, there is no reason to send these variables.
<p />
Now let's get into some of the more complex variable replication statements...
<p />
<h4><a name="b_FixedRotationDir, b_RotateToDesired, _RotationRate, _DesiredRotation"></a> bFixedRotationDir, bRotateToDesired, RotationRate, DesiredRotation </h4>
<div class="codesnippet">
<pre>
if (RemoteRole &#61;&#61; ROLE&#95;SimulatedProxy)
  Base;
</pre>
</div>
<p />
Here we see a slightly more complex replication statement, that does not involve <strong>Role == ROLE_Authority</strong>. Here we see that the current <strong>Base</strong> (set via <em>SetBase</em>) is only replicated if the actor is set to be a simulated proxy. So if you are using <em>SetBase</em>, make sure it's a simulated proxy, or if it's not a simulated proxy, use something other than <em>SetBase</em>. Or if you need both <em>SetBase</em> and a simulated proxy, the Base will not be replicated for you. You'll have to work out some other mechanism to do that, probably a simulated function that sets the base, so it is run on the client, (more on this later, too.) You might still have troubles when the actor gets its simulated function called while the actor was not relevant. This results in the simulated function never being called client side, and then when the actor does finally become relevant, it's as if that function was never called (and the base isn't set), which will result in those things affectionately referred to as 'bugs.' You can make the actor being attached (and what it's being attached to) <strong>bAlwaysRelevant</strong> so that the simulated functions will always be called, but that might be a bit too harsh on network bandwidth.
<p />
<div class="codesnippet">
<pre>
if(RemoteRole &#61;&#61; ROLE&#95;SimulatedProxy &#38;&#38; Physics &#61;&#61; PHYS&#95;Rotating &#38;&#38; bNetInitial)
  bFixedRotationDir, bRotateToDesired, RotationRate, DesiredRotation;
</pre>
</div>
<p />
This one is still relatively easy, but it's getting more complex. Here we have similar logic to what was seen above, with the server only sending these variables to the client if the client is a simulated proxy. However, since all these variables apply <strong>only</strong> to <strong>PHYS_Rotating</strong>, there is no need to replicate these variables to the client if the client is not using <strong>PHYS_Rotating</strong>. And finally, a very important clause at the end is the <strong>bNetInitial</strong> one. This states that these variables will only be replicated to the client when it is being replicated for the first time.
<p />
<h4><a name="Physics, Acceleration, bBounce"></a> Physics, Acceleration, bBounce </h4>
<div class="codesnippet">
<pre>
if(bSimFall &#124;&#124; (RemoteRole &#61;&#61; ROLE&#95;SimulatedProxy &#38;&#38; bNetInitial &#38;&#38; !bSimulatedPawn))
  Physics, Acceleration, bBounce;
</pre>
</div>
<p />
Here we have some of the interesting variables replicated. We see that if the <strong>bSimFall</strong> is set to true, it will replicate the <strong>Physics</strong> to the client. This is used when tossing weapons from your inventory. When they are tossed, they require a <strong>Physics</strong> change from <strong>PHYS_None</strong> while sitting in your Inventory to <strong>PHYS_Falling</strong> as they fly through the air. They then get set back to <strong>PHYS_None</strong> when they land on the ground. All these <strong>Physics</strong> changes are accomplished by setting <strong>bSimFall</strong> at the key points during the TournamentWeapon's life. It is set to true when it is thrown from the inventory, to capture the change, and left on until it hits the ground, where it changes <strong>Physics</strong> again. After it finally hits and has its physics reset, <strong>bSimFall</strong> is set to false so no further <strong>Physics</strong> changes occur. Looking at the second half of the statement, we see that the <strong>Physics</strong> is replicated <strong>only</strong> if it's a simulated proxy, it's the first time this actor is being replicated over the internet, <strong>and</strong> it's not a simulated pawn. The <strong>bSimulatedPawn</strong> variable is set to true if it's a Pawn with a <strong>RemoteRole</strong> of <strong>ROLE_SimulatedProxy</strong> (who would have thought?) This means any changes to the <strong>Physics</strong> of a simulated proxy non-pawn actor before it is replicated will be replicated to the client. The <strong>Physics</strong> are never replicated for pawns. Rather, the code for their physics is hard-wired into the code to cause them to be pushed to the ground. Basically, when a pawn jumps, the server sets his vertical velocity so that he travels upwards. That Velocity is then replicated to the client (described below). The client then checks if the pawn is a player (eg: a bot or a PlayerPawn), that they are currently unable to fly (set via the Pawn's <strong>bCanFly</strong> variable), and that they are not in a water zone (since that involves different gravities and physics). So in fact, the <strong>Physics</strong> for a pawn is never replicated to the client, it only appears to do so. If you are attempting to create alternate physics with the PlayerPawn, you will need to ensure that you set <strong>bCanFly</strong> to true so that the native code does not enforce the falling Physics upon the player when he's on the wall or in the air. You must then implement the alternate means of transportation yourself.
<p />
<h4><a name="Location"></a> Location </h4>
<div class="codesnippet">
<pre>
if (!bCarriedItem &#38;&#38; (bNetInitial &#124;&#124; bSimulatedPawn &#124;&#124; RemoteRole &#60; ROLE&#95;SimulatedProxy) &#38;&#38; Role &#61;&#61; ROLE&#95;Authority)
  Location;
</pre>
</div>
<p />
Here we see another important variable, <strong>Location</strong>, and it's replication. We see that it is not replicated for carried items. This is useful in the case of <strong>Inventory</strong>. When a player is carrying it, there's no reason its location should be replicated, since it isn't used for anything. replicating a player's entire inventory would be quite the strain on network bandwidth. Let's look at the next section of the statement. The location is replicated if this is the first time the actor is being replicated (assuming the other parts of the conditional are true). This is very useful, since all pawns will be spawned in different locations when you enter the game, and rockets will need their start locations set when they spawn out of a rocket launcher, etc. The location is also sent if this is a <strong>bSimulatedPawn</strong>. This helps correct any errors that may occur in replicating pawns. Since a pawn can change direction, and a client may not always know about it (due to lag, etc), this location resetting is the only way in which the locational updates can be 'corrected'. Note that this is not used to correct your own location when you experience lag. When that happens, you are an <strong>AutonomousProxy</strong>, and functions specific to PlayerPawn handle that (namely <strong>ClientAdjustPosition()</strong>). For example, <strong>PHYS_Walking</strong> is not like <strong>PHYS_Projectile</strong>, where the position can be predicted with great accuracy. <strong>PHYS_Walking</strong> just means "keep them attached to the ground", basically, the client's only updates (without location) would have been their velocity, which can easily lead to errors in the player's movements over any significant amount of time. This location is used as a correcting factor, making sure the client's view does not stray too far from where he expects the player to be, while at the same time keeping the velocity's replication so he can be predicted in between server updates. The other option for allowing the <strong>Location</strong> to replicate is that of where the <strong>RemoteRole</strong> is less than a <strong>ROLE_SimulatedProxy</strong>. A <strong>SimulatedProxy</strong> would not get sent <code>Location</code> updates, since it would be predicted through the use of the <code>Velocity</code> and the current Physics.
<p />
<h4><a name="Rotation"></a> Rotation </h4>
<div class="codesnippet">
<pre>
if (!bCarriedItem &#38;&#38; (DrawType &#61;&#61; DT&#95;Mesh &#124;&#124; DrawType &#61;&#61; DT&#95;Brush) &#38;&#38; (bNetInitial &#124;&#124; bSimulatedPawn &#124;&#124; RemoteRole &#60; ROLE&#95;SimulatedProxy) &#38;&#38; Role &#61;&#61; ROLE&#95;Authority)
  Rotation;
</pre>
</div>
<p />
Here we see another important variable, <strong>Rotation</strong>. This also has the same <strong>!bCarriedItem</strong> clause, for the same reasons as described above. The rotation is also only replicated if this actor is a mesh or a brush. Since sprites always face the player, replicating their rotation is useless. The <strong>bNetInitial</strong> also causes the rotation to be replicated the first time through, (again, assuming if the other conditions are true,) since rockets need to be facing in the right direction when it has them flying through the air. Their velocity determines their direction of movement, but the direction they are facing which is equally important, is determined by their rotation. The rotation is replicated if they are a simulated pawn (every PlayerPawn and bot in the level except your own self). This is so you can see what direction the other people are facing. The <strong>ViewRotation</strong> (which determines where the client is looking), is sent to the server via <strong>ServerMove()</strong>, where it is translated into a rotation. It is this rotation that is then replicated to the clients. Rotation updates do not need any interpolating between updates like location does. Location lag is much more noticeable when the player is moving quickly, but you never really notice <strong>Rotation</strong> lag. Besides, there is no real way to predict or forecast rotation. It depends entirely upon the other user's mouse.
<p />
<h4><a name="Velocity"></a> Velocity </h4>
<div class="codesnippet">
<pre>
if (bSimFall &#124;&#124; ((RemoteRole &#61;&#61; ROLE&#95;SimulatedProxy &#38;&#38; (bNetInitial &#124;&#124; bSimulatedPawn)) &#124;&#124; bIsMover))
  Velocity;
</pre>
</div>
<p />
Here's one of the last important variables with a complex replication statement. The velocity is replicated if it has <strong>bSimFall</strong> set, used when throwing weapons from your inventory. The <strong>PHYS_Falling</strong> alone isn't enough. It needs to know exactly what it's initial velocity is when it is launched from the pawn. And no, <strong>bNetInitial</strong> will not work here, since it's not the first time it's being replicated. It's existed as a weapon for quite some time. It's just for the initial velocity of when it's being thrown from the player that we want updates. Moving along, we see that <strong>SimulatedProxies</strong> get their <strong>Velocities</strong> replicated if it the first time on the replication channel, for newly spawned rockets, or for grenades, or shock projectiles, etc. <strong>SimulatedProxies</strong> also get their velocities replicated if they are a simulated pawn, as all the various pawns need their velocities replicated so that they can be predicated locally. And finally, movers get their velocities replicated, so that the client can accurately predict the mover's movement locally.
<p />
<h4><a name="AnimSequence, _SimAnim, _AnimMinRate, b_AnimNotify"></a> AnimSequence, SimAnim, AnimMinRate, bAnimNotify </h4>
<div class="codesnippet">
<pre>
if (DrawType &#61;&#61; DT&#95;Mesh &#38;&#38; ((RemoteRole &#60;&#61; ROLE&#95;SimulatedProxy  &#38;&#38; (!bNetOwner &#124;&#124; !bClientAnim)) &#124;&#124; bDemoRecording))
  AnimSequence, SimAnim, AnimMinRate, bAnimNotify;
</pre>
</div>
<p />
There are a few more variables here, all of which relate to animation. These variables are only replicated if it is currently being drawn as a Mesh. If we are recording a demo, then the animations are always sent. Otherwise, it checks the somewhat confusing conditional. Simulated proxies, which include pawns and rockets and other projectiles, are all simulated proxies, and so they do not receive animations from the server. Instead, the client animates them with its client-side prediction. In the case of pawns, this is handled internally in the engine (for another tutorial ;), and you need not worry about it.
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
