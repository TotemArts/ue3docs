<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | MobileInputSystem    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">MobileInputSystem  </b></div>
<div id="tooltext">
<a href="MobileInputSystemJP.html" class="twikiLink">日本語訳</a><br><a href="MobileInputSystemCH.html" class="twikiLink">中国翻译</a><br><a href="MobileInputSystemKR.html" class="twikiLink">한국어</a><br>

<!-- Three/MobileInputSystem -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="MobileHome.html" class="twikiLink">Mobile Home</a></b> &gt; Mobile Input System
</div>
<hr size="1" noshade="noshade">
<h1><a name="Mobile Input System"></a> Mobile Input System </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="MobileInputSystem.html#Mobile Input System"> Mobile Input System</a> <ul>
<li> <a href="MobileInputSystem.html#Overview"> Overview</a>
</li> <li> <a href="MobileInputSystem.html#MobilePlayerInput"> MobilePlayerInput</a> <ul>
<li> <a href="MobileInputSystem.html#MobilePlayerInput Properties"> MobilePlayerInput Properties</a>
</li> <li> <a href="MobileInputSystem.html#MobilePlayerInput Delegates"> MobilePlayerInput Delegates</a>
</li> <li> <a href="MobileInputSystem.html#MobilePlayerInput functions"> MobilePlayerInput functions</a>
</li> <li> <a href="MobileInputSystem.html#TouchDataEvent"> TouchDataEvent</a>
</li> <li> <a href="MobileInputSystem.html#TouchData"> TouchData</a>
</li></ul>
</li> <li> <a href="MobileInputSystem.html#Input Zones"> Input Zones</a> <ul>
<li> <a href="MobileInputSystem.html#Input Groups"> Input Groups</a>
</li> <li> <a href="MobileInputSystem.html#MobileInputZone"> MobileInputZone</a> <ul>
<li> <a href="MobileInputSystem.html#MobileInputZone Properties"> MobileInputZone Properties</a>
</li> <li> <a href="MobileInputSystem.html#MobileInputZone Delegates"> MobileInputZone Delegates</a>
</li> <li> <a href="MobileInputSystem.html#MobileInputZone Functions"> MobileInputZone Functions</a>
</li> <li> <a href="MobileInputSystem.html#Input Zone Types"> Input Zone Types</a>
</li> <li> <a href="MobileInputSystem.html#Input Zone States"> Input Zone States</a>
</li></ul>
</li> <li> <a href="MobileInputSystem.html#Rendering and Appearance"> Rendering and Appearance</a>
</li> <li> <a href="MobileInputSystem.html#Sizing and Positioning"> Sizing and Positioning</a>
</li> <li> <a href="MobileInputSystem.html#Adding Input Zones"> Adding Input Zones</a>
</li> <li> <a href="MobileInputSystem.html#Defining Input Groups"> Defining Input Groups</a>
</li> <li> <a href="MobileInputSystem.html#Debugging"> Debugging</a>
</li></ul>
</li> <li> <a href="MobileInputSystem.html#Mobile Input in _UnrealScript"> Mobile Input in UnrealScript</a> <ul>
<li> <a href="MobileInputSystem.html#Touch Input"> Touch Input</a> <ul>
<li> <a href="MobileInputSystem.html#Touch Events"> Touch Events</a>
</li> <li> <a href="MobileInputSystem.html#Handling Touches"> Handling Touches    </a>
</li> <li> <a href="MobileInputSystem.html#Picking Example"> Picking Example</a>
</li></ul>
</li> <li> <a href="MobileInputSystem.html#Motion Input"> Motion Input</a>
</li></ul>
</li> <li> <a href="MobileInputSystem.html#Mobile Input in Kismet"> Mobile Input in Kismet</a> <ul>
<li> <a href="MobileInputSystem.html#Managing Input Zones in Kismet"> Managing Input Zones in Kismet</a> <ul>
<li> <a href="MobileInputSystem.html#Adding and Removing Input Zones"> Adding and Removing Input Zones</a>
</li> <li> <a href="MobileInputSystem.html#Handling Button Input Zones"> Handling Button Input Zones</a>
</li> <li> <a href="MobileInputSystem.html#Handling Joystick Input Zones"> Handling Joystick Input Zones</a>
</li></ul>
</li> <li> <a href="MobileInputSystem.html#Handling Kismet Touch Input Events"> Handling Kismet Touch Input Events</a>
</li> <li> <a href="MobileInputSystem.html#Handling Kismet Motion Input Events"> Handling Kismet Motion Input Events</a>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
There are three different methods to manage touch and motion input on your device. The simplest way is through the MobileInputZones which can be thought of as pre-designed input subsystems. If input zones do not give you the level of control you need, the entire input system can be managed in Unrealscript using several delegates located in the MobilePlayerInput class. Finally, a set of Kismet events and actions are available allowing for quick prototyping.
<p />
<h2><a name="MobilePlayerInput"></a> MobilePlayerInput </h2>
<hr size="1" noshade="noshade">
The <code>MobilePlayerInput</code> class is the hub for all input from the player on mobile devices. It takes in the touch input from the device's screen as well as motion input from the various motion sensors available on the device. Access to this input is then provided through properties and accessor functions (or delegates in some cases).
<p />
<code>MobilePlayerInput</code> is defined as <code>within(GamePlayerController)</code>, meaning it can only be used in classes which inherit, either directly or indirectly through its hierarchy, from the <code>GamePlayerController</code> class. To force the <code>MobilePlayerInput</code> class to be used, assign it to the <code>InputClass</code> property in the <code>defaultproperties</code> block of your custom <code>PlayerController</code> class (which extends from <code>GamePlayerController</code> of course).
<p />
<div class="codetitlebar">
SimplePC.uc
</div>
<div class="codesnippet">
<pre>
defaultproperties
{
  InputClass&#61;class&#39;GameFramework.MobilePlayerInput&#39;
}
</pre>
</div>
<p />
<h3><a name="MobilePlayerInput Properties"></a> MobilePlayerInput Properties </h3>
<p />
<h4><a name="Menus"></a><a name=" Menus"></a>  Menus </h4> <ul>
<li> <strong>InteractiveObject</strong> - The <code>MobileMenuObject</code> the user is currently interacting with. For example, if the user presses on a button, it becomes the <code>InteractiveObject</code> until the user raises their finger causing an UnTouch event.
</li> <li> <strong>MobileMenuStack</strong> - The array holding the stack of mobile menu scenes to render and pass input to. See the <a href="MobileMenuTechnicalGuide.html" class="twikiLink">Mobile Menu Technical Guide</a> for more information on mobile menu scenes.
</li></ul>
<p />
<h4><a name="Motion"></a><a name=" Motion"></a>  Motion </h4>
<img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note:</strong> Most of these variables either are no longer used or do not exist as of UDK Feb 2012 <ul>
<li> <strong>MobilePitch</strong> - The current tilt value of the device's gyroscope, if available.
</li> <li> <strong>MobilePitchCenter</strong> - The center value for the device pitch.
</li> <li> <strong>MobilePitchMultiplier</strong> - Scaling factor for the device's pitch, adjusting sensitivity to pitch motion.
</li> <li> <strong>MobileYaw</strong> - The current yaw value of the device's gyroscope, if available.
</li> <li> <strong>MobileYawCenter</strong> - The center value for the device yaw.
</li> <li> <strong>MobileYawMultiplier</strong> - Scaling factor for the device's yaw, adjusting sensitivity to yaw motion.
</li> <li> <strong>MobilePitchDeadzoneSize</strong> - The distance from the <code>MobilePitchCenter</code> that the <code>MobilePitch</code> value must be to be considered for input. This would be used if motion input was being used for controls in the game.
</li> <li> <strong>MobileYawDeadzoneSize</strong> - The distance from the <code>MobileYawCenter</code> that the <code>MobileYaw</code> value must be to be considered for input. This would be used if motion input was being used for controls in the game.
</li> <li> <strong>DeviceMotionAttitude</strong> - A <code>Vector</code> describing the attitude or orientation of the device. <ul>
<li> <strong>X</strong> - Represents rotation around the axis coming straight out from the screen.
</li> <li> <strong>Y</strong> - Only valid if the device has a gyroscope.
</li> <li> <strong>Z</strong> - Represents rotation around the horizontal axis of the device.
</li></ul>
</li> <li> <strong>DeviceMotionRotationRate</strong> - A <code>Vector</code> holding the rate of change of the device's attitude. This value is much more accurate on devices with a gyroscope.
</li> <li> <strong>DeviceMotionGravity</strong> - A <code>Vector</code> holding the gravity vector of the device. Only valid if the device has a gyroscope.
</li> <li> <strong>DeviceMotionAcceleration</strong> - A <code>Vector</code> holding the current linear acceleration of the device. Only valid if the device has a gyroscope.
</li> <li> <strong>bDeviceHasGyroscope</strong> - TRUE if device has a gyroscope.
</li> <li> <strong>DeviceGyroRawData</strong> - A <code>Vector</code> holding the raw gyroscope motion data. Values are in the range [0.0, 1.0].
</li> <li> <strong>bDeviceHasAccelerometer</strong> - TRUE if device has an accelerometer.
</li> <li> <strong>DeviceAccelerometerRawData</strong> - A <code>Vector</code> holding the raw accelerometer data. Values are in the range [0.0, 1.0]. <ul>
<li> <strong>X</strong> - Roll. Represents rotation around the axis coming straight out from the screen.
</li> <li> <strong>Y</strong> - Portrait Pitch. Represents rotation around the horizontal axis in portrait orientation.
</li> <li> <strong>Z</strong> - Lanscape Pitch. Represnts the rotation around the horizontal axis in landscape orientation.
</li></ul>
</li> <li> <strong>MobileSeqEventHandlers</strong> - An array of <code>SeqEvent_MobileBase</code> events looking to listen in on Motion events. <ul>
<li> <img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note:</strong> This is still used as of UDK Feb 2012
</li></ul>
</li> <li> <strong>aTilt</strong> - A vector describing the current orientation of the mobile device. (Used in UDK Feb 2012)
</li> <li> <strong>aRotationRate</strong> - A vector describing the rate of change of the tilt. (Used in UDK Feb 2012)
</li> <li> <strong>aGravity</strong> - A vector describing the gravity detected by the mobile device. (Used in UDK Feb 2012)
</li> <li> <strong>aAcceleration</strong> - A vector describing the linear acceleration detected by the device. (Used in UDK Feb 2012)
</li></ul>
<p />
<h4><a name="Touch"></a><a name=" Touch"></a>  Touch </h4> <ul>
<li> <strong>NumTouchDataEntries</strong> - Constant. Sets the number of touches that are tracked concurrently. This is set to 5.
</li> <li> <strong>Touches</strong> - An array of <code>TouchData</code> structures representing the touches being tracked.
</li> <li> <strong>MobileDoubleTapTime</strong> - The maximum amount of time that can elapse between 'taps' to register as a 'double tap'.
</li> <li> <strong>MobileMinHoldForTap</strong> -The minimum amount of time in seconds a touch must be held to register as a 'tap'.
</li> <li> <strong>MobileTapRepeatTime</strong> - The amount of time that will elapse between sending touch events for a touch that is being held.
</li> <li> <strong>bAllowTouchesInCinematic</strong> - If TRUE, touch input will be allowed and registered during cinematic sequences.
</li> <li> <strong>bDisableTouchInput</strong> - If TRUE, touches will not be registered as input.
</li> <li> <strong>bFakeMobileTouches</strong> - TRUE if the game is run with the <code>-simmobile</code> or <code>-simmobileinput</code> command line argument.
</li> <li> <strong>MobileInactiveTime</strong> - The amount of time in seconds that no touch input has been registered.
</li> <li> <strong>MobileRawInputSeqEventHandlers</strong> - An array of <code>SeqEvent_MobileRawInput</code> events looking to listen in on raw touch events
</li></ul>
<p />
<h4><a name="Zones"></a><a name=" Zones"></a>  Zones </h4> <ul>
<li> <strong>MobileInputGroups</strong> - An array of available input <a href="MobileInputSystem.html#MobileInputGroup" class="twikiAnchorLink">MobileInputGroups</a>.
</li> <li> <strong>CurrentInputGroup</strong> - References the currently active <a href="MobileInputSystem.html#MobileInputGroup" class="twikiAnchorLink">MobileInputGroup</a>. <ul>
<li> <img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note:</strong> This has been renamed to <strong>CurrentMobileGroup</strong> as of UDK Feb 2012
</li></ul>
</li> <li> <strong>MobileInputZones</strong> - An array of the existing <a href="MobileInputSystem.html#MobileInputZone" class="twikiAnchorLink">MobileInputZones</a>.
</li> <li> <strong>MobileInputZoneClasses</strong> - An array of class names mapped to the names of the <a href="MobileInputSystem.html#MobileInputZone" class="twikiAnchorLink">MobileInputZones</a>.
</li> <li> <strong>ZoneTimeout</strong> - The maximum amount of time that a zone can go without input before being consider timed out.
</li></ul>
<p />
<h3><a name="MobilePlayerInput Delegates"></a> MobilePlayerInput Delegates </h3> <ul>
<li> <strong>OnInputTouch() [Handle] [Type] [TouchLocation] [DeviceTimestamp]</strong> - Called by the engine when any touch event occurs. <ul>
<li> <strong>Handle</strong> - The unique identifier of the touch. See the <a href="MobileInputSystem.html#TouchData" class="twikiAnchorLink">TouchData</a> section for more information.
</li> <li> <strong>Type</strong> - The <code>ETouchType</code> type of the touch event. See the <a href="MobileInputSystem.html#TouchEvents" class="twikiAnchorLink">Touch Events</a> section for more information.
</li> <li> <strong>TouchLocation</strong> - The <code>Vector2D</code> location of the touch event in screen coordinates (pixels).
</li> <li> <strong>DeviceTimestamp</strong> - The time the touch event occurred.
</li></ul>
</li> <li> <strong>OnMobileMotion() [PlayerInput] [CurrentAttitude] [CurrentRotationRate] [CurrentGravity] [CurrentAcceleration]</strong> - Called by the engine when motion occurs on the device. <strong>NOTE:</strong> Depending on the device hardware, Gravity and Acceleration might not be valid. <img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note:</strong> This no longer exists in UDK Feb 2012    <ul>
<li> <strong>PlayerInput</strong> - A reference to the <code>PlayerInput</code> that owns the delegate.
</li> <li> <strong>CurrentAttitude</strong> - A <code>Vector</code> holding the current attitude (Pitch, Yaw, Roll) information of the device. <strong>Note:</strong> Yaw will only be valid if the device has a gyro.  Also, these values are independent on landscape vs. portrait.
</li> <li> <strong>CurrentRotationRate</strong> - A <code>Vector</code> holding the current rate of change of the device's attitude. This value is much more accurate on devices with a gyroscope.
</li> <li> <strong>CurrentGravity</strong> - A <code>Vector</code> holding the gravity vector of the device. Only valid if the device has a gyroscope.
</li> <li> <strong>CurrentAcceleration</strong> - A <code>Vector</code> holding the current linear acceleration of the device. Only valid if the device has a gyroscope.
</li></ul>
</li> <li> <strong>OnTouchNotHandledInMenu()</strong> - Invoked when the mobile menus did not process an <code>Touch_Began</code>.
</li> <li> <strong>OnPreviewTouch() [X] [Y] [TouchpadIndex]</strong> - Returns true/false for touches handled/not handled. <ul>
<li> <strong>X</strong> - Screen space X coordinate
</li> <li> <strong>Y</strong> - Screen space Y coordinate
</li> <li> <strong>TouchpadIndex</strong> - Which touch pad was touched
</li></ul>
</li></ul>
<p />
<h3><a name="MobilePlayerInput functions"></a> MobilePlayerInput functions </h3>
<p />
<h4><a name="Initialization"></a><a name=" Initialization"></a>  Initialization </h4> <ul>
<li> <strong>InitInputSystem()</strong> - Called by the <code>PlayerController</code> after the input system is created. Currently forces the touch input system to be initialized. Subclasses should override this to perform additional initialization.
</li> <li> <strong>ClientInitInputSystem()</strong> - Called on the client after the input system is created. Currently forces the touch input system to be initialized. Subclasses should override this to perform additional initialization.
</li> <li> <strong>InitTouchSystem()</strong> - Sets up the touch input system if mobile simulation is enabled or the game is running on a mobile device.
</li> <li> <strong>NativeInitializeInputSystem()</strong> - Native. Called by <code>InitTouchSystem()</code> native initialization of the input subsystem.
</li> <li> <strong>InitializeInputZones()</strong> - Queries the needed input zones from the game type and initializes them.
</li> <li> <strong>NativeInitializeInputZones()</strong> - Native. Called by <code>InitializeInputZones()</code> to initialize the input zones by iterating over them and calculating their bounds based on the current device resolution.
</li></ul>
<p />
<h4><a name="Input Events"></a><a name=" Input Events"></a>  Input Events </h4> <ul>
<li> <strong>SendInputKey() [Key] [Event] [AmountDepressed]</strong> - Sends an input key event, such as presses of the keys on the keyboard. This provides the ability to manually translate mobile input to standard keyboard input. <ul>
<li> <strong>Key</strong> - The <code>Name</code> of the key for which an event occurred. (KEY_Up, KEY_Down, etc.)
</li> <li> <strong>Event</strong> - The <code>EInputEvent</code> type of the input event. (<code>IE_Pressed</code>, <code>IE_Released</code>, <code>IE_Repeat_</code>, <code>IE_DoubleClick</code>, <code>IE_Axis</code>)
</li> <li> <strong>AmountDepressed</strong> - The amount the key is pressed for analog keys.
</li></ul>
</li> <li> <strong>SendInputAxis() [Key] [Delta] [DeltaTime]</strong> - Sends an input axis event, such as a joystick, thumb stick, or mouse movement. This provides the ability to manually translate mobile input to standard control input. <ul>
<li> <strong>Key</strong> - The <code>Name</code> of the axis that moved. (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
</li> <li> <strong>Delta</strong> - The amount the axis moved.
</li> <li> <strong>DeltaTime</strong> - The amount of time in seconds since the last update for the axis.
</li></ul>
</li></ul>
<p />
<h4><a name="Input Zones"></a><a name=" Input Zones"></a>  Input Zones </h4> <ul>
<li> <strong>FindZone() [ZoneName]</strong> - Searches for and returns an input zone by name from the <code>MobileInputZones</code> array. <ul>
<li> <strong>ZoneName</strong> - A <code>String</code> specifying the name of the input zone to search for.
</li></ul>
</li> <li> <strong>FindorAddZone() [ZoneName]</strong> - Searches for and returns an input zone by name from the <code>MobileInputZones</code> array. If the input zone is not found, a new zone is created, added to the <code>MobileInputZones</code> array, and a reference to the new zone is returned. <ul>
<li> <strong>ZoneName</strong> - A <code>String</code> specifying the name of the input zone to search for and/or add.
</li></ul>
</li> <li> <strong>HasZones()</strong> - Returns whether the <code>MobilePlayerInput</code> currently has any input zones.
</li> <li> <strong>GetCurrentZones()</strong> - Returns all of the input zones associated with the current input group as an array of <code>MobileInputZones</code>.
</li> <li> <strong>ActivateInputGroup() [GroupName]</strong> - Exec. Sets a new input group as being active, and therefore able to receive input. <ul>
<li> <strong>GroupName</strong> - A <code>String</code> specifying the name of the input group to set active.
</li></ul>
</li> <li> <strong>SetMobileInputConfig() [GroupName]</strong> - Exec. Sets a new input group as being active, and therefore able to receive input. <ul>
<li> <strong>GroupName</strong> - A <code>String</code> specifying the name of the input group to set active.
</li></ul>
</li></ul>
<p />
<h4><a name="Kismet"></a><a name=" Kismet"></a>  Kismet </h4> <ul>
<li> <strong>RefreshKismetLinks()</strong> - Registers all <code>SeqEvent_MobileBase</code> and <code>SeqEvent_MobileRawInput</code> events in the level's Kismet sequence, assigning them as handlers.
</li> <li> <strong>AddKismetEventHandler() [NewHandler]</strong> - Adds a <code>SeqEvent_MobileBase</code> Kismet event as a new mobile motion event handler which will receive input events when motion occurs.
</li> <li> <strong>AddKismetRawInputEventHandler() [NewHandler]</strong> - Adds a <code>SeqEvent_MobileRawInput</code> Kismet event as a new mobile touch event handler which will receive input events when touches occur.
</li></ul>
<p />
<h4><a name="Menu Scenes"></a><a name=" Menu Scenes"></a>  Menu Scenes </h4> <ul>
<li> <strong>OpenMenuScene() [SceneClass] [Mode]</strong> - Opens a new menu scene of the given class. Returns a reference to the opened scene. <ul>
<li> <strong>SceneClass</strong> - Specifies the class of menu scene to open. Must be a subclass of <code>MobileMenuScene</code>.
</li> <li> <strong>Mode</strong> - Optional. Specifies a string to be passed to the scene's <code>Opened()</code> function.
</li></ul>
</li> <li> <strong>CloseMenuScene() [SceneToClose]</strong> - Closes the specified menu scene. <ul>
<li> <strong>SceneToClose</strong> - References the scene to be close.
</li></ul>
</li> <li> <strong>CloseAllMenus()</strong> - Closes all menu scenes in the scene stack.
</li> <li> <strong>RenderMenus() [Canvas Canvas] [RenderDelta]</strong> - Called by the engine each frame to render all the menus in the scene stack. <ul>
<li> <strong>Canvas</strong> - References the <code>Canvas</code> to use to draw the scene.
</li> <li> <strong>RenderDelta</strong> - Holds the amount of time since the last render cycle.
</li></ul>
</li> <li> <strong>MobileMenuCommand() [MenuCommand]</strong> - Exec. Passes a command to all scenes in the stack until one hanldes the command, by returning TRUE. <ul>
<li> <strong>MenuCommand</strong> - A <code>String</code> specifying the command to pass to the scenes.
</li></ul>
</li> <li> <strong>OpenMobileMenu() [MenuClassName]</strong> - Exec. Opens a menu scene given a class in the form of a string. <ul>
<li> <strong>MenuClassName</strong> - Specifies the name of the class of menu scene to open in the form of a string.
</li></ul>
</li> <li> <strong>OpenMobileMenuMode() [MenuClassName] [Mode]</strong> - Exec. Opens a menu scene given a class in the form of a string, with an optional mode. <ul>
<li> <strong>MenuClassName</strong> - Specifies the name of the class of menu scene to open in the form of a string.
</li> <li> <strong>Mode</strong> - Optional. Specifies a string to be passed to the scene's <code>Opened()</code> function.
</li></ul>
</li></ul>
<p />
<h3><a name="TouchDataEvent"></a> TouchDataEvent </h3>
The <code>TouchDataEvent</code> structure contains data for individual touch events queued for a specific touch handle. Each time a touch event is detected for a touch, a new <code>TouchDataEvent</code> is constructed to hold the data for that specific event. These can then be processed by the input system in order as soon as possible.
<p /> <ul>
<li> <strong>EventType</strong> - The <code>ETouchType</code> type of the touch event.
</li> <li> <strong>TouchpadIndex</strong> - What touch pad this came from.
</li> <li> <strong>Location</strong> - The <code>Vector2D</code> representing the location of the touch event in screen coordinates (pixels).
</li> <li> <strong>DeviceTime</strong> - The timestamp of when the event occurred.
</li></ul>
<p />
<h3><a name="TouchData"></a> TouchData </h3>
The <code>TouchData</code> structure holds all the information about a specific touch throughout its lifetime, from when the user first touches the screen until the user lifts their finger off the screen. The current active touches on the device are stored in the <code>Touches</code> array, allowing access to the current state of the touch input on the device.
<p /> <ul>
<li> <strong>Handle</strong> - An <code>Int</code> specifying a unique ID for this individual touch.
</li> <li> <strong>TouchpadIndex</strong> - What touch pad this came from.
</li> <li> <strong>Location</strong> - A <code>Vector2D</code> holding the current location, in screen space, of the touch, according to the most recent touch event.
</li> <li> <strong>TotalMoveDistance</strong> - The total distance, in pixels, that the touch has moved since the initial touch event.
</li> <li> <strong>InitialDeviceTime</strong> - The timestamp from when the initial touch event occurred.
</li> <li> <strong>TouchDuration</strong> - The amount of time in seconds that the touch has been active.
</li> <li> <strong>MoveEventDeviceTime</strong> - The timestamp from the most recent touch event for this touch.
</li> <li> <strong>MoveDeltaTime</strong> - The amount of time in seconds between movement events the last time the touch moved.
</li> <li> <strong>bInUse</strong> - If TRUE, the touch entry is currently in use. Otherwise, it is no longer active and can be appropriated for a new touch.
</li> <li> <strong>Zone</strong> - The <code>MobileInputZone</code> that is currently processing the touch.
</li> <li> <strong>State</strong> - The <code>EZoneTouchEvent</code> type of the most recent touch event for this touch. See <a href="MobileInputSystem.html#TouchEvents" class="twikiAnchorLink">Touch Events</a> for more information.
</li> <li> <strong>Events</strong> - An array of <code>TouchDataEvents</code> holding all touch events for this touch over its lifetime.
</li> <li> <strong>LastActiveTime</strong> - The last time the touch was active. This is used to determine if a zone is timed out.
</li></ul>
<p />
<h2><a name="Input Zones"></a> Input Zones </h2>
<hr size="1" noshade="noshade">
Input zones are essentially touch controls that can take input from touchscreen devices and translate that input into usable data. The same way a key bind can take a key press and translate that into data used by the game to control player movement or other in-game events, an input zone can take touch input and perform this same function. In fact, input zones actually use the same key bind system to bind the input to the action, as you will see later on.
<p />
<h3><a name="Input Groups"></a> Input Groups </h3>
An input group is a collection of associated input zones. For instance, the left and right control sticks seen in the Epic Citadel example game belong to a single input group. Each game can have any number of input groups assigned to it and any one of these input groups can be active at any point during the game. An input zone can also belong to more than one input group, making them reusable by multiple games or for multiple uses within a single game.
<p />
The <code>MobileInputGroup</code> structure is used to represent an input group. It simply maps a unique name to identify the group with an array of input zones that make up the group.
<p /> <ul>
<li> <strong>GroupName</strong> - A <code>String</code> specifying the unique name of the input group.
</li> <li> <strong>AssociatedZones</strong> - An array of <code>MobileInputZones</code> belonging to the input group.
</li></ul>
<p />
Input groups are defined in the DefaultGame.ini file by adding entries to the <code>RequiredMobileInputConfigs</code> array of an individual game type. For more on this, see the <a href="MobileInputSystem.html#DefiningInputGroups" class="twikiAnchorLink">Defining Input Groups</a> section.
<p />
<h3><a name="MobileInputZone"></a> MobileInputZone </h3>
The <code>MobileInputZone</code> class is the base class for defining areas of the screen that take touch input from the user and translate it in to standard UE3 input/axis events.
<p />
<h4><a name="MobileInputZone Properties"></a> MobileInputZone Properties </h4>
<h5><a name="General"></a><a name=" General"></a>  General </h5> <ul>
<li> <strong>Type</strong> - The <code>EZoneType</code> specifying the type of input zone (button, joystick, trackball, slider). See the <a href="MobileInputSystem.html#ZoneTypes" class="twikiAnchorLink">Input Zone Types</a> for more information.
</li> <li> <strong>State</strong> - The <code>EZoneState</code> describing the current state of the input zone. See the <a href="MobileInputSystem.html#ZoneStates" class="twikiAnchorLink">Input Zone States</a> for more information.
</li> <li> <strong>SlideType</strong> - The <code>EZoneSlideType</code> describing the direction the zone slides if the zone is a slider ( <code>Type=ZoneType_Slider</code> )
</li> <li> <strong>InputOwner</strong> - The <code>MobilePlayerInput</code> responsible for managing the input zone.
</li> <li> <strong>MobileSeqEventHandlers</strong> - An array of the <code>SeqEvent_MobileZoneBase</code> Kismet events associated with the input zone.
</li></ul>
<p />
<h5><a name="Input"></a><a name=" Input"></a>  Input </h5> <ul>
<li> <strong>InputKey</strong> - The <code>Name</code> of the input key to send to the input subsystem on an input event from this input zone. For analog input types, this is for input events along the vertical axis.
</li> <li> <strong>HorizontalInputKey</strong> - The <code>Name</code> of the input key to send to the input subsystem on an input event along the horizontal axis from this input zone. Only used for analog input types.
</li> <li> <strong>TapInputKey</strong> - The <code>Name</code> of the input key to send to the input subsystem on a tap input from this input zone.
</li> <li> <strong>DoubleTapInputKey</strong> - The <code>Name</code> of the input key to send to the input subsystem on a double-tap input from this input zone.
</li> <li> <strong>VertMultiplier</strong> - The scaling factor to multiply analog input along the vertical axis by. Determines how sensitive the input zone is on the vertical axis.
</li> <li> <strong>HorizMultiple</strong> - The scaling factor to multiply analog input along the horizontal axis by. Determines how sensitive the input zone is on the horizontal axis.
</li> <li> <strong>Acceleration</strong> - The amount of acceleration (actually defined as: movement per second) to apply to trackball input zone movement.
</li> <li> <strong>Smoothing</strong> - The amount of input smoothing to apply to trackball input zone movement.
</li> <li> <strong>EscapeVelocity</strong> - A <code>Vector2D</code> holding the vertical and horizontal input movement to apply after the touch has ended. This is like inertial movement, such as the behavior seen in scrolling lists on iOS devices where the list continues to scroll even after the touch has ended.
</li> <li> <strong>EscapeVelocityStrength</strong> - Specifies the amount of escape velocity to use each update. This value is in the range [0.0, 1.0]. Higher values mean a faster falloff.
</li> <li> <strong>bScalePawnMovement</strong> - If TRUE, the input values of the zone will be multiplied by the local PlayerController's Pawn's <code>MovementSpeedModifier</code> value.
</li> <li> <strong>bQuickDoubleTap</strong> - If TRUE, a double-tap will cause a simple press and release (IE_Pressed, IE_Release) of the <code>DoubleTapInputKey</code> on the touch event. Otherwise, a double tap will cause a press (IE_Pressed) of the <code>DoubleTapInputKey</code> on the touch event, a repeat (IE_Repeat) of the <code>DoubleTapInputKey</code> on each update event, and a release)IE_Release) of the <code>DoubleTapInputKey</code> on the untouch or canceled event.
</li> <li> <strong>TapDistanceConstraint</strong> - The maximum distance a touch can move from the touch event to the untouch event to be considered a tap.
</li> <li> <strong>bAllowFirstDeltaForTrackballZone</strong> - If TRUE, the first movement delta for a trackball zone will be used. Otherwise, the first movement delta for a trackball zone will be ignored.  This is useful for devices with inconsistent 'dead zones' for initial touch deltas, however this will reduce responsiveness of trackball drags slightly.
</li> <li> <strong>InitialLocation</strong> - The initial location of the touch event when a new touch occurs within the zone.
</li> <li> <strong>CurrentLocation</strong> - The current location of the touch in the zone. Only applies to joystick and trackball zones.
</li> <li> <strong>InitialCenter</strong> - The actual center of the zone, given its bounds. Used to reset zones using <code>bCenterOnTouch=true</code> (usually joystick zones).
</li> <li> <strong>CurrentCenter</strong> - The current location used as the center for input events. Updated to the initial touch location of zones using <code>bCenterOnTouch=true</code> (usually joystick zones) when a new touch occurs.
</li> <li> <strong>PreviousLocations</strong> - The (6) most recent touch event locations for the zone to be used when smoothing input over frames. Only applies to joystick and trackball zones.
</li> <li> <strong>PreviousMoveDeltaTimes</strong> - The (6) most recent touch event time deltas for the zone to be used when smoothing input over frames. Only applies to joystick and trackball zones.
</li> <li> <strong>PreviousLocationCount</strong> - The number of previous touch locations and time deltas currently being stored and used for smoothing input over frames.
</li> <li> <strong>LastTouchTime</strong> - The time of the last touch event in the zone. Used to determine if a tap is a double tap.
</li> <li> <strong>TimeSinceLastTapRepeat</strong> - The amount of time since the last repeat (IE_Repeat) of the <code>InputKey</code> for button zones.
</li> <li> <strong>bIsDoubleTapAndHold</strong> - TRUE if a double-tap occurs that is not considered a 'quick double-tap'. Needed so that the repeat and release (IE_Repeat, IE_Release) of the <code>DoubleTapInputKey</code> is sent.
</li> <li> <strong>LastAxisValue</strong> - A <code>Vector2D</code> holding the cached input values from the last update. Only applies to joystick and trackball zones.
</li> <li> <strong>TotalActiveTime</strong> - The amount of time the zone has been active.
</li> <li> <strong>LastWentActiveTime</strong> - The time when the zone last went from inactive to active.
</li></ul>
<p />
<h5><a name="Position and Size"></a><a name=" Position and Size"></a>  Position and Size </h5> <ul>
<li> <strong>[X/Y]</strong> - The horizontal and vertical position in screen coordinates of the top-left corner of the input zone. (Either in pixels or relative depending on <code>bRelative[X/Y]</code>)
</li> <li> <strong>Size[X/Y]</strong> - The width and height of the input zone. (Either in pixels or relative depending on <code>bRelativeSize[X/Y]</code>)
</li> <li> <strong>ActiveSize[X/Y]</strong> - The width and height of the 'active zone'. See the <a href="MobileInputSystem.html#ZoneSizing" class="twikiAnchorLink">Sizing and Positioning</a> section for more information.
</li> <li> <strong>bRelative[X/Y]</strong> -  If TRUE, the horizontal or vertical position of the top-left corner of the zone will be assumed to be relative values in the range [0.0, 1.0].
</li> <li> <strong>bRelativeSize[X/Y]</strong> - If TRUE, the width and height of the zone will be assumed to be relative values in the range [0.0, 1.0].
</li> <li> <strong>bActiveSizeYFromX</strong> - If TRUE, the <code>ActiveSizeY</code> value will be assumed to be relative to the value of <code>ActiveSizeX</code>.
</li> <li> <strong>bSizeYFromSizeX</strong> - If TRUE, the <code>SizeY</code> value will be assumed to be relative to the value of <code>SizeX</code>.
</li> <li> <strong>bAppleGlobalScaleToActiveSizes</strong> - If TRUE, the horizontal and vertical global scaling factors will be applied to the <code>ActiveSize[X/Y]</code> values. This can be useful to keep the size of the control accurate on devices of differing resolutions or screen sizes.
</li> <li> <strong>bCenter[X/Y]</strong> - If TRUE, the zone will be centered on the <code>[X/Y]</code> values specified in the config instead of having them represent the top-left corner. The <code>[X/Y]</code> values will then be updated to reflect the actual top-left corner of the zone.
</li> <li> <strong>bCenterOnEvent</strong> - If TRUE, the <code>CurrentCenter</code> of the zone will be adjusted to the location of all new touch events. This is useful for creating controls which auto-position to the user's touch (within a certain area), such as the joysticks in Epic Citadel.
</li> <li> <strong>ResetCenterAfterInactivityTime</strong> - If <code>bCenterOnEvent</code> is TRUE and this is a non-zero value, the <code>CurrentCenter</code> position will be reset to its <code>InitialCenter</code> after this amount of time has passed with the zone being inactive.
</li> <li> <strong>Border</strong> - The distance around the outside of the zone to be included in determining if touches are within the zone or not.
</li> <li> <strong>bFloatingTiltZone</strong> - If TRUE, the tilt zone will float within the <code>Size[X/Y]</code>. Does not appear to be used.
</li></ul>
<p />
<a name="ZoneRenderingProperties"></a>
<h5><a name="Rendering"></a><a name=" Rendering"></a>  Rendering </h5> <ul>
<li> <strong>OverrideTexture[1/2]</strong> - Specifies the <code>Texture2Ds</code> used to override the zone textures.       * For Button zones, <code>OverrideTexture1</code> is the texture drawn when the button is inactive, and <code>OverrideTexture2</code> is the texture drawn when the button is active.       * For Trackball and Joystick zones, <code>OverrideTexture1</code> is drawn as the background (the hollow circle seen in Citadel), and <code>OverrideTexture2</code> is the "hat" that follows the finger.       * For Slider zones, <code>OverrideTexture1</code> is the slider graphic, and <code>OverrideTexture2</code> is unused.
</li> <li> <strong>OverrideTexture[1/2]Name</strong> - A string specifying the full path to the texture, e.g. "Package.Group.Name".
</li> <li> <strong>OverrideUVs[1/2]</strong> - Specifies the texture UVs in texels (meaning texture pixel values) used to describe the sub-region of OverrideTexture[1/2] to draw.
</li> <li> <strong>Caption</strong> - The text to display for the zone. This is only used for buttons currently and is drawn centered within the zone.
</li> <li> <strong>Caption[X/Y]Adjustment</strong> - Horizontal and vertical offsets for the position of the zone's <code>Caption</code> allowing for fine adjustment of the text to align fonts correctly.
</li> <li> <strong>bIsInvisible</strong> - If TRUE, the zone will be rendered.
</li> <li> <strong>bUseGentleTransitions</strong> - If TRUE, the zone will gradually transition from the inactive to active and vice-versa visually. Otherwise, the change is immediate. <strong>NOTE:</strong> This is purely visual. The actual state of the zone changes immediately the moment a touch begins or ends.
</li> <li> <strong>ActivateTime</strong> - The amount of time it takes for the zone to visually transition from inactive to active.
</li> <li> <strong>DeactivateTime</strong> - The amount of time it takes for the zone to visually transition from active to inactive.
</li> <li> <strong>bRenderGuides</strong> - If TRUE, debug lines will be rendered for the zone. This is only used for joystick zones currently and renders a line from the zone's <code>CurrentCenter</code> to the location of the joystick hat.
</li> <li> <strong>RenderColor</strong> - The <code>Color</code> to use when drawing the zone. This will modulate any images or text making up the visual representation of the zone. The <code>Canvas</code> draw color is set to this color before calling the appropriate zone drawing function in the <code>MobileHUD</code>.
</li> <li> <strong>InactiveAlpha</strong> - The opacity to draw the zone at when inactive.
</li> <li> <strong>AnimatingFadeOpacity</strong> - The current opacity of the fading effect used when re-centering the zone after a period of inactivity.
</li> <li> <strong>TransitionTime</strong> - The current amount of time elapsed during the transition of the zone from inactive to active or vice-versa.
</li></ul>
<p />
<h4><a name="MobileInputZone Delegates"></a> MobileInputZone Delegates </h4> <ul>
<li> <strong>OnProcessInputDelegate() [Zone] [DeltaTime] [Handle] [EventType] [TouchLocation]</strong> - Called when any input event occurs within the zone allowing completely custom input handling for any zone or for input in a zone to be handled by other classes. Return TRUE to acknowledge the input as being handled. Returning FALSE will pass the input on, processing it in the <code>ProcessTouch()</code> function according to the type of zone. <ul>
<li> <strong>Zone</strong> - A reference to the Zone the delegate belongs to.
</li> <li> <strong>DeltaTime</strong> - The amount of time since the last input event for the zone.
</li> <li> <strong>Handle</strong> - The unique identifier of the touch responsible for the input event.
</li> <li> <strong>EventType</strong> - The <code>EZoneTouchEvent</code> type of the input event.
</li> <li> <strong>TouchLocation</strong> - The <code>Vector2D</code> specifying the horizontal and vertical location of the touch event in pixel screen coordinates.
</li></ul>
</li> <li> <strong>OnTapDelegate() [Zone] [EventType] [TouchLocation]</strong> - Called when a tap occurs within the zone allowing completely custom handling for taps or for taps in the zone to be handled by other classes. Return TRUE to acknowldge the tap as being handled. Returning FALSE will pass the tap on, processing it in the <code>ProcessTouch()</code> function. <ul>
<li> <strong>Zone</strong> - A reference to the Zone the delegate belongs to.
</li> <li> <strong>EventType</strong> - The <code>EZoneTouchEvent</code> type of the input event.
</li> <li> <strong>TouchLocation</strong> - The <code>Vector2D</code> specifying the horizontal and vertical location of the touch event in pixel screen coordinates.
</li></ul>
</li> <li> <strong>OnDoubleTapDelegate() [Zone] [EventType] [TouchLocation]</strong> - Called when a double-tap occurs within the zone allowing completely custom handling for double-taps or for double-taps in the zone to be handled by other classes. Return TRUE to acknowledge the double-tap as being handled. Returning FALSE will pass the double-tap on, processing it in the <code>ProcessTouch()</code> function. <ul>
<li> <strong>Zone</strong> - A reference to the Zone the delegate belongs to.
</li> <li> <strong>EventType</strong> - The <code>EZoneTouchEvent</code> type of the input event.
</li> <li> <strong>TouchLocation</strong> - The <code>Vector2D</code> specifying the horizontal and vertical location of the touch event in pixel screen coordinates.
</li></ul>
</li> <li> <strong>OnProcessSlide() [Zone] [EventType] [SlideValue] [ViewportSize]</strong> - Called when an input event occurs within a slider zone to allow the value of the slider to be accessed. The return value is not used currently. <ul>
<li> <strong>Zone</strong> - A reference to the Zone the delegate belongs to.
</li> <li> <strong>EventType</strong> - The <code>EZoneTouchEvent</code> type of the input event.
</li> <li> <strong>SlideValue</strong> - The location of the slide as a pixel offset [+/-] from the normal resting position.
</li> <li> <strong>ViewportSize</strong> - The dimensions of the current viewport, e.g. the device's screen.
</li></ul>
</li> <li> <strong>OnPreDrawZone() [Zone] [Canvas]</strong> - Called immediately before the zone is rendered by the <code>MobileHUD</code> allowing the drawing of the zone to be overridden by a custom zone or any other <code>Actor</code>. Return TRUE to abort the standard rendering of the zone. <ul>
<li> <strong>Zone</strong> - A reference to the Zone the delegate belongs to.
</li> <li> <strong>Canvas</strong> - References the <code>Canvas</code> to use for drawing.
</li></ul>
</li> <li> <strong>OnPostDrawZone() [Zone] [Canvas]</strong> - Called after the zone is rendered by the <code>MobileHUD</code> allowing the drawing of the zone to be supplemented by a custom zone or any other <code>Actor</code>. <ul>
<li> <strong>Zone</strong> - A reference to the Zone the delegate belongs to.
</li> <li> <strong>Canvas</strong> - References the <code>Canvas</code> to use for drawing.
</li></ul>
</li></ul>
<p />
<h4><a name="MobileInputZone Functions"></a> MobileInputZone Functions </h4> <ul>
<li> <strong>ActivateZone()</strong> - Sets the input zone to either the <code>ZoneState_Activating</code> or <code>ZoneState_Active</code> state depending on the value of <code>bUseGentleTransitions</code>.
</li> <li> <strong>DeactivateZone()</strong> - Sets the input zone to either the <code>ZoneState_Deactivating</code> or <code>ZoneState_Inactive</code> state depending on the value of <code>bUseGentleTransitions</code>.
</li> <li> <strong>AddKismetEventHandler() [NewHandler]</strong> - Associates a new mobile input Kismet event with the input zone that will receive events when touch input occurs for the zone. <ul>
<li> <strong>NewHandler</strong> - References the <code>SeqEvent_MobileZoneBase</code> to add as a new handler.
</li></ul>
</li></ul>
<p />
<a name="ZoneTypes"></a>
<h4><a name="Input Zone Types"></a> Input Zone Types </h4>
<p /> <ul>
<li> <strong>Button</strong> - The <code>ZoneType_Button</code> zone type creates a zone that has 2 states: pressed and unpressed.  It will send its InputKey when it goes from the pressed to the unpressed state.
</li> <li> <strong>Joystick</strong> - The <code>ZoneType_Joystick</code> zone type creates a zone that has a virtual stick that allows you to quickly simulate a joypad/stick on the device.  The InputKey defines the bind that will be sent when movement along the vertical access occurs.   HorizontalInputKey will be sent when horizontal access movement occurs.
</li> <li> <strong>Trackball</strong> - The <code>ZoneType_Trackball</code> zone type creates a zone that handles general touches and swipes. When you add a trackball zone, sliding your finger through the zone will have the same affect of rolling a trackball.  Like ZoneType_Joystick above, InputKey is for vertical movement, HorizontalInputKey is for Horizontal movement.
</li> <li> <strong>Slider</strong> - The <code>ZoneType_Slider</code> zone type creates a zone that can be used to slide a sub-zone along a locked axis.  The SliderZone is designed to be used with script delegates for managing its values.  Look to Citadel for examples.
</li></ul>
<p />
<a name="ZoneStates"></a>
<h4><a name="Input Zone States"></a> Input Zone States </h4>
<p /> <ul>
<li> <strong>Inactive</strong> - The input zone is currently inactive
</li> <li> <strong>Activating</strong> - The input zone is becoming active
</li> <li> <strong>Active</strong> - The input zone is active
</li> <li> <strong>Deactivating</strong> - The input zone is becoming inactive
</li></ul>
<p />
<h3><a name="Rendering and Appearance"></a> Rendering and Appearance </h3>
Rendering the overlays for the input zones is handled by the <code>MobileHud</code> class. If you want to change how they appear, you will want to override the various <code>DrawMobileZone_xxxx</code> functions.
<p />
You may also do some basic appearance overriding by using the following properties in the zone. (See the <a href="MobileInputSystem.html#ZoneRenderingProperties" class="twikiAnchorLink">MobileInputZone Rendering Properties</a> section for descriptions of the properties.)
<p /> <ul>
<li> <strong>OverrideTexture[1/2]</strong>
</li> <li> <strong>OverrideTexture[1/2]Name</strong>
</li> <li> <strong>OverrideUVs[1/2]</strong>
</li></ul>
<p />
<a name="ZoneSizing"></a>
<h3><a name="Sizing and Positioning"></a> Sizing and Positioning </h3>
The position and size of a zone is handled by the <code>X</code>, <code>Y</code>, <code>SizeX</code>, and <code>SizeY</code> member variables.  There are some important things to note about sizing and positioning.   The first has to do with using Negative numbers.  They can be used to position or size something from the right/bottom edge of the viewport.  For example, having a zone that has <code>SizeX = 32</code> and <code>X = -32</code> will be flush with the right edge of the screen.  In addition, there are several flags that can be set to have the engine use these values as percentages of the viewport.  So if the zone has <code>bRelativeX = true</code> then the value of X will be taken as a percentage of the Viewport's <code>SizeX</code>.  Finally, <code>bSizeYFromSizeX</code> can be used to insure proper aspect ratio in varying resolution (ex: iPad vs iPod).
<p />
In additional to <code>X</code>, <code>Y</code>, <code>SizeX</code>, and <code>SizeY</code> there is an <code>ActiveSizeX</code> and <code>ActiveSizeY</code>.  These can be used to define a "zone within a zone".  What this means is that the bounds of the zone can be defined using the <code>X</code>, <code>Y</code>, <code>SizeX</code>, and <code>SizeY</code> properties, but the active part of the zone that actually acts as the control is defined by the <code>ActiveSizeX</code> and <code>ActiveSizeY</code> properties. This is usually used with controls that "center on touch", for example the joysticks in Epic Citadel that move to where you touch the screen within a specific area.
<p />
<img src="rsrc/Three/MobileInputSystem/activezone.jpg" alt="activezone.jpg" width="" height="" />
<p />
<h3><a name="Adding Input Zones"></a> Adding Input Zones </h3>
Each zone is defined in the <code>DefaultGame.ini</code> config file. The <code>MobileInputZone</code> system uses per-object-config to manage and load various zones. This means that each input zone will be defined in its own section in the config file. Any of the properties declared with the <code>config</code> specifier can be set in the section defining the input zone in the config file.
<p />
An example mobile input zone definition would look like the following:
<p />
<div class="codesnippet">
<pre>
&#91;UberStickMoveZone MobileInputZone]
InputKey&#61;MOBILE&#95;AForward
HorizontalInputKey&#61;MOBILE&#95;AStrafe
Type&#61;ZoneType&#95;Joystick
bRelativeX&#61;true
bRelativeY&#61;true
bRelativeSizeX&#61;true
bRelativeSizeY&#61;true
X&#61;0.05
Y&#61;-0.4
SizeX&#61;0.1965
SizeY&#61;1.0
bSizeYFromSizeX&#61;true
VertMultiplier&#61;-1.0
HorizMultiplier&#61;1.0
bScalePawnMovement&#61;true
RenderColor&#61;(R&#61;255,G&#61;255,B&#61;255,A&#61;255)
InactiveAlpha&#61;0.25
bUseGentleTransitions&#61;true
ResetCenterAfterInactivityTime&#61;3.0
ActivateTime&#61;0.6
DeactivateTime&#61;0.2
TapDistanceConstraint&#61;5
</pre>
</div>
<p />
<a name="DefiningInputGroups"></a>
<h3><a name="Defining Input Groups"></a> Defining Input Groups </h3>
Any gametype that extends from <code>FrameworkGame</code> can define a list of required mobile input configs, or input groups. Each config consists of a name that defines it and a list of zones that need to be included. The order in which the input zones are specified in the input group is extremely important. This defines the order in which input is passed to the input zones, and when input is passed to an input zone and is within that zone's bounds, it is handled and not passed to any subsequent zones. This can cause issues if ythe input group has multiple zones which overlap each other. For instance, if one input zone is fullscreen and is added before any other input zones, the subsequent zones will never receive input.
<p />
Here is the mobile input config section for the <code>CastleGame</code> gametype used in Epic Citadel:
<p />
<div class="codesnippet">
<pre>
&#91;MobileGame.CastleGame]
+RequiredMobileInputConfigs&#61;(GroupName&#61;&#34;UberGroup&#34;,RequireZoneNames&#61;(&#34;MenuSlider&#34;,&#34;UberStickMoveZone&#34;,&#34;UberStickLookZone&#34;,&#34;UberLookZone&#34;))
+RequiredMobileInputConfigs&#61;(bIsAttractModeGroup&#61;true,GroupName&#61;&#34;AttractGroup&#34;,RequireZoneNames&#61;(&#34;MenuSlider&#34;,&#34;ExitAttractModeZone&#34;))
+RequiredMobileInputconfigs&#61;(GroupName&#61;&#34;InitialFlybyGroup&#34;)
+RequiredMobileInputConfigs&#61;(GroupName&#61;&#34;TapTutorialGroup&#34;,RequireZoneNames&#61;(&#34;MenuSlider&#34;,&#34;TapTutorialZone&#34;))
+RequiredMobileInputConfigs&#61;(GroupName&#61;&#34;SwipeTutorialGroup&#34;,RequireZoneNames&#61;(&#34;MenuSlider&#34;,&#34;SwipeTutorialZone&#34;))
bAllowAttractMode&#61;true
</pre>
</div>
<p />
When the input system is initialized, it will query the game to find out what <code>MobileInputZones</code> need to be loaded. Each input zone for the current gametype is instanced and stored in the local instance of the <code>MobilePlayerInput</code> class. The important part here is the <code>RequireZoneNames</code> array needs to hold the name used for per-object-config creation in the .ini file.  See <code>InitializeInputZones()</code> in the <code>MobilePlayerInput</code> class to see the code. You can change the active input group by calling <code>ActivateInputGroup()</code> on the <code>MobilePlayerInput</code>.
<p />
<h3><a name="Debugging"></a> Debugging </h3>
Debugging input from the zones can be tricky.  We have tried to make this as easy as possible.  To start with, there is a full featured emulation mode available on the PC. If you launch the game with the command line parameters:
<pre>
-simmobile
</pre>
 or
<pre>
-simmobileinput
</pre>
<p />
The game will use the mouse to simulate a single touch environment.  Additionally, if you use the command line parameter "-wxwindows" you can then use the console command:
<p />
<pre>
editobject class&#61;mobileplayerinput
</pre>
<p />
This will allow view/edit various mobile input properties in real time.  In addition, there are several config options that will cause debug information to display on the HUD.  They are:
<p />
<pre>
&#91;GameFramework.MobileHUD]
bDebugTouches&#61;true
bDebugZones&#61;true
bDebugZonePresses&#61;true
bShowMotionDebug&#61;true
</pre>
<p />
These are <code>SET</code> command friendly (ie: <code>set mobilehud bDebugTouches</code>).  Give them a try in Citadel.
<p />
You can also use the <a href="UDKRemote.html" class="twikiLink">UDKRemote</a> to send input from your device to engine running on a PC.  For more information over obtaining and using the UDKRemote application, see the <a href="UDKRemote.html" class="twikiLink">UDKRemote</a> page.
<p />
<h2><a name="Mobile Input in _UnrealScript"></a> Mobile Input in UnrealScript </h2>
<hr size="1" noshade="noshade">
Input on mobile devices can be managed in UnrealScript through several delegates found in the <code>MobilePlayerInput</code> class. There is only one low-level function that you need to be concerned with. By assigning a function to this delegate, you can create a completely custom handling of the touch input from mobile devices that can be set up directly through UnrealScript. This could be done in a subclass of <code>MobilePlayerInput</code>, in your game's custom <code>PlayerController</code> class, or anywhere else there might be a need to handle input from the device.
<p />
<a name="TouchInput"></a>
<h3><a name="Touch Input"></a> Touch Input </h3>
Any time the user touches the screen, it is considered a 'touch'. The input system has the ability to track multiple touches at one time. Each touch lasts from the time the user comes into contact with the screen and is tracked until the user stops touching the screen.
<p />
<a name="TouchEvents"></a>
<h4><a name="Touch Events"></a> Touch Events </h4>
During the lifetime of touch, it generates events that are categorized into different types. These types can be used to determine how to react to the touch at any given point. These types are stored in an enum called ETouchType which is defined in Interaction.uc.
<p /> <ul>
<li> <strong>Touch_Began</strong> - This event type is sent when the user comes into contact, or touches, the device. It signifies a new individual touch.
</li> <li> <strong>Touch_Moved</strong> - This event type is sent each frame between when the first touch occurs and the touch ends. This event allows the touch to be tracked over its lifetime.
</li> <li> <strong>Touch_Ended</strong> - This event type is sent when the touch ends, or the user stops touching the device. It signifies the end of an individual touch.
</li> <li> <strong>Touch_Cancelled</strong> - This event type is sent when an outside force, like a system message appearing, cancels an existing touch. This also signifies the end of an existing touch.
</li> <li> <strong>Touch_Stationary</strong> - This event type is not currently generated.
</li></ul>
<p />
<h4><a name="Handling Touches"></a> Handling Touches </h4>
The entry point to the touch input system is through a delegate present in the <code>MobilePlayerInput</code> class. This delegate gives you access to raw low level touch data coming from the device. It can and will be called multiple times per frame returning various touch information. It is up to the programmer to track and manage the data coming from here.
<p /> <ul>
<li> <strong>OnInputTouch [Handle] [Type] [TouchLocation] [DeviceTimestamp]</strong> -  <ul>
<li> <strong>Handle</strong> - The index into the <code>Touches</code> array identifying this touch. This will be unique throughout the life-time of the touch, but not unique from touch to touch.
</li> <li> <strong>Type</strong> - The <code>ETouchType</code> type of touch event. See <a href="MobileInputSystem.html#TouchEvents" class="twikiAnchorLink">Touch Events</a> for an explanation of the various types of events that can be generated.
</li> <li> <strong>TouchLocation</strong> - A <code>Vector2D</code> that holds the horizontal and vertical location in pixels of the touch on the device's screen.
</li> <li> <strong>DeviceTimestamp</strong> - The actual low-level timestamp for the touch.
</li> <li> <strong>TouchpadIndex</strong> - Which touch pad invoked this delegate.
</li></ul>
</li></ul>
<p />
This same information is used to drive the MobileInputZone's above.  These delegates get access to the touch before the zones do, but must co-exist with them.
<p />
<h4><a name="Picking Example"></a> Picking Example </h4>
Many different types of games require the ability to interact with arbitrary items in the world, or to detect which item is being touched. This can be done in a very flexible way by using the <code>OnInputTouch()</code> delegate from the <code>MobilePlayerInput</code> class along with an Interface. The use of an interface allows any class that wishes to be considered 'touchable' to have that functionality, while keeping the code required to support that ability very succinct.
<p />
<h5><a name="ITouchable Interface"></a><a name=" ITouchable Interface"></a>  ITouchable Interface </h5>
The <code>ITouchable</code> interface is very simple. It declares a single function, <code>OnTouch()</code>, that will be called from the custom <code>PlayerController</code> class (detailed below) whenever an Actor implementing this interface is touched.
<p />
<div class="codetitlebar">
ITouchable.uc
</div>
<div class="codesnippet">
<pre>
Interface ITouchable;

function OnTouch(ETouchType Type, float X, float Y);
</pre>
</div>
<p />
A class which implements this interface will be needed in order to test it. A class extending from the <code>MobilePlaceablePawn</code> will work.
<p />
<div class="codetitlebar">
UDNMobilePawn.uc
</div>
<div class="codesnippet">
<pre>
class UDNMobilePawn extends MobilePlaceablePawn implements(ITouchable);

function OnTouch(ETouchType Type, float X, float Y)
{
  WorldInfo.Game.Broadcast(self, &#34;Touched:&#34;&#64;self);
}
</pre>
</div>
<p />
The <code>implements(ITouchable)</code> states this class must define all functions belonging to the <code>ITouchable</code> interface; in this case the <code>OnTouch()</code> function. This provides a reliable way to communicate with any item that should be touchable. The body of the function just displays a message to the screen showing the item has been touched.
<p />
<h5><a name="PlayerController Class"></a><a name=" _PlayerController Class"></a>  PlayerController Class </h5>
The functionality for picking objects will be implemented in the <code>PlayerController</code> class, which will be a subclass of <code>GamePlayerController</code> as extending from this class is a requirement for using mobile touch input.
<p />
<div class="codetitlebar">
UDNMobilePC.uc
</div>
<div class="codesnippet">
<pre>
class UDNMobilePC extends GamePlayerController;
</pre>
</div>
<p />
Several variable are needed to facilitate the picking functionality.
<p />
<div class="codetitlebar">
UDNMobilePC.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42; Holds the dimensions of the device&#39;s screen &#42;/
var vector2D ViewportSize;

/&#42;&#42; If TRUE, a new touch was detected (must be the only touch active) &#42;/
var bool bPendingTouch;

/&#42;&#42; Holds the handle of the most recent touch &#42;/
var int PendingTouchHandle;

/&#42;&#42; Holds the Actor that was selected &#42;/
var Actor SelectedActor;

/&#42;&#42; Maximum distance an Actor can be to be picked &#42;/
var float PickDistance;

/&#42;&#42; Maximum amount the mouse can move between touch and untouch to be considered a &#39;click&#39; &#42;/
var float ClickTolerance;

/&#42;&#42; Cache a reference to the MobilePlayerInput &#42;/
var MobilePlayerInput MPI;
</pre>
</div>
<p />
A new function is defined which transforms the touch location from screen coordinates to a pair of <code>Vectors</code> that can be used with the <code>Trace()</code> function to determine if anything is being touched.
<p />
<div class="codetitlebar">
UDNMobilePC.uc
</div>
<div class="codesnippet">
<pre>
/&#42;&#42; find actor under touch location
&#42;
&#42;   &#64;PickLocation - Screen coordinates of touch
&#42;/
function Actor PickActor(Vector2D PickLocation)
{
  local Vector TouchOrigin, TouchDir;
  local Vector HitLocation, HitNormal;
  local Actor PickedActor;

  //Transform absolute screen coordinates to relative coordinates
  PickLocation.X &#61; PickLocation.X / ViewportSize.X;
  PickLocation.Y &#61; PickLocation.Y / ViewportSize.Y;

  //Transform to world coordinates to get pick ray
  LocalPlayer(Player).Deproject(PickLocation, TouchOrigin, TouchDir);

  //Perform trace to find touched actor
  PickedActor &#61; Trace(HitLocation, HitNormal, TouchOrigin + (TouchDir &#42; PickDistance), TouchOrigin, true);

  //Casting to ITouchable determines if the touched actor can indeed be touched
  if(Itouchable(PickedActor) !&#61; none)
  {
    //Call the OnTouch() function on the touched actor
    Itouchable(PickedActor).OnTouch(ZoneEvent&#95;Touch, PickLocation.X, PickLocation.Y);
  }

  //Return the touched actor for good measure
  return PickedActor;
}
</pre>
</div>
<p />
Now, the location of the touch must be determined so it can be passed to the <code>PickActor()</code> function. This requires the use of the <code>OnInputTouch()</code> delegate from the <code>MobilePlayerInput</code> class, as stated previously. First, the function that will be assigned to the delegate is defined.
<p />
<div class="codetitlebar">
UDNMobilePC.uc
</div>
<div class="codesnippet">
<pre>
function HandleInputTouch(int Handle, ETouchType Type, Vector2D TouchLocation, float DeviceTimestamp)
{
  local Actor PickedActor;
  local int i;

  //New touch event
  if(Type &#61;&#61; Touch&#95;Began)
  {
    //Specify a new touch has occurred
    PendingTouchHandle &#61; Handle;
    bPendingTouch &#61; true;
  }
  //Touch in progress
  else if(Type &#61;&#61; Touch&#95;Moved)
  {
    for(i&#61;0; i&#60;MPI.NumTouchDataEntries; i++)
    {
      //Test distance touch has moved and cancel touch if moved too far; update touch location if not
      if(MPI.Touches&#91;i].Handle &#61;&#61; PendingTouchHandle &#38;&#38; MPI.Touches&#91;i].TotalMoveDistance &#62; ClickTolerance)
      {
        bPendingTouch &#61; false;
      }
    }
  }
  //End of touch
  else if(Type &#61;&#61; Touch&#95;Ended)
  {
    //Check if a touch is active
    if(Handle &#61;&#61; PendingTouchHandle &#38;&#38; bPendingTouch)
    {
      //Get actor under touch
      PickedActor &#61; PickActor(TouchLocation);

      //Check if actor is touchable and set it as selected; clear current selected if not
      if(ITouchable(PickedActor) !&#61; none)
      {
        SelectedActor &#61; PickedActor;
      }
      else
      {
        SelectedActor &#61; none;
      }

      //cancel active touch
      bPendingTouch &#61; false;
    }

    WorldInfo.Game.Broadcast(self, &#34;SelectedActor:&#34;&#64;SelectedActor);
  }
}
</pre>
</div>
<p />
In order for the <code>HandleInputTouch()</code> function to get called when input occurs, it must be assigned to the <code>OnInputTouch()</code> delegate.
<p />
<div class="codetitlebar">
UDNMobilePC.uc
</div>
<div class="codesnippet">
<pre>
event InitInputSystem()
{
  Super.InitInputSystem();

  //Get a reference to the local MobilePlayerInput
  MPI &#61; MobilePlayerInput(PlayerInput);

  //Accessing the input handler function to the delegate
  MPI.OnInputTouch &#61; HandleInputTouch;

  //get the screen dimensions (used to transform to relative screen coords for the DeProject)
  LocalPlayer(Player).ViewportClient.GetViewportSize(ViewportSize);
}
</pre>
</div>
<p />
The <code>InitInputSystem()</code> event is called by the engine to initialize the input system. Prior to the <code>Super.InitInputSystem();</code> call the system should be initialized and the local <code>MobilePlayerInput</code> is accessible allowing the <code>HandleInputTouch</code> function to be assigned to its <code>OnInputTouch</code> delegate to be assigned.
<p />
Finally, some defaults are set for the properties which require them.
<p />
<div class="codetitlebar">
UDNMobilePC.uc
</div>
<div class="codesnippet">
<pre>
defaultproperties
{
  PickDistance&#61;10000
  ClickTolerance&#61;5

  InputClass&#61;class&#39;GameFramework.MobilePlayerInput&#39;
}
</pre>
</div>
<p />
<h5><a name="GameType"></a><a name=" _GameType"></a>  GameType </h5>
Obviously, it will be necessary for the <code>PlayerController</code> class containing this new functionality to be in use for the object picking to be used. A quick sample gametype is shown here that will force the new PlayerController to be used.
<p />
<div class="codetitlebar">
UDNMobileGame.uc
</div>
<div class="codesnippet">
<pre>
class UDNMobileGame extends FrameworkGame;

defaultproperties
{
  PlayerControllerClass&#61;class&#39;UDNMobileGame.UDNMobilePC&#39;
  DefaultPawnClass&#61;class&#39;MobileGame.MobilePawn&#39;
  HUDType&#61;class&#39;GameFramework.MobileHUD&#39;
  bRestartLevel&#61;false
  bWaitingToStartMatch&#61;true
  bDelayedStart&#61;false
}
</pre>
</div>
<p />
The <code>DefaultEngine.ini</code> is also modified to specify the new gametype to be used by default.
<p />
<div class="codesnippet">
<pre>
&#91;Engine.GameInfo]
DefaultGame&#61;UDNMobileGame.UDNMobileGame
DefaultServerGame&#61;UDNMobileGame.UDNMobileGame
DefaultGameType&#61;&#34;UDNMobileGame.UDNMobileGame&#34;
</pre>
</div>
<p />
<h5><a name="Testing"></a><a name=" Testing"></a>  Testing </h5>
A very simple test map is set up with a <code>PlayerStart</code> and a <code>UDNMobilePawn</code> placed using the Jazz Jackrabbit skeletal mesh and placed in front of the <code>PlayerStart</code>.
<p />
<img src="rsrc/Three/MobileInputSystem/pickactor_map.jpg" alt="pickactor_map.jpg" width="480" height="320" />
<p />
First the screen is touched away from Jazz and the result shows no item was touched.
<p />
<img src="rsrc/Three/MobileInputSystem/pickactor_fail.jpg" alt="pickactor_fail.jpg" width="480" height="320" />
<p />
Then, the screen is touched directly over Jazz and the result shows Jazz was touched and selected, as expected.
<p />
<img src="rsrc/Three/MobileInputSystem/pickactor_success.jpg" alt="pickactor_success.jpg" width="480" height="320" />
<p />
<h3><a name="Motion Input"></a> Motion Input </h3>
Motion input refers to using the orientation and movement of the device itself as a means of input. Different devices support different types of motion data (or none at all). Devices with accelerometers provide basic orientation and rotation data, while those with more sophisticated instruments, such as gyroscopes, can produce additional data such as linear motion while also improving the accuracy of the orientation and rotational input data. The motion input data is accessed directly through properties in <code>PlayerInput</code>.
<p />
<h4><a name="Tilt"></a><a name=" Tilt"></a>  Tilt </h4>
The tilt of the device refers to its orientation. As the device is oriented differently, by rotating it around its various axes, the tilt is reported in terms of pitch, yaw, and roll (usually in the form of a <code>Vector</code>). These values can then be used to drive any action or gameplay element within the game. Tilt motion data is available for any device which has at least an accelerometer.
<p />
This stored is within <strong>PlayerInput.aTilt</strong>. This value is in Unreal rotator units.
<p />
<h4><a name="Rotation Rate"></a><a name=" Rotation Rate"></a>  Rotation Rate </h4>
Rotation rate refers to the speed at which the tilt of the device changes. As the device is oriented differently, the rate at which it is rotated around its axes determines the rotation rate values reported by the device. This data is in the form of a <code>Vector</code> representing the rate of change of the pitch, yaw, and roll. Rotation rate data is available on devices with accelerometers, but it is much more accurate if the device has a gyroscope.
<p />
This is stored within <strong>PlayerInput.aRotationRate</strong>.
<p />
<h4><a name="Acceleration"></a><a name=" Acceleration"></a>  Acceleration </h4>
Acceleration refers to linear motion of the device. As the device is moved through space along any of its axes, the device reports this linear motion as acceleration data in the form of a <code>Vector</code>. This type of motion input is only available if the device has a gyroscope
<p />
This is stored within <strong>PlayerInput.aAcceleration</strong>
<p />
<h4><a name="Gravity"></a><a name=" Gravity"></a>  Gravity </h4>
Some devices are able to detect gravity as well.
<p />
This is stored within <strong>PlayerInput.aGravity</strong>
<p />
<a name="KismetAnchor"></a>
<h2><a name="Mobile Input in Kismet"></a> Mobile Input in Kismet </h2>
<hr size="1" noshade="noshade">
Kismet provides several actions and events specific to the setting up and managing input. This is useful if you are making one-off levels for your game, and you don't want to edit the .ini, or if you want level-specific input.
<p />
For a complete reference of the mobile input-related Kismet objects, see the <a href="MobileKismetReference.html" class="twikiLink">Mobile Kismet Reference</a>.
<p />
<h3><a name="Managing Input Zones in Kismet"></a> Managing Input Zones in Kismet </h3>
There are several ways input zones can be managed within Kismet. The mobile actions allow for adding and removing individual input zones or clearing all input zones.
<p />
<h4><a name="Adding and Removing Input Zones"></a> Adding and Removing Input Zones </h4>
Input zones can be added or removed easily directly through Kismet using the mobile input actions: <em>Clear Input Zones</em>, <em>Add Input Zones</em>, and <em>Remove Input Zones</em>. This is especially useful for quick prototyping or specialized, level-specific input. Prototyping and testing input zones without needing to shut down the editor, edit an .ini file, re-open the editor, and run the level again is a huge benefit to managing input zones through Kismet in time savings alone. The <em>Add Input Zone</em> action give syou complete control over the input zone's positioning and size as well as all other significant properties allowing for complete control. It is also possible to use these actions to limit or reconfigure the available input zones during play to customize the user experience. For example, a particular level may have an event that occurs during which the player needs to have a very specialized method of input available, while not allowing any of the normal input of the game. This can easily be accomplished using these actions.
<p />
Below is a simple example of taking the standard input zones from the default MobileGame and providing the ability to modify them during play to limit the player's input choices and then restore the default input again.
<p />
Kismet sequence:
<p />
<span style="font:italic 10px arial;">(Click for full size)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_inputzones_example_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_inputzones_example_thumb.jpg" alt="kismet_inputzones_example_thumb.jpg" width="800" height="230" border="0" /></a>
<p />
The logic of the sequence is fairly simple:
<p /> <ul>
<li> The <code>RemoveInput</code> event sequence removes the <code>UberStickMoveZone</code> and <code>UberStickLookZone</code> joystick input zones leaving only the <code>UberLookZone</code> trackball input zone used for looking around.
</li> <li> The <code>AddInput</code> event sequence adds the <code>UberStickMoveZone</code> and <code>UberStickLookZone</code> joystick input zones back restoring normal control to the player
</li> <li> The two <em>Console Events</em> simply provide a quick way to trigger the remote events sequences through the console by entering either <code>CE ADD</code> or <code>CE REMOVE</code>.
</li></ul>
<p />
Properties for the <em>Add Input Zones</em> actions:
<p />
<span style="font:italic 10px arial;">(Click to see all properties)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_inputzones_props_stickmove_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_inputzones_props_stickmove_thumb.jpg" alt="kismet_inputzones_props_stickmove_thumb.jpg" width="335" height="356" border="0" /></a> <a href="rsrc/Three/MobileInputSystem/kismet_inputzones_props_sticklook_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_inputzones_props_sticklook_thumb.jpg" alt="kismet_inputzones_props_sticklook_thumb.jpg" width="335" height="356" border="0" /></a>
<p />
Preview of the sequence in action:
<p />
<img src="rsrc/Three/MobileInputSystem/kismet_inputzones_preview.jpg" alt="kismet_inputzones_preview.jpg" width="800" height="535" border="0" />
<p />
<h4><a name="Handling Button Input Zones"></a> Handling Button Input Zones </h4>
The input from a button input zone can be handled through the <em>Mobile Button Access</em> event. This makes it possible to perform actions within a level based on taps on a button by the user. The button input zone being monitore can either be defined in the DefaultGame.ini for the current gametype or it could be a completely custom button added using the <em>Add Input Zone</em> action.
<p />
The following example shows a simple Kismet sequence which adds a button input zone in response to a console event and then listens for input from that button. When the button is pressed, a console command is sent to close the game.
<p />
Kismet sequence:
<p />
<span style="font:italic 10px arial;">(Click for full size)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_inputzones_example_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_inputzones_example_thumb.jpg" alt="kismet_inputzones_example_thumb.jpg" width="800" height="230" border="0" /></a>
<p />
Properties for the <em>Add Input Zone</em> action and <em>Mobile Button Access</em> event:
<p />
<span style="font:italic 10px arial;">(Click to see all properties)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_mobilebutton_props_addbutton_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_mobilebutton_props_addbutton_thumb.jpg" alt="kismet_mobilebutton_props_addbutton_thumb.jpg" width="335" height="356" border="0" /></a> <img src="rsrc/Three/MobileInputSystem/kismet_mobilebutton_props_buttonaccess.jpg" alt="kismet_mobilebutton_props_buttonaccess.jpg" width="361" height="171" border="0" />
<p />
Preview of the sequence in action:
<p />
<span style="font:italic 10px arial;">(Click for full size)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_mobilebutton_preview_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_mobilebutton_preview_thumb.jpg" alt="kismet_mobilebutton_preview_thumb.jpg" width="800" height="179" border="0" /></a>
<p />
<h4><a name="Handling Joystick Input Zones"></a> Handling Joystick Input Zones </h4>
Input from joystick input zones can be handled directly in Kismet through the <em>Mobile Input Access</em> and <em>Mobile Look</em> events. <em>Mobile Input Access</em> is a fairly generic event that gives access to the raw input data of the joystick, such as axis and center values. <em>Mobile Look</em> is a more specialized event that outputs more specialized, but extremely usable data, such as <code>Yaw</code>, <code>Strength</code>, and <code>Rotation</code>. This can easily be used to grab input from a joystick and apply it to control characters in the game, either for prototyping or for level-specific player controls.
<p />
This example shows a single-joystick movement implementation where the left-stick (usually used for simple direction movement) is used to control not only the direction of movement for the player, but also the rotation so that the player is always facing the direction it is moving. it should also be noted that this example uses a placeable Pawn along with a custom camera setup created in the map using Kismet.
<p />
Kismet sequence:
<p />
<span style="font:italic 10px arial;">(Click for full size)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_joystick_example_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_joystick_example_thumb.jpg" alt="kismet_joystick_example_thumb.jpg" width="800" height="512" border="0" /></a>
<p />
The logic of the sequence is:
<p /> <ul>
<li> The <em>Level Loaded</em> event disables player input and sets a top-down camera.
</li> <li> The <em>Input Active</em> output uses the <code>Strength</code> and <code>Rotation</code> variables to calculate the <code>Velocity</code> (direction and magnitude) of the player.
</li> <li> The <em>Input Active</em> output uses the <code>Yaw</code> variable to calculate the <code>Rotation</code> of the player.
</li> <li> The <em>Input Inactive</em> input drives a sequence that ramps down the <code>Velocity</code> of the player to give the appearance of the player decelerating.
</li></ul>
<p />
Properties for the <em>Mobile Look</em> event:
<p />
<img src="rsrc/Three/MobileInputSystem/kismet_joystick_props_mobilelook.jpg" alt="kismet_joystick_props_mobilelook.jpg" width="335" height="101" border="0" />
<p />
Preview of the sequence in action:
<p />
<span style="font:italic 10px arial;">(Click to view - Right-click &gt; Save As to download)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_joystick_preview.mp4"><img src="rsrc/Three/MobileInputSystem/kismet_joystick_preview.jpg" alt="kismet_joystick_preview.jpg" width="480" height="320" /></a>
<p />
<h3><a name="Handling Kismet Touch Input Events"></a> Handling Kismet Touch Input Events </h3>
Raw touch input as well as simple swipe detection is possible in Kismet using the <em>Mobile Raw Input Access</em> and <em>Mobile Simple Swipes</em> events. The <em>Mobile raw Input Access</em> event gives access to very generic input data inside of Kismet. This can be helpful in debugging and prototyping custom input schemes. The <em>Mobile Simple Swipes</em> event provides basic swipe detection within Kismet allowing for custom player input based on swipe touches.
<p />
The example below demonstrates using simple swipe detection to control the movement and rotation of a placeable Pawn character. All other input is disabled in the scene. While this example uses a placeable player, a similar setup could also be usd to control other objects such as pieces to a puzzle or boulders that need to be moved by the player.
<p />
Kismet sequence:
<p />
<span style="font:italic 10px arial;">(Click for full size)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_swipe_example_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_swipe_example_thumb.jpg" alt="kismet_swipe_example_thumb.jpg" width="800" height="241" border="0" /></a>
<p />
The logic of the sequence is:
<p /> <ul>
<li> Each output of the <em>Mobile Simple Swipes</em> event sets some direction an rotation variables.
</li> <li> The direction and rotation variables are used to create velocity and rotation vector varaibles.
</li> <li> The roation vector is used to set the <code>Rotation</code> of the placeable Pawn character.
</li> <li> The direction vector and a velocity magnitude variable are used to set the <code>Velocity</code> of the placeable Pawn character.
</li> <li> The <code>Velocity</code> is ramped down to give the appearance of the player decelerating.
</li></ul>
<p />
Properties for the <em>Mobile Simple Swipes</em> event:
<p />
<img src="rsrc/Three/MobileInputSystem/kismet_swipe_props_mobileswipe.jpg" alt="kismet_swipe_props_mobileswipe.jpg" width="335" height="171" border="0" />
<p />
Preview of the sequence in action:
<p />
<span style="font:italic 10px arial;">(Click to view - Right-click &gt; Save As to download)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_swipe_preview.mp4"><img src="rsrc/Three/MobileInputSystem/kismet_swipe_preview.jpg" alt="kismet_swipe_preview.jpg" width="480" height="320" /></a>
<p />
<h3><a name="Handling Kismet Motion Input Events"></a> Handling Kismet Motion Input Events </h3>
Motion input data can be accessed using the <em>Mobile Motion Access</em> event in Kismet. This outputs the motion data in the form of rotation values and deltas. Depending on the situation, this data can be used for debugging and prototyping or for creating unique and specialized input within a level. Keep in mind though, this data is fairly raw and may need some processing in order to be very useful within Kismet for complex control schemes. Additional custom Kismet objects and several calculations may be needed in order to create custom controls using this event.
<p />
The following example demonstrates using motion input inside of Kismet to control "simple" movement of a placeable Pawn character. (The quotes around "simple" are there because you will see that the sequence is anything but simple, though it looks worse than it really is.)
<p />
Kismet sequence:
<p />
<span style="font:italic 10px arial;">(Click for full size)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_motion_example_full.jpg"><img src="rsrc/Three/MobileInputSystem/kismet_motion_example_thumb.jpg" alt="kismet_motion_example_thumb.jpg" width="800" height="105" border="0" /></a>
<p />
The logic of the sequence is:
<p /> <ul>
<li> The <code>Roll</code> value is normalized, clamped to a range of [0.0, 1.0], and a dead zone is calculated.
</li> <li> The <code>Pitch</code> value is normalized, clamped to a range of [0.0, 1.0], and a dead zone is calculated.
</li> <li> The final <code>Roll</code> and <code>Pitch</code> values are used to set the veloctiy (direction and magnitude) of the character.
</li></ul>
<p />
Preview of the sequence in action:
<p />
<span style="font:italic 10px arial;">(Click to view - Right-click &gt; Save As to download)</span>
<p />
<a href="rsrc/Three/MobileInputSystem/kismet_motion_preview.mp4"><img src="rsrc/Three/MobileInputSystem/kismet_motion_preview.jpg" alt="kismet_motion_preview.jpg" width="480" height="320" /></a>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
