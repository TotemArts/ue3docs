<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | MasteringUnrealScriptInterfaces    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">MasteringUnrealScriptInterfaces  </b></div>
<div id="tooltext">
<a href="MasteringUnrealScriptInterfacesJP.html" class="twikiLink">日本語訳</a><br><a href="MasteringUnrealScriptInterfacesCH.html" class="twikiLink">中国翻译</a><br><a href="MasteringUnrealScriptInterfacesKR.html" class="twikiLink">한국어</a><br>

<!-- Three/MasteringUnrealScriptInterfaces -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div class="twikiToc"> <ul>
<li> <a href="MasteringUnrealScriptInterfaces.html#Chapter 13 – Interfaces">Chapter 13 – Interfaces</a> <ul>
<li> <a href="MasteringUnrealScriptInterfaces.html#What are interfaces?">What are interfaces?</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#Examples of Interfaces">Examples of Interfaces</a> <ul>
<li> <a href="MasteringUnrealScriptInterfaces.html#USB">USB</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#COMPUTER MICE">COMPUTER MICE</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#POWER OUTLETS">POWER OUTLETS</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#PROGRAMMING SPECIFICS">PROGRAMMING SPECIFICS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#DEFINING INTERFACES">DEFINING INTERFACES</a> <ul>
<li> <a href="MasteringUnrealScriptInterfaces.html#DECLARATION V. DEFINITION">DECLARATION V. DEFINITION</a>
</li></ul>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#INTERFACE INHERITANCE">INTERFACE INHERITANCE</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#IMPLEMENTING INTERFACES">IMPLEMENTING INTERFACES</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#WHY ARE INTERFACES USED?">WHY ARE INTERFACES USED?</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#FINAL WORDS">FINAL WORDS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.1 – THE COMPASS, PART I: ICOMPASS INTERFACE">TUTORIAL 13.1 – THE COMPASS, PART I: ICOMPASS INTERFACE</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.2 – THE COMPASS, PART II: COMPASS CLASS IMPEMENTATION">TUTORIAL 13.2 – THE COMPASS, PART II: COMPASS CLASS IMPEMENTATION</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.3 – THE COMPASS, PART III: TESTING THE COMPASS, PART I">TUTORIAL 13.3 – THE COMPASS, PART III: TESTING THE COMPASS, PART I</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.4 – THE MINIMAP, PART I: THE MU_MINIMAP CLASS">TUTORIAL 13.4 – THE MINIMAP, PART I: THE MU_MINIMAP CLASS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.5 – THE MINIMAP, PART II: THE MINIMAPGAME CLASS">TUTORIAL 13.5 – THE MINIMAP, PART II: THE MINIMAPGAME CLASS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.6 – THE MINIMAP, PART III: MINIMAPHUD INITIAL SETUP">TUTORIAL 13.6 – THE MINIMAP, PART III: MINIMAPHUD INITIAL SETUP</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.7 - THE MINIMAP, PART IV: MINIMAPHUD FUNCTIONS">TUTORIAL 13.7 - THE MINIMAP, PART IV: MINIMAPHUD FUNCTIONS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.8 – THE MINIMAP, PART V:  DRAWMAP() INITIAL SETUP">TUTORIAL 13.8 – THE MINIMAP, PART V: DRAWMAP() INITIAL SETUP</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.9 – THE MINIMAP, PART VI:  PLAYERPOS AND CLAMPEDPLAYERPOS">TUTORIAL 13.9 – THE MINIMAP, PART VI: PLAYERPOS AND CLAMPEDPLAYERPOS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.10 – THE MINIMAP, PART VII:  MAP ROTATION">TUTORIAL 13.10 – THE MINIMAP, PART VII: MAP ROTATION</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.11 – THE MINIMAP, PART VII: SET MATERIAL PARAMS AND DRAW MAP">TUTORIAL 13.11 – THE MINIMAP, PART VII: SET MATERIAL PARAMS AND DRAW MAP</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.12 – THE MINIMAP, PART VIII: DRAWING OTHER PLAYERS">TUTORIAL 13.12 – THE MINIMAP, PART VIII: DRAWING OTHER PLAYERS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.13 – THE MINIMAP, PART IX: MAP SETUP AND SCREENSHOT">TUTORIAL 13.13 – THE MINIMAP, PART IX: MAP SETUP AND SCREENSHOT</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.14 – THE MINIMAP, PART X: MINIMAP MATERIAL AND FINISHING TOUCHES">TUTORIAL 13.14 – THE MINIMAP, PART X: MINIMAP MATERIAL AND FINISHING TOUCHES</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.15 – THE MINIMAP, PART XI: TESTING THE MINIMAP">TUTORIAL 13.15 – THE MINIMAP, PART XI: TESTING THE MINIMAP</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.16 – THE CAPTURE VOLUME, PART I: INITIAL SETUP">TUTORIAL 13.16 – THE CAPTURE VOLUME, PART I: INITIAL SETUP</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.17 – THE CAPTURE VOLUME, PART II: TOUCH AND TIME">TUTORIAL 13.17 – THE CAPTURE VOLUME, PART II: TOUCH AND TIME</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.18 – THE CAPTURE VOLUME, PART III: THE CAPTURED STATE">TUTORIAL 13.18 – THE CAPTURE VOLUME, PART III: THE CAPTURED STATE</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.19 – THE CAPTURE VOLUME, PART IV: THE TIMER FUNCTION">TUTORIAL 13.19 – THE CAPTURE VOLUME, PART IV: THE TIMER FUNCTION</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.20 – THE CAPTURE VOLUME, PART V: UPDATING THE EVENTS">TUTORIAL 13.20 – THE CAPTURE VOLUME, PART V: UPDATING THE EVENTS</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.21 – THE CAPTURE VOLUME, PART VI:  TOGGLING THE VOLUME OFF  UPDATING OUR DEFAULTPROPERTIES BLOCK">TUTORIAL 13.21 – THE CAPTURE VOLUME, PART VI: TOGGLING THE VOLUME OFF &amp; UPDATING OUR DEFAULTPROPERTIES BLOCK</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.22 – THE CAPTURE VOLUME, PART VII: THE SEQUENCE EVENT’S INTERFACE AND IMPLEMENTATION">TUTORIAL 13.22 – THE CAPTURE VOLUME, PART VII: THE SEQUENCE EVENT’S INTERFACE AND IMPLEMENTATION</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#TUTORIAL 13.23 – PLACING A CAPTUREVOLUME AND SEEING IT IN ACTION">TUTORIAL 13.23 – PLACING A CAPTUREVOLUME AND SEEING IT IN ACTION</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#INTERFACES WITHIN UT3">INTERFACES WITHIN UT3</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#SUMMARY">SUMMARY</a>
</li> <li> <a href="MasteringUnrealScriptInterfaces.html#SUPPLEMENTAL FILES">SUPPLEMENTAL FILES</a>
</li></ul>
</li></ul>
</div>
<p />
<h1><a name="Chapter 13 – Interfaces"></a> Chapter 13 – Interfaces </h1>
<p />
We now have more than enough to accomplish most any task in Unreal Script. We understand the syntax, how to instantiate variables and functions. We have covered a few advanced topics, allowing us to take advantage of iterators, states and now delegates. In this chapter we are going to go a step further, opening the door to dependable programming as your project grows by introducing Interfaces. We will see their purpose, instantiation and a couple examples of how they can be used to help maintain coding standards throughout a project.
<p />
<h2><a name="What are interfaces?"></a> What are interfaces? </h2>
<p />
Programming poses many challenges that are not entirely obvious to the lay observer. Game development, in particular, poses many such challenges and as such, it is a field that takes advantage of most every aspect of software engineering. Occasionally when working in large object oriented systems you will create a number of classes that are all used in a single way, defining a group of functions that provide the same function signature.
<p />
<font face=consolas>
<pre>
class MyPistol extends MyWeapon;

function bool PrimaryFire(float rate)
{
   /&#42; Pistol Stuff Here &#42;/
}

/&#42; and so forth &#42;/

class MyRifle extends MyWeapon;

function bool PrimaryFire(float rate)
{
   /&#42; Rifle Stuff Here &#42;/
}

/&#42; and so forth &#42;/

class MyShotgun extends MyWeapon;

function bool PrimaryFire(float rate)
{
   /&#42; Shotgun Stuff Here &#42;/
}

/&#42; and so forth &#42;/
</pre>
</font>
<p />
It is entirely possible – similar to how it is possible to swim across the English Channel or build a house entirely from toothpicks – to throw ourselves to the wind and just write the code here, but it doesn’t ensure that we implement the necessary functions properly. Nor does it provide any assurance that our functions will not change over time, so refactoring our code later may be a hassle; this is of course not to mention that it doesn’t provide a means for us to ensure that our buddies and co-developers actually follow directions.
<p />
Many object oriented languages provide a tool that will help mitigate this issue, and Unreal Script stays true to its Java and CPP roots. Interfaces are used in these types of situations, partially handing the complications of monitoring code development over to the compiler, while helping us increase the quality of our code by providing an explicit means of planning our classes according to a defined standard.
<p />
A term that will be useful in this discussion is Implement. Throughout the rest of this chapter I will use it to refer to a class or device providing some group of functionality to the user. A spoon implements the utensil interface, which is synonymous to saying that a spoon provides all of the functionality of a utensil. A spoon may implement the utensil, but that is not to say that it is not specialized in its own way, providing further functionality.
<p />
<h2><a name="Examples of Interfaces"></a> Examples of Interfaces </h2>
<p />
If you were to take a trip to your local Ikea or cutlery shop you will find extravagant views of what a fork, spoon or knife should be, and chances are they will look different than the ones here. Regardless of this possibility though, they implement the same standards as all other cutlery, when looked at on the whole. Some may even be specialized further, such as a straining spoon which is useful for vegetables, or a spork which combines the usefulness of both elements into a stubby red headed step child, also known as the “best of both worlds.”
<p />
<table cellspacing="0" cellpadding="10" border="1" width="100%">
	<tr>
		<td width="33%" style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;">Fork</td>
		<td width="33%" style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;">Spoon</td>
		<td width="33%" style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;">Knife</td>
	</tr>
	<tr>
		<td width="33%">
			<ul>
				<li>To manipulate food, that is simple</li>
				<li>Provide for easy removal of items that have been picked up</li>
			</ul>
		</td>
		<td width="33%">
			<ul>
				<li>To move liquids and jello from one location to another</li>
			</ul>
		</td>
		<td width="33%">
			<ul>
				<li>To split food into pieces small enough to be placed in my mouth.</li>
			</ul>
		</td>
	</tr>
</table>
<strong><font color=blue>Table 13.1 Simple example of Interfaces using Utensils</font></strong>
<p />
Being a utensil may place other standards or requirements on our Fork, Spoon and Knife, such as ensuring:
<p /> <ul>
<li> They are large enough to be useful, but small enough to fit in our mouths and hands
</li> <li> They aren’t made out of perishable or non standard materials (no one ever heard of Styrofoam utensils)
</li> <li> They are the correct length, to make sure we don’t end up biting our fingers or poking our girlfriends eyes out as we eat
</li> <li> They are not bent in an unacceptably complicated manner, forcing us to contort our bodies to be able to eat
</li></ul>
<p />
<h3><a name="USB"></a> USB </h3>
<p />
Another example of an interface is something that we each use on a regular basis, and is more than likely on each of our computers. When we plug in a USB device we are taking advantage of a well defined interface, allowing us to use one port to plug in everything from a Wacom tablet, to a mouse, to a hard drive. We can reliably jam our USB dongle into our computer and within a few seconds windows will recognize – or not in some cases – our device and allow us to use it straight away. USB has not been around forever, many of the people I know remember how stressful it was to get our joysticks to work on the Commodore 64, and it had a standardized interface as well, called a serial port.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_001.jpg"/><br/> <strong><font color=blue>Figure 13.1 – A common USB Port</font></strong>
<p />
<h3><a name="COMPUTER MICE"></a> COMPUTER MICE </h3>
<p />
Interfaces are all around us, allowing us to pick up a mouse and depend upon its left and right buttons working, or how it moves meeting our expectations. Mice are a great example of interfaces because they expose a second characteristic of interfaces – implementation may change. The mouse may be ball, trackball, light or laser, but regardless of the implementation we can dependably use this mouse as we have learned over the years. Moving it along our mouse pad, or spinning the trackball, sends the proper commands to our computer to move the cursor around the screen; clicking the buttons also provides the expected response from your computer.
<p />
<h3><a name="POWER OUTLETS"></a> POWER OUTLETS </h3>
<p />
Two and three pronged power outlets provide an interface between electric devices, like your refrigerator or ceiling fan and the power grid provided by the city. We have multiple interfaces to deal with here, though. Three pronged interfaces allow us to take advantage of grounding, while two pronged outlets don’t.
<p />
Our device, like a laptop or desktop computer, can only be plugged into a three pronged outlet, because of power requirements and surge protection. A two pronged item, like a desk fan or Cell phone adapter uses only two, but it may be plugged into either outlet because the three pronged outlet provides all of the same functionality as the two pronged outlet, it simply goes a step further, providing the ground as well.
<p />
The three pronged outlet is said to Implement the two pronged interface. If we were to set up an inheritance tree for some popular outlet types it could look something like this, although this is admittedly simplified to exclude the high voltage lines that you may find your refrigerator or deep freezer plugged into.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_002.jpg"/><br/> <strong><font color=blue>Figure 13.2 - Power Outlet Tree Diagram</font></strong>
<p />
We can use these diagrams of this type to help orient our notes and keep a fifty-thousand foot view of our classes and how they relate. They are also fun to keep track of what we can use at which level. Looking at this diagram and knowing that I have a heavy duty hair dryer to use I can look in my bathroom and find anything that implements the three pronged outlet, while my desktop fan can be plugged into anywhere in my house.
<p />
<h2><a name="PROGRAMMING SPECIFICS"></a> PROGRAMMING SPECIFICS </h2>
<p />
When it comes to programming we use interfaces to define certain functions that can be depended upon by other classes. When programming, you will occasionally find yourself defining a number of functions that have the same input output and name. We call this combination a function’s signature. Working within these confines you can draft some sort of requirement and hand it to your programmers telling them what kind of functionality to provide, but Interfaces allow you to force the compiler to confirm that you have provided them.
<p />
One way to look at this is to think of an example group of objects as follows:
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_003.jpg"/><br/> <strong><font color=blue>Figure 13.3 Interface Overview</font></strong>
<p />
This hierarchy allows us to see a plan for our weapons, and we have created two interfaces, the IWeapon and the IZoomedWeapon interfaces, although the details of their contents don’t really matter at this point. We can see here that the Pistol, MachineGun and RocketLauncher implement the IWeapon Interface, while the SniperRifle implements the IZoomedWeapon Interface. When working with interfaces it is a standard practice to have interfaces use the “I” prefix to set them apart.
<p />
It may be useful to look at the interfaces, like IWeapon and IZoomedWeapon, as enforcers, or explicit laws. The compiler uses interfaces as a requirements document for your code.  Each interface defines necessary functions and when you implement it the compiler does the checking to ensure that you have implemented them. Looking into IWeapon we could see something like the following, in pseudo-code:
<p />
All weapons will implement a Primary Fire, accepting the rate that it fires, and Secondary Fire method which accepts the number of the rounds it should fire. Both will return false if the execution was successful.
<p />
To ensure data integrity we will define two constants that will be free to be used throughout the implementations. The Maximum Firing Rate and the Minimum firing Counter.
<p />
When you attempt to compile the above classes the compiler will check the pistol, machinegun, and any other class implementing the IWeapon interface, to see that they are implementing the necessary functions. Depending on the language, not implementing a function defined in an interface will more than likely result in an error, or some scary looking output at compile time.
<p />
<h2><a name="DEFINING INTERFACES"></a> DEFINING INTERFACES </h2>
<p />
Unreal uses the Interface keyword to denote an interface, which is different from a class, as we discussed earlier, because of the function signature. In Unreal Script we are free to define any number of functions, or data types as we see fit.  This includes functions, structures, enumerations, or anything further that does not actually instantiate memory. You can use this fact to centralize these declarations and minimize the code duplication problems that you may run into.
<p />
In Unreal Script, Interfaces are defined in a simple fashion, following the standard set by the classes. Below is the IWeapon interface that we just went through, declared in Unreal Script, instead of pseudo-code.
<p />
<font face=consolas>
<pre>
Interface IWeapon;

/&#42; Define our constants &#42;/
const MaximumFiringRate    &#61; 0.05; // 60/1200
const MinimumFiringCounter &#61; 3;

/&#42; All following function declarations &#42;/
function bool PrimaryFire(float Rate);
function bool SecondaryFire(int Counter);
</pre>
</font>
<p />
<h3><a name="DECLARATION V. DEFINITION"></a> DECLARATION V. DEFINITION </h3>
<p />
Everything from the return type to the input value must match these function signatures for it to be compiled by Unreal 3. This highlights another important aspect of programming in this environment, the differentiation between Declaration and Definition.
<p /> <ul>
<li> The interface declares functions, supplying the necessary elements like return type and input arguments.
</li> <li> When you implement the interface in a class you will be able to define the actual details of the function, like how it works or what it does.
</li></ul>
<p />
It may be helpful to think about this in terms of a restaurant outing. You are given the menu initially, an interface, but once you choose from that you will be given the meat and potatoes of your meal. The interface is the menu, the food itself is the implementation.
<p />
<h2><a name="INTERFACE INHERITANCE"></a> INTERFACE INHERITANCE </h2>
<p />
Similar to our discussion about power adapters, you can build interfaces off of each other. This is accomplished in the same way as classes are extended, using the Extends keyword.
<p />
<font face=consolas>
<pre>
Interface IZoomedWeapon extends IWeapon;

function bool ZoomedFire(float Rate, int FOV);
</pre>
</font>
<p />
It is certainly the case that we can build complicated hierarchical inheritance trees for interfaces, but you should do what you can to stay away from them. Just as with your classes you should create interfaces only when needed, and define them explicitly. Defining interfaces to be nebulous or include frivolous declarations will lead to complicated classes with empty functions. Using interfaces is exceptionally beneficial when you plan ahead. I would strongly recommend a class in object oriented analysis and design or a book on UML if you are turned on by this type of discussion.
<p />
<h2><a name="IMPLEMENTING INTERFACES"></a> IMPLEMENTING INTERFACES </h2>
<p />
Implementing an Interface in a class is really quite straight forward in Unreal Script, similar in fashion to what we are used to with the class derivation. Interfaces will more than likely be stand alone, however. Let’s look at two examples to drive this home. The pistol class implements the IWeapon interface, and its class will look something like the following in UScript:
<p />
<font face=consolas>
<pre>
Class Pistol extends UTWeapon implements(IWeapon);

function bool PrimaryFire(float Rate)
{
   if (Rate &#62; class&#39;IWeapon&#39;.const.MaximumFiringRate)
           return true;

       /&#42; Do mumbo jumbo here &#42;/
       return false;
}

function bool SecondaryFire(int Counter)
{
   if (Counter &#60; class&#39;IWeapon&#39;.const.MinimumFiringCounter)
      return true;

   /&#42; Do jumbo mumbo here &#42;/
   return false;
}
</pre>
</font>
<p />
As you can see this implements the necessary functions, declared in the interface, and when you compile it you will get no errors. You will certainly see a peculiar line…
<p />
<font face=consolas>
<pre>
if (Rate &#62; class&#39;IWeapon&#39;.const.MaximumFiringRate)
</pre>
</font>
<p />
This line is an example of how you gain access to a constant within an interface. As a rule, treat interfaces as though they are classes and you can gain access to their defined elements in the same fashion. (This is discussed in the third chapter)
<p />
Just for examples sake, if you were to compile with the interface implemented incorrectly you will see an error like the following:
<p />
<font face=consolas>
<pre>
Error, Implementation of function &#39;SecondaryFire&#39; conflicts with interface &#39;IWeapon&#39; - parameter 0 &#39;Counter&#39;
Compile aborted due to errors.
</pre>
</font>
<p />
Let’s look at our sniper rifle.
<p />
<font face=consolas>
<pre>
Class SniperRifle extends UTWeapon implements(IZoomedWeapon);

function bool PrimaryFire(float Rate)
{
   if (Rate &#62; class&#39;IWeapon&#39;.const.MaximumFiringRate)
      Rate &#61; class&#39;IWeapon&#39;.const.MaximumFiringRate;

   /&#42; Do mumbo jumbo here &#42;/
   return false;
}

function bool SecondaryFire(int Counter)
{
   if (Counter &#60; class&#39;IWeapon&#39;.const.MinimumFiringCounter)
      Counter &#61; class&#39;IWeapon&#39;.const.MinimumFiringCounter;

   /&#42; Do jumbo mumbo here &#42;/
   return false;
}

function bool ZoomedFire(float Rate, int FOV)
{
   /&#42; boom headshot! &#42;/
   return false;
}
</pre>
</font>
<p />
As you can see here this class implements IZoomedWeapon, which in turn extends the IWeapon interface. The compiler expects both interfaces to be implemented, and as a rule it will check every interface above the current one to ensure that all of their functions are defined as well. This is another reason to keep the interface tree short – think bush or shrub.
<p />
Also note that neither of our classes has had to define the constants.
<p />
When you first begin working with interfaces you will undoubtedly have a tough time and may wind up being overwhelmed. It may be useful to create Interface index cards to keep track of your interfaces.
<p />
<table cellspacing="0" cellpadding="10" border="1" width="100%">
	<tr>
		<td colspan="2" style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;">
			IWeapon
		</td>
	</tr>
	<tr>
		<td width="50%">
			<strong>Functions</strong>
			</br>
			<ul>
				<li>PrimaryFire(rate)
				<ul>
					<li>Returns Success</li>
				</ul>
				</li>
				<li>SecondaryFire(spread)
				<ul>
					<li>Returns Success</li>
				</ul>
				</li>
			</ul>
		</td>
		<td width="50%">
			<strong>Constants</strong>
			</br>
			<ul>
				<li>MaximumFiringRate</li>
				<li>MinimumFiringSpread</li>
			</ul>
		</td>
	</tr>
</table>
<strong><font color=blue>Table 13.2 - IWeapon Interface</font></strong>
<p />
<table cellspacing="0" cellpadding="10" border="1" width="100%">
	<tr>
		<td colspan="2" style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;">
			IZoomedWeapon extends IWeapon
		</td>
	</tr>
	<tr>
		<td width="50%">
			<strong>Functions</strong>
			</br>
			<ul>
				<li>ZoomedFire(Rate, FOV)</li>
				<li>Returns Success</li>
			</ul>
		</td>
		<td width="50%">
			<strong>Constants</strong>
			</br>
			<ul>
				<li>None</li>
			</ul>
		</td>
	</tr>
</table>
<strong><font color=blue>Table 13.3 - IZoomedWeapon Interface</font></strong>
<p />
Let’s review what interfaces are and highlight a couple quirks within the UT3 paradigm, then we will get into more code and see about building something out that will actually be interesting.
<p /> <ul>
<li> Interfaces allow us to declare functions that must be implemented within our classes
</li> <li> They provide us with a means to impose requirements upon our functions declarations
</li> <li> They make no requirement on the implementation other than the function signature, also known as declaration <ul>
<li> Instead their focus is on how the functions will be used
</li> <li> Implementation may vary from between classes; definition may be different
</li> <li> If a function is implemented in a parent class it will satisfy the interfaces requirements
</li></ul>
</li> <li> UT3 provides us a means to define Enumerations, Structures, and Constants, but nothing that actually requires memory
</li> <li> Implementing multiple interfaces is possible, but should be used only in select circumstances <ul>
<li> Implementing two interfaces of the same hierarchy will cause issues within your code and should be avoided like the plague
</li></ul>
</li></ul>
<p />
<h2><a name="WHY ARE INTERFACES USED?"></a> WHY ARE INTERFACES USED? </h2>
<p />
As we have already discussed, interfaces provide a mechanic to the compiler to ensure our classes conform to some specifications. Epic distributes quite a few interfaces, including but not limited to the UI elements, many of the elements for online gameplay, and some data-store craziness. If you look closely you will find each interface is implemented as we have seen already in our examples, and a second method, similar to what we experienced in the classes, as variable types. A prime example of this is in the OnlineSubsystem:
<p />
<font face=consolas>
<pre>
/&#42;&#42; The interface to use for creating and/or enumerating account information &#42;/
var OnlineAccountInterface AccountInterface;

/&#42;&#42; The interface for accessing online player methods &#42;/
var OnlinePlayerInterface PlayerInterface;

/&#42;&#42; The interface for accessing online player extension methods &#42;/
var OnlinePlayerInterfaceEx PlayerInterfaceEx;

/&#42;&#42; The interface for accessing system wide network functions &#42;/
var OnlineSystemInterface SystemInterface;

/&#42;&#42; The interface to use for creating, searching for, or destroying online games &#42;/
var OnlineGameInterface GameInterface;

/&#42;&#42; The interface to use for online content &#42;/
var OnlineContentInterface ContentInterface;

/&#42;&#42; The interface to use for voice communication &#42;/
var OnlineVoiceInterface VoiceInterface;

/&#42;&#42; The interface to use for stats read/write operations &#42;/
var OnlineStatsInterface StatsInterface;

/&#42;&#42; The interface to use for reading game specific news announcements &#42;/
var OnlineNewsInterface NewsInterface;
</pre>
</font>
<p />
This reinforces what we have already learned about interfaces, but it may not be entirely obvious. Lets take a look back at our weapons that we defined earlier. We had defined our interface and said that they were there so they could be used by other classes dependably. Our user could have a function as we have here:
<p />
<font face=consolas>
<pre>
Function bool foo (IWeapon w)
{
   w.PrimaryFire(60/1200);
   /&#42; any other things it wants to do &#42;/
}
</pre>
</font>
<p />
In similar fashion to what we experienced earlier declaring variable types in our classes, function parameters and structures. The upside, or downside depending on how you look at it, is that you have a variable that is already cast to that type when you are about to use it. This is used throughout the default codebase and as such it is quite common place for reference material.
<p />
<table cellspacing="0" cellpadding="10" border="1" width="100%">
	<tr>
		<td style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;" width="33%">Base Types</td>
		<td style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;" width="33%">Classes</td>
		<td style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;" width="33%">Constants</td>
	</tr>
	<tr>
		<td width="33%">
			<ul>
				<li>Only items of this type</li>
				<li>Ex. Bool</li>
			</ul>
		</td>
		<td width="33%">
			<ul>
				<li>This class or any inheriting it</li>
				<li>Ex. UTPawn</li>
			</ul>
		</td>
		<td width="33%">
			<ul>
				<li>Any class implementing this interface</li>
				<li>Ex. OnlineAccountInterface</li>
			</ul>
		</td>
	</tr>
</table>
<strong><font color=blue>Table 13.4 - Interfaces are accepted when used as a type</font></strong>
<p />
<h2><a name="FINAL WORDS"></a> FINAL WORDS </h2>
<p />
When to subclass and when to create in interface is a question many people like to ask, and it’s not a bad question. When you get yourself going you will find that interfacing creates similar results to sub classing, with one difference – sub classing doesn’t stop you from changing the signature of a function, which is one prime example of when to use an interface. Some projects require a defined interface before a class is defined, as we discussed previously.
<p />
Throwing ourselves to the wind is a way of saying let chance control our destiny. A simple typo may lead to hours of debugging, while an interface will give you a direct line of where your function is not declared correctly.
<p />
<h2><a name="TUTORIAL 13.1 – THE COMPASS, PART I: ICOMPASS INTERFACE"></a> TUTORIAL 13.1 – THE COMPASS, PART I: ICOMPASS INTERFACE </h2>
<p />
We should now take a few minutes and implement an interface of some sort, just to drive home our discussion up to this point. Let’s aim a little low for this first one, focusing on the details, and later we will do something more interesting.
<p />
Our mapper and HUD coder have come to us, looking for a new element to be defined, a compass. The purpose of this element is to be placed into our level and provide the mappers fine tuned control over the direction of north, from that the HUD coder has some needs, with which we are going to be defining our Interface and later the actual Compass class.
<p />
The Compass needs:
<p />
<table cellspacing="0" cellpadding="10" border="1" width="100%">
	<tr>
		<td style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;" width="50%">Mapper</td>
		<td style="background:#4f81bd;color:#ffffff;font:bold 12pt arial;" width="50%">Coder</td>
	</tr>
	<tr>
		<td width="50%">
			<ul>
				<li>to be placed within the map</li>
				<li>have rotatable heading, referred to as the Yaw</li>
				<li>Have a visible icon within the map
				<ul>
					<li>It has been provided by the mapper, and is in the CompassContent package named compass</li>
				</ul>
				</li>
			</ul>
		</td>
		<td width="50%">
			<ul>
				<li>Provide Getter functions for the Yaw</li>
				<li>Needs to calculate for radian and degree, in case of UI changes</li>
				<li>Allow the developers to grab the Rotator directly if they choose</li>
				<li>Ensure it is not removed or changed when the map reloads</li>
			</ul>
		</td>
	</tr>
</table>
<strong><font color=blue>Table 13.5 - Overview of specifications for our compass object</font></strong>
<p />
Most of this information is implementation related, but the coder clearly understands our needs. We should take this step by step, so the code makes clear sense.
<p />
<strong>1.</strong>	Declare the ICompass Interface.
<p />
<font face=consolas>
<pre>
interface ICompass;
</pre>
</font>
<p />
<strong>2.</strong>	Declare the GetRadianHeading() function, returning the unwound heading of the object.
<p />
<font face=consolas>
<pre>
function float GetRadianHeading();
</pre>
</font>
<p />
<strong>3.</strong>	Declare the GetDegreeHeading() Function, returning the converted radian value into degrees.
<p />
<font face=consolas>
<pre>
function float GetDegreeHeading();
</pre>
</font>
<p />
<strong>4.</strong>	Declare the GetYaw() function, returning the Yaw of our objects Rotation.
<p />
<font face=consolas>
<pre>
function int GetYaw();
</pre>
</font>
<p />
<strong>5.</strong>	Declare the GetRotator function, returning the entire rotator object.
<p />
<font face=consolas>
<pre>
function Rotator GetRotator();
</pre>
</font>
<p />
<strong>6.</strong>	Declare the GetVectorizedRotator() function, returning the rotator, converted to a vector.
<p />
<font face=consolas>
<pre>
function vector GetVectorizedRotator();
</pre>
</font>
<p />
<h2><a name="TUTORIAL 13.2 – THE COMPASS, PART II: COMPASS CLASS IMPEMENTATION"></a> TUTORIAL 13.2 – THE COMPASS, PART II: COMPASS CLASS IMPEMENTATION </h2>
<p />
We can take this interface and build out a compass in a straightforward fashion, but we should do some research to make sure we do not end up reinventing the wheel. The only element that may be useful to avoid writing on our own is probably the rotator, which is seemingly in every element. It also provides the interface that our mapper is accustomed to, with the rotation tool.
<p />
The Object class has a lot of cool functions and elements, which will most likely be useful, but the actor class actually implements the rotator that we are looking for, and it comes with the location vector as well, so life is great!
<p />
<font face=consolas>
<pre>
var(Movement) const vector   Location; // Actor&#39;s location; use Move to set.
var(Movement) const rotator Rotation; // Rotation.
</pre>
</font>
<p />
We can start coding out our class at this point, knowing that we intend to implement the interface and derive from this class.
<p />
<strong>1.</strong>	Define our class, extending the actor class and placeable, implementing our ICompass interface.
<p />
<font face=consolas>
<pre>
class Compass extends actor placeable implements(ICompass);
</pre>
</font>
<p />
<strong>2.</strong>	Define the Rotator retrieval functions. Because of where we chose to derive, the rotator is already available to us. We can quickly take care of three of the function definitions.
<p />
<font face=consolas>
<pre>
// Return the yaw of the actor
function int GetYaw()
{
   return Rotation.Yaw;
}

function Rotator GetRotator()
{
   return Rotation;
}

function vector GetVectorizedRotator()
{
   return vector(Rotation);
}
</pre>
</font>
<p />
We only care about the Yaw and then providing raw access to our developers.
<p />
<strong>3.</strong>	The Yaw is actually not exactly in the format that we need for the HUD to be useful, but it works fine for our mapper. We will need to do some manipulation of the rotator, ensuring the heading is accurate for the UI work. Let us take a couple minutes to break this apart. First declare the GetRadianHeading() function.
<p />
<font face=consolas>
<pre>
function float GetRadianHeading()
{
}
</pre>
</font>
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Three local variables are needed.
<p />
<font face=consolas>
<pre>
local Vector v;
local Rotator r;
local float f;
</pre>
</font>
<p />
<strong>b.</strong>	Get the Yaw component. Note that we are copying it into a new rotator object’s yaw value. This is the first step in simplifying our rotator.
<p />
<font face=consolas>
<pre>
r.Yaw &#61; GetYaw();
</pre>
</font>
<p />
<strong>c.</strong>	Convert our rotator to a Vector, which make the angle manipulations easier to handle.
<p />
<font face=consolas>
<pre>
v &#61; vector(r);
</pre>
</font>
<p />
<strong>d.</strong>	Unwind the Heading using a function that epic has provided to us. Many functions like it will prove to be very useful if you get deep into the mathematical end of programming within Unreal.
<p />
<font face=consolas>
<pre>
f &#61; GetHeadingAngle(v);
</pre>
</font>
<p />
<strong>e.</strong>	Unwind that heading, using another of the built in functions. This actually returns a radian value, but it may be negative.
<p />
<font face=consolas>
<pre>
f &#61; UnwindHeading(f);
</pre>
</font>
<p />
<strong>f.</strong>	Lets convert the value to positive by adding 2Pi
<p />
<font face=consolas>
<pre>
while (f &#60; 0)
   f +&#61; PI &#42; 2.0f;
</pre>
</font>
<p />
<strong>g.</strong>	And finally, return that value.
<p />
<font face=consolas>
<pre>
return f;
</pre>
</font>
</div>
<p />
This is an algorithm that is used with the vehicles, save the radian conversion, and can be seen within UTVehicle.uc on line 1199.
<p />
<strong>4.</strong>	Convert the Radian measurement to degrees. We can now use the radian measurement that we just calculated to be able to get the radian measurements. There is a constant variable that is quite useful RadToDeg which is 180/PI, pre-calculated for us.
<p />
<font face=consolas>
<pre>
function float GetDegreeHeading()
{
   local float f;

   f &#61; GetRadianHeading();

   f &#42;&#61; RadToDeg;

   return f;
}
</pre>
</font>
<p />
<strong>5.</strong>	We are now done with the heavy lifting. The only things left to do are UI related. Before we leave, though, it would be helpful to be able to have some debug info output when we are working on our map later. A function that is very useful for debugging as the level is loading is PostBeginPlay. We can output the heading to our log file when the game begins.
<p />
<font face=consolas>
<pre>
event PostBeginPlay()
{
   `log(&#34;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#34;,,&#39;UTBook&#39;);
    `log(&#34;Compass Heading&#34;&#64;GetRadianHeading()&#64;GetDegreeHeading(),,&#39;UTBook&#39;);
   `log(&#34;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#34;,,&#39;UTBook&#39;);
}
</pre>
</font>
<p />
<strong>6.</strong>	We have the functions all setup, but we now need to hook up a couple visual items for our mapper. Specifically an icon and the arrow need to be drawn on our object. We can also take this moment to change a couple entries to ensure our element holds its proper values and doesn’t get removed or changed when the map is reset.
<p />
<font face=consolas>
<pre>
DefaultProperties
{
}
</pre>
</font>
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Define a new ArrowComponent element, named arrow. This will be the actual arrow our mappers will be shown to reflect the actual direction that the object is pointing.
<p />
<font face=consolas>
<pre>
Begin Object Class&#61;ArrowComponent Name&#61;Arrow
</pre>
</font>
<p />
<strong>b.</strong>	The Arrow Color is the 0-255 range, which you may be familiar with, from your experience with Photoshop or Web development. You can tweak this as you wish. There is a color chooser within UnrealEditor that is very nicely done, but you can also play with the integer values.
<p />
<font face=consolas>
<pre>
ArrowColor &#61; (B&#61;80,G&#61;80,R&#61;200,A&#61;255)
</pre>
</font>
<p />
<strong>c.</strong>	This is the scale of the Arrow, not the weight. You will see its length or size increase as you scale this value up.
<p />
<font face=consolas>
<pre>
ArrowSize &#61; 1.000000
</pre>
</font>
<p />
<strong>d.</strong>	Provide it with a nice and friendly name to help minimize complications.
<p />
<font face=consolas>
<pre>
Name &#61; &#34;North Heading&#34;
</pre>
</font>
<p />
<strong>e.</strong>	Now close it out, and add it to the components array. You will see this pattern throughout the map components in Unreal Script.	End Object
<p />
<font face=consolas>
<pre>
Components(0) &#61; Arrow
</pre>
</font>
<p />
<strong>f.</strong>	For instance, the Sprite component. This one is going to be slightly easier to implement, but it requires that we know the package, group and/or name of the texture we want to display. Begin as we did previously, defining the new component object for our Sprite.
<p />
<font face=consolas>
<pre>
Begin Object Class&#61;SpriteComponent Name&#61;Sprite
</pre>
</font>
<p />
<strong>g.</strong>	We are going to plug in the new texture we want to have hooked to our element. As with all 2d sprites in the editor, it will always face the developer and should be as minimally intrusive as possible. As discussed earlier, our Sprite has been defined for us already – ‘UTBookTextures.compass’.
<p />
<font face=consolas>
<pre>
Sprite&#61;Texture2D&#39; CompassContent.compass&#39;
</pre>
</font>
<p />
<strong>h.</strong>	Now we will take a moment to set a couple boolean values, making it hidden in game and avoid loading it into the actual game when playing.
<p />
<font face=consolas>
<pre>
HiddenGame &#61; True
AlwaysLoadOnClient &#61; False
AlwaysLoadOnServer &#61; False
</pre>
</font>
<p />
<strong>i.</strong>	And finally close it out and add it to the Components array. This element you pass in is the Name=Sprite entry.
<p />
<font face=consolas>
<pre>
End Object
Components(1) &#61; Sprite
</pre>
</font>
</div>
<p />
<strong>7.</strong>	There are still a couple final elements that should be toggled for good housekeeping, lets cover those before we complete this task.
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	bStatic is a Boolean that controls whether the Mappers have the ability to change anything about this actor during game play. The compass should stick to pointing north, so it should be static.
<p />
<font face=consolas>
<pre>
bStatic   &#61; True
</pre>
</font>
<p />
<strong>b.</strong>	bHidden controls the visibility of the primitive components of this actor. You can think of this as a failsafe to the boolean values we changed on the Sprite component.
<p />
<font face=consolas>
<pre>
bHidden   &#61; True
</pre>
</font>
<p />
<strong>c.</strong>	bNoDelete controls the ability for this actor to be deleted during gameplay. It would be quite confusing for the compass to wink out of existence, so we clearly want this property set to True.
<p />
<font face=consolas>
<pre>
bNoDelete &#61; True
</pre>
</font>
<p />
<strong>d.</strong>	bMovable is tied into the movement of the actor. Another failsafe within the actor class.
<p />
<font face=consolas>
<pre>
bMovable  &#61; False
</pre>
</font>
</div>
<p />
You can find more information on the components by looking at the dozens of derivative classes under Component. Suffice to say that these two are to hook up a sprite and an arrow component on our object, based at its origin.
<p />
<h2><a name="TUTORIAL 13.3 – THE COMPASS, PART III: TESTING THE COMPASS, PART I"></a> TUTORIAL 13.3 – THE COMPASS, PART III: TESTING THE COMPASS, PART I </h2>
<p />
All of the coding is now behind us, at least for the compass element. We should now build the code and open up the editor to check that we did everything properly, place it into a map and then load it up into UT3 to test that the element is working.
<p />
<strong>1.</strong>	Go ahead and load up the editor. You should create a new (or open up an existing if you are so inclined) map and set it up to have the necessary elements.
<p />
<strong>2.</strong>	Open up the Actor Classes browser. This is within the Generic Browser, under Actor Classes and contains the class hierarchy within Unreal Script.
<p />
<strong>3.</strong>	The script package should already be loaded since it is in the ModPackages list in the UTEditor.ini file, but if it is not for some reason, go to File &gt; Open then navigate to your Unpublished\CookedPC\Scripts directory, where your compiled .u file resides.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_004.jpg"/><br/> <strong><font color=blue>Figure 13.4 - File Dialog Looking for MasteringUnrealScript.u</font></strong>
<p />
<strong>4.</strong>	Once it has loaded it should show the compass element in the class tree, under Actor, as seen in Figure 13.5. Select it and go over to your map. You should now be able to right click and an “Add Compass Here” menu option provided to you.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_005.jpg"/><br/> <strong><font color=blue>Figure 13.5  - Actor Class Browser with our Compass </font></strong>
<p />
<strong>5.</strong>	Selecting this element will create an element like the one in Figure 13.6. You can make sure it works properly by selecting it in the editor and switching to the rotation tool and see the arrow rotate.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_006.jpg"/><br/> <strong><font color=blue>Figure 13.6 - Our Compass Object in a map</font></strong>
<p />
<strong>6.</strong>	If you load up your level now you should see something like the following in your log file, showing that it is indeed working.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_007.jpg"/><br/> <strong><font color=blue>Figure 13.7 - Excerpt of the games log file.</font></strong>
<p />
As we can see here, our compass is reporting the appropriate values, in both radian and degree format, so our developers can do what they need to do. This is a prime example of where planning and interfaces come together. Just to recap, our process was as follows:
<p /> <ul>
<li> See what the needs of the class will be
</li> <li> Define the interface as per the specifications
</li> <li> Define the functions for our class, implementing the interface as a failsafe
</li> <li> Attach the necessary components
</li> <li> Test
</li></ul>
<p />
Now that we have a working implementation of this compass object, in the next series of tutorials you will be building upon this idea to create a fully-functional dynamic minimap system that follows the player’s position in the map and displays the locations of other players within the map as well.
<p />
<h2><a name="TUTORIAL 13.4 – THE MINIMAP, PART I: THE MU_MINIMAP CLASS"></a> TUTORIAL 13.4 – THE MINIMAP, PART I: THE MU_MINIMAP CLASS </h2>
<p />
Minimaps should be fairly familiar to anyone who has played any of the open sandbox –style games that have been released recently. Essentially, this is a map displayed on the screen at all times that shows a portion of the world surrounding the player. As the player moves or turns, the map moves or rotates with them. The minimap we will create will consist of two parts: the map and a compass overlay
<p />
In order to create a working minimap system, we will need three things: a subclass of the Compass class to place in the map and hold some data specific to the map in question, a new heads up display (HUD) class that will handle drawing the map to the screen, and a new gametype to force the new HUD class to be used. The HUD class will extend the basic UTHUD class and simply add the necessary functionality to draw the minimap. The gametype class will be a very simple extension of the UTDeathMatch gametype which overrides the type of HUD used and does a small amount of setup related to the minimap system.
<p />
To begin with, in this tutorial we will declare the MU_Minimap class which is a subclass of the Compass class.
<p />
<strong>1.</strong>	Open ConTEXT and create a new file named MU_Minimap.uc using the UnrealScript highlighter.
<p />
<strong>2.</strong>	Declare the new MU_Minimap class extending from the Compass class.
<p />
<font face=consolas>
<pre>
class MU&#95;Minimap extends Compass;
</pre>
</font>
<p />
<strong>3.</strong>	This class needs several editable variables declared. First, a MaterialInstanceConstant to hold a reference to the material to be used for the map itself. We will take a look at the material setup later once we have all the coding out of the way and we are ready to set up the MU_Minimap actor within our map.
<p />
<font face=consolas>
<pre>
var() MaterialInstanceConstant Minimap;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_008.jpg"/><br/> <strong><font color=blue>Figure 13.8 - An example minimap texture.</font></strong>
<p />
<strong>4.</strong>	Another MIC variable referencing the material for the compass overlay is also needed.
<p />
<font face=consolas>
<pre>
var() MaterialInstanceConstant CompassOverlay;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_009.jpg"/><br/> <strong><font color=blue>Figure 13.9 – An example of a compass overlay texture.</font></strong>
<p />
<strong>5.</strong>	A sphere component is added to the class and is made editable in order to make setting up the level and getting the map screenshot just right. The idea is that the location of this actor will represent the center of the map and the radius of the sphere will represent the extent in each direction covered by the map.
<p />
<font face=consolas>
<pre>
var() Const EditConst DrawSphereComponent MapExtentsComponent;
</pre>
</font>
<p />
<strong>6.</strong>	A Bool variable named bForwardAlwaysUp will allow the designer to specify whether the player’s forward movement should always be displayed as upward movement on the screen or at offset from straight up by the North direction angle as determined by the rotation of the MU_Minimap actor. The odds are good this will always be set to True as it makes the most sense, but we will leave the option.
<p />
<font face=consolas>
<pre>
var() Bool bForwardAlwaysUp;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_010.jpg"/><br/> <strong><font color=blue>Figure 13.10 – The arrow shows the direction of forward movement. On the left with bForwardAlwaysUp set to False, and on the right with it set to True.</font></strong>
<p />
<strong>7.</strong>	In order to track the player’s position in the map and convert it to a position in the map texture, we need to know the range of world space coordinates in the X- and Y-axes that is covered by the map texture. Two Vector2D variables will hold these values.
<p />
<font face=consolas>
<pre>
var Vector2D MapRangeMin;
var Vector2D MapRangeMax;
</pre>
</font>
<p />
<strong>8.</strong>	Another Vector2D variable will hold the X and Y world space coordinates corresponding to the center of the map texture.
<p />
<font face=consolas>
<pre>
var Vector2D MapCenter;
</pre>
</font>
<p />
<strong>9.</strong>	The values of the MapCenter variable will be assigned in the PostBeginPlay() function. Override this function and assign the values to this variable, making sure to call the parent class’s PostBeginPlay() function as well.
<p />
<font face=consolas>
<pre>
function PostBeginPlay()
{
   Super.PostBeginPlay();

   MapCenter.X &#61; MapRangeMin.X + ((MapRangeMax.X - MapRangeMin.X) / 2);
   MapCenter.Y &#61; MapRangeMin.Y + ((MapRangeMax.Y - MapRangeMin.Y) / 2);
}
</pre>
</font>
<p />
<strong>10.</strong>	Next, still in the PostBeginPlay() function, calculate the extents in each axis of the map by starting with the MapCenter and adding or subtracting the SphereRadius of the MapExtentsComponent.
<p />
<font face=consolas>
<pre>
MapRangeMin.X &#61; MapCenter.X - MapExtentsComponent.SphereRadius;
MapRangeMax.X &#61; MapCenter.X + MapExtentsComponent.SphereRadius;
MapRangeMin.Y &#61; MapCenter.Y - MapExtentsComponent.SphereRadius;
MapRangeMax.Y &#61; MapCenter.Y + MapExtentsComponent.SphereRadius;
</pre>
</font>
<p />
<strong>11.</strong>	Finally, create the DrawSphereComponent with e default radius of 1024.0 and using the color green. Also, set the value of bForwardAlwaysUp to True in the default properties as this is the most likely the desired functionality.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   Begin Object Class&#61;DrawSphereComponent Name&#61;DrawSphere0
        SphereColor&#61;(R&#61;0,G&#61;255,B&#61;0,A&#61;255)
        SphereRadius&#61;1024.000000
   End Object
   MapExtentsComponent&#61;DrawSphere0
   Components.Add(DrawSphere0)

   bForwardAlwaysUp&#61;True
}
</pre>
</font>
<p />
<strong>12.</strong>	Save the script to preserve your progress.
<p />
<h2><a name="TUTORIAL 13.5 – THE MINIMAP, PART II: THE MINIMAPGAME CLASS"></a> TUTORIAL 13.5 – THE MINIMAP, PART II: THE MINIMAPGAME CLASS </h2>
<p />
This tutorial focuses on the creation of the new Minimap gametype class. Its purpose is simply to hold a reference to the MU_Minimap actor placed within the map and tell the game to use the new HUD class we will create in subsequent tutorials.
<p />
<strong>1.</strong>	Open ConTEXT and create a new file named MinimapGame.uc using the UnrealScript highlighter.
<p />
<strong>2.</strong>	Declare the new MInimapGame class extending from the UTDeathMatch class.
<p />
<font face=consolas>
<pre>
class MinimapGame extends UTDeathMatch;
</pre>
</font>
<p />
<strong>3.</strong>	This class has one variable to declare, a MU_Minimap object reference named GameMInimap.
<p />
<font face=consolas>
<pre>
var MU&#95;Minimap GameMinimap;
</pre>
</font>
<p />
<strong>4.</strong>	When the game initializes, we must populate this variable with a reference to the MU_Minimap actor placed within the map. Override the InitGame() function making sure to call the parent class’s version of the function.
<p />
<font face=consolas>
<pre>
function InitGame( string Options, out string ErrorMessage )
{
   Super.InitGame(Options,ErrorMessage);
}
</pre>
</font>
<p />
<strong>5.</strong>	Inside the InitGame() function, a local MU_Minimap variable is needed.
<p />
<font face=consolas>
<pre>
local MU&#95;Minimap ThisMinimap;
</pre>
</font>
<p />
<strong>6.</strong>	An AllActors iterator is used to find the MU_Minimap actor within the level and assign it to the GameMinimap variable.
<p />
<font face=consolas>
<pre>
foreach AllActors(class&#39;MasteringUnrealScript.MU&#95;Minimap&#39;,ThisMinimap)
{
   GameMinimap &#61; ThisMinimap;
   break;
}
</pre>
</font>
<p />
<strong>7.</strong>	In the default properties, the HUDType variable of the gametype is overridden to force the HUD class we will create to be used.
<p />
<font face=consolas>
<pre>
HUDType&#61;Class&#39;MasteringUnrealScript.MinimapHUD&#39;
</pre>
</font>
<p />
<strong>8.</strong>	Also, the the MapPrefixes(0) variable is overridden to determine what maps are associated with this gametype.
<p />
<font face=consolas>
<pre>
MapPrefixes(0)&#61;&#34;COM&#34;
</pre>
</font>
<p />
<strong>9.</strong>	Save the script to preserve your work.
<p />
<h2><a name="TUTORIAL 13.6 – THE MINIMAP, PART III: MINIMAPHUD INITIAL SETUP"></a> TUTORIAL 13.6 – THE MINIMAP, PART III: MINIMAPHUD INITIAL SETUP </h2>
<p />
With the minimap actor and gametype classes out of the way, we turn our attention to the HUD class. In this tutorial, we will focus on declaring the class and its variables as well as setting some default properties for those variables.
<p />
<strong>1.</strong>	Open ConTEXT and create a new file named MinimapHUD.uc using the UnrealScript highlighter.
<p />
<strong>2.</strong>	Declare the MinimapHUD class extending from the UTHUD class.
<p />
<font face=consolas>
<pre>
class MinimapHUD extends UTHUD;
</pre>
</font>
<p />
<strong>3.</strong>	This class will also hold its own reference to the minimap actor in the level.
<p />
<font face=consolas>
<pre>
var MU&#95;Minimap GameMinimap;
</pre>
</font>
<p />
<strong>4.</strong>	A Float variable named TileSize will hold a value specifying the amount of the full map that will be displayed at any time. So if the full map texture is 2048x2048, and this value is 0.25, then the portion of the map texture that would be displayed would be 512x512.
<p />
<font face=consolas>
<pre>
var Float TileSize;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_011.jpg"/><br/> <strong><font color=blue>Figure 13.11 – The portion of the map drawn using TileSize values of 0.25 and 0.5.</font></strong>
<p />
<strong>5.</strong>	An Int variable named MapDim represents the dimensions of the map as drawn on the screen at the default resolution of 1024x768.
<p />
<font face=consolas>
<pre>
var Int MapDim;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_012.jpg"/><br/> <strong><font color=blue>Figure 13.12 – MapDim specifies the dimensions of the map as drawn on screen.</font></strong>
<p />
<strong>6.</strong>	Another Int variable specifies the size of the box representing the players on the map at the default resolution of 1024x768.
<p />
<font face=consolas>
<pre>
var Int BoxSize;
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_013.jpg"/><br/> <strong><font color=blue>Figure 13.13 – BoxSize specifies the dimensions of the player box as drawn on screen.</font></strong>
<p />
<strong>7.</strong>	The last variable is an array of two colors which are used to draw the players on the map. One of the colors is for the owner of the HUD and the other color is for all the other players in themap.
<p />
<font face=consolas>
<pre>
var Color PlayerColors&#91;2];
</pre>
</font>
<p />
<strong>8.</strong>	The default properties block should be fairly straightforward.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   MapDim&#61;256
   BoxSize&#61;12
   PlayerColors(0)&#61;(R&#61;255,G&#61;255,B&#61;255,A&#61;255)
   PlayerColors(1)&#61;(R&#61;96,G&#61;255,B&#61;96,A&#61;255)
   TileSize&#61;0.4
   MapPosition&#61;(X&#61;0.000000,Y&#61;0.000000)
}
</pre>
</font>
<p />
<strong>9.</strong>	Save the script to preserve your progress.
<p />
<h2><a name="TUTORIAL 13.7 - THE MINIMAP, PART IV: MINIMAPHUD FUNCTIONS"></a> TUTORIAL 13.7 - THE MINIMAP, PART IV: MINIMAPHUD FUNCTIONS </h2>
<p />
Before we move on to implementing the functionality for drawing the map, the PostBeginPlay() and DrawHUD() functions need to be overridden in the MinimapHUD class and a new function named GetPlayerHeading() is added.
<p />
<strong>1.</strong>	Open ConTEXT and the MinimapHUD.uc file.
<p />
<strong>2.</strong>	First, the PostBeginPlay() function is overridden and used to assign the gametype’s reference to the minimap actor in the map to the GameMInimap variable in this class.
<p />
<font face=consolas>
<pre>
simulated function PostBeginPlay()
{
   Super.PostBeginPlay();

   GameMinimap &#61; MinimapGame(WorldInfo.Game).GameMinimap;
}
</pre>
</font>
<p />
<strong>3.</strong>	Next, the DrawHUD() function is overridden and a call to the function which will be responsible for drawing the map, the DrawMap() function,  is added. This will essentially force the map to be drawn at all times whether the player is alive or dead an whether the game is still going or has ended.
<p />
<font face=consolas>
<pre>
function DrawHUD()
{
   Super.DrawHUD();

   DrawMap();
}
</pre>
</font>
<p />
<strong>4.</strong>	The GetPlayerHeading() function is very much like the GetRadianHeading() function found in the Compass class created previously. Copy this function from the Compass class and paste it into the MinimapHUD class now. The code below should now be in the MinimapHUD class.
<p />
<font face=consolas>
<pre>
function float GetRadianHeading()
{
   local Vector v;
   local Rotator r;
   local float f;

   r.Yaw &#61; GetYaw();
   v &#61; vector(r);
   f &#61; GetHeadingAngle(v);
   f &#61; UnwindHeading(f);

   while (f &#60; 0)
      f +&#61; PI &#42; 2.0f;

   return f;
}
</pre>
</font>
<p />
<strong>5.</strong>	Change the name of the function to GetPlayerHeading()
<p />
<font face=consolas>
<pre>
function float GetPlayerHeading()
{
   local Vector v;
   local Rotator r;
   local float f;

   r.Yaw &#61; GetYaw();
   v &#61; vector(r);
   f &#61; GetHeadingAngle(v);
   f &#61; UnwindHeading(f);

   while (f &#60; 0)
      f +&#61; PI &#42; 2.0f;

   return f;
}
</pre>
</font>
<p />
<strong>6.</strong>	Next, change the line that reads:
<p />
<font face=consolas>
<pre>
r.Yaw &#61; GetYaw();
</pre>
</font>
<p />
To read:
<p />
<font face=consolas>
<pre>
r.Yaw &#61; PlayerOwner.Pawn.Rotation.Yaw;
</pre>
</font>
<p />
<strong>7.</strong>	Save the script to preserve your work.
<p />
<h2><a name="TUTORIAL 13.8 – THE MINIMAP, PART V:  DRAWMAP() INITIAL SETUP"></a> TUTORIAL 13.8 – THE MINIMAP, PART V:  DRAWMAP() INITIAL SETUP </h2>
<p />
The DrawMap() function is responsible for performing all the remaining necessary calculations and drawing the map to the screen. In this tutorial, the function and all local variables will be declared.
<p />
<strong>1.</strong>	Open ConTEXT and the MinimapHUD.uc script.
<p />
<strong>2.</strong>	Declare the DrawMap function.
<p />
<font face=consolas>
<pre>
function DrawMap()
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Two local Floats will hold the headings for the direction of North as specified by the minimap actor in the map and for the direction the player is currently facing.
<p />
<font face=consolas>
<pre>
local Float TrueNorth;
local Float PlayerHeading;
</pre>
</font>
<p />
<strong>4.</strong>	Declare local Float variables for the rotation of the map and the rotation of the compass overlay
<p />
<font face=consolas>
<pre>
local Float MapRotation;
local Float CompassRotation;
</pre>
</font>
<p />
<strong>5.</strong>	Several local Vector variables are declared. Their uses will be explained in detail later.
<p />
<font face=consolas>
<pre>
local Vector PlayerPos;
local Vector ClampedPlayerPos;
local Vector RotPlayerPos;
local Vector DisplayPlayerPos;
local vector StartPos;
</pre>
</font>
<p />
<strong>6.</strong>	The minimap material uses a transparency mask to force the map to display in a circular shape. In order to move this mask to the proper location, the R and G components of a Vector Parameter are added to the texture coordinates to offset the position of the mask texture. A LinearColor local variable is needed to pass the appropriate value to the Vector Parameter in the material.
<p />
<font face=consolas>
<pre>
local LinearColor MapOffset;
</pre>
</font>
<p />
<strong>7.</strong>	A local Float variable holds the distance in world space coordinates covered by the map. For simplicity, we are requiring that a square map texture be used and thus only one range is needed.
<p />
<font face=consolas>
<pre>
local Float ActualMapRange;
</pre>
</font>
<p />
<strong>8.</strong>	Finally, a local Controller variable is used with an iterator to draw the positions of all the players within the map.
<p />
<font face=consolas>
<pre>
local Controller C;
</pre>
</font>
<p />
<strong>9.</strong>	Before moving on, the location the map will be drawn to on the screen as well as the size of the adjusted size of the map and player boxes can be set. The MapPosition variable of the class holds relative position values. Multiplying these by the width and height of the viewport will result in the absolute position at which to draw the map. The current width and height of the viewport are provided in the form of the FullWidth and FullHeight variables.
<p />
<font face=consolas>
<pre>
MapPosition.X &#61; default.MapPosition.X &#42; FullWidth;
MapPosition.Y &#61; default.MapPosition.Y &#42; FullHeight;
</pre>
</font>
<p />
<strong>10.</strong>	The size of the map and player boxes is calculated each frame by multiplying the default values of these variables by the scaling factor for the viewport at its current resolution. This scaling factor is held in the ResolutionScale variable.
<p />
<font face=consolas>
<pre>
MapDim &#61; default.MapDim &#42; ResolutionScale;
BoxSize &#61; default.BoxSize &#42; ResolutionScale;
</pre>
</font>
<p />
<strong>11.</strong>	Save the script to preserve your progress.
<p />
<h2><a name="TUTORIAL 13.9 – THE MINIMAP, PART VI:  PLAYERPOS AND CLAMPEDPLAYERPOS"></a> TUTORIAL 13.9 – THE MINIMAP, PART VI:  PLAYERPOS AND CLAMPEDPLAYERPOS </h2>
<p />
The PlayerPos and ClampedPlayerPos variables hold the player’s current location as a normalized offset from the center of the map. If you consider the length of the full map being 1.0 in each direction, each component of these variables can have a value between -0.5 and 0.5 since they represent offsets from the center.  You may be wondering why use an offset from the center of the map. The reason is because the map will be rotated around its center inside of the material and we need to know the position relative to that in order to calculate everything correctly as you will see later on.
<p />
Of course, before we can calculate normalized values, we must know the length the map covers in world space coordinate values. This is where we begin in this tutorial.
<p />
<strong>1.</strong>	Open ConTEXT and the MinimapHUD.uc script.
<p />
<strong>2.</strong>	The ActualMapRange is calculated by taking the larger of the two ranges between the X-axis and the Y-axis, though they should be equal. This merely a failsafe. The range of each axis is calculated by taking the difference between the values set in the MapRandMin and MapRangeMax elements of the GameMinimap.
<p />
<font face=consolas>
<pre>
ActualMapRange &#61; FMax(GameMinimap.MapRangeMax.X - GameMinimap.MapRangeMin.X,
         GameMinimap.MapRangeMax.Y - GameMinimap.MapRangeMin.Y);
</pre>
</font>
<p />
<strong>3.</strong>	This next part is tricky because when taking the screenshot of the level to use as the map, you must use the Top viewport inside of UnrealEd since this gives you no perspective distortion. However, the axes as displayed in that viewport have X in the vertical direction and Y in the horizontal direction. As far as the HUD and Canvas are concerned, the horizontal direction of the viewport is X and the vertical direction is Y. To complicate matters even more, the X-axis inside of UnrealEd as seen from the Top viewport increases as it moves from bottom to top, while the game’s viewport increases as it moves from top to bottom.
<p />
It boils down to the axes must be swapped and when dealing with the X-axis world coordinates, the values must be the opposite sign. This will align the world space coordinates as they would be in the Top viewport in UnrealEd with the way they are handled with respect to the HUD.
<p />
Let’s start with the X component of the PlayerPos. To get the normalized offset from the center, the map’s center must be subtracted from the location of the player. Then that value must be divided by the range we just calculated. Remember that the X component of a position in the HUD corresponds to the Y component of world space locations.
<p />
<font face=consolas>
<pre>
PlayerPos.X &#61; (PlayerOwner.Pawn.Location.Y – GameMinimap.MapCenter.Y) / ActualMapRange;
</pre>
</font>
<p />
<strong>4.</strong>	The Y component of the PlayerPos corresponds to the X component of the world space location, but must be multiplied by -1 in order to get the opposite value. The easiest way to achieve this is simply to swap the order of the subtraction.
<p />
<font face=consolas>
<pre>
PlayerPos.Y &#61; (GameMinimap.MapCenter.X - PlayerOwner.Pawn.Location.X) / ActualMapRange;
</pre>
</font>
<p />
<strong>5.</strong>	So that gives us the player’s position on the map, but what happens when the player is very close to one of the edges? Since the minimap is designed to show the player’s location in the center with the map all around it, we run the risk of the map texture tiling if we allow the player to get close to the edge while still displaying the player in the center of the minimap. To account for this, we will use the ClampedPlayerPos variable to hold a second location which is limited to always be just far enough from the edge to never allow any tiling.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_014.jpg"/><br/> <strong><font color=blue>Figure 13.14 – The map drawn without clamping on the left, and with clamping on the right.</font></strong>
<p />
To do this, the FClamp() function is used. By passing the value to be clamped along with the two limits to clamp it within, we can assure that the positions will always be within a safe range. The two limits will be:
<p />
<font face=consolas>
<pre>
-0.5 + (TileSize / 2.0)
</pre>
</font>
<p />
and
<p />
<font face=consolas>
<pre>
0.5 - (TileSize / 2.0)
</pre>
</font>
<p />
We’ve already mentioned the normalized offset values are between -0.5 and 0.5. Adding or subtracting half the portion of the map being displayed from these will make sure the portion never overlaps causing tiling of the map texture.
<p />
Clamp the X component of the player’s position now.
<p />
<font face=consolas>
<pre>
ClampedPlayerPos.X &#61; FClamp(   PlayerPos.X,
            -0.5 + (TileSize / 2.0),
            0.5 - (TileSize / 2.0));
</pre>
</font>
<p />
<strong>6.</strong>	Now do the same for the Y component.
<p />
<font face=consolas>
<pre>
ClampedPlayerPos.Y &#61; FClamp(   PlayerPos.Y,
            -0.5 + (TileSize / 2.0),
            0.5 - (TileSize / 2.0));
</pre>
</font>
<p />
<strong>7.</strong>	Save the script to preserve your work.
<p />
<h2><a name="TUTORIAL 13.10 – THE MINIMAP, PART VII:  MAP ROTATION"></a> TUTORIAL 13.10 – THE MINIMAP, PART VII:  MAP ROTATION </h2>
<p />
Now the fun begins as the map must be rotated to account for the direction the player is facing. Rotating the map itself is actually extremely easy; we just pass a radian value to a Scalar Parameter within the material the drives a Rotator expression. Making this even easier, the Rotator within the material will rotate the opposite direction of the rotation calculated by the GetPlayerHeading() or GetRadianHeading() functions which is ideal since the map should rotate the opposite direction that the player is turning.
<p />
The real fun part is calculating the rotated position of the player within the map. We know the player’s position relative to the center of the texture, but the moment that texture gets rotated, the position we just calculated no longer corresponds to the spot on the map where the player should be displayed. With a little trigonometry, though, we can calculate the rotated position. First, we need to know how much to rotate everything.
<p />
<strong>1.</strong>	Open ConTEXT and the MinimapHUD.uc script.
<p />
<strong>2.</strong>	The TrueNorth and PlayerHeading variables need to be populated with the appropriate radian values.
<p />
<font face=consolas>
<pre>
TrueNorth &#61; GameMinimap.GetRadianHeading();
Playerheading &#61; GetPlayerHeading();
</pre>
</font>
<p />
<strong>3.</strong>	Now, we can use those values to set the MapRotation, CompassRotation, and InverseRotation values, but how we do that is dependent on the value of the bForwardAlwaysUp variable of the GameMInimap minimap actor. Create an If-statement with this variable’s value as the condition.
<p />
<font face=consolas>
<pre>
if(GameMinimap.bForwardAlwaysUp)
{
}
else
{
}
</pre>
</font>
<p />
<strong>4.</strong>	If bForwardAlwaysUp is True, the map is rotated based solely on the PlayerHeading and the CompassRotation is the difference between the Playerheading and TrueNorth.
<p />
<font face=consolas>
<pre>
MapRotation &#61; PlayerHeading;
CompassRotation &#61; PlayerHeading - TrueNorth;
</pre>
</font>
<p />
<strong>5.</strong>	If bForwardAlwaysUp is False, the map is rotated based on the difference between the PlayerHeading and TrueNorth and the CompassRotation is the same as the MapRotation.
<p />
<font face=consolas>
<pre>
MapRotation &#61; PlayerHeading - TrueNorth;
CompassRotation &#61; MapRotation;
</pre>
</font>
<p />
<strong>6.</strong>	The basic idea when rotating a point around another point is to use the parametric equation of a circle:
<p />
The radius in this case, would be the distance from the center of the map to the player’s position, or the length of the PlayerPos vector.
<p />
<font face=consolas>
<pre>
VSize(PlayerPos)
</pre>
</font>
<p />
The angle of rotation requires a little more complexity to decipher. The angle of rotation is the angle between the positive X-axis, or 0 radians, and the vector from the center of the map to the position the player would be after being rotated.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_015.jpg"/><br/> <strong><font color=blue>Figure 13.15 – The angle needed to calculate the rotated player’s position.</font></strong>
<p />
You may be thinking to yourself, “The whole point of this is to calculate the position of the player after being rotated. How do we find that angle if we don’t know the position?” We do know the player’s actual location and we can find the angle between the positive X-axis and the vector from the center of the map to that location. This is done by passing the Y and X components of the player’s position to the Atan() function which calculates the arctangent given the lengths of the opposite and adjacent sides of a triangle. For example:
<p />
<font face=consolas>
<pre>
Atan(PlayerPos.Y, PlayerPos.X)
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_016.jpg"/><br/> <strong><font color=blue>Figure 13.16 – The angle to the player’s actual position.</font></strong>
<p />
And we know the amount that position is to be rotated. By subtracting the MapRotation from the angle between the positive X-axis and the player’s position, we can calculate the angle between the positive X-axis and the rotated position. So the actual value of   in the equations above is:
<p />
<font face=consolas>
<pre>
Atan(PlayerPos.Y, PlayerPos.X) – MapRotation
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_017.jpg"/><br/> <strong><font color=blue>Figure 13.17 – Subtracting the angle rotation leaves the desired angle.</font></strong>
<p />
Putting it all together, the rotated player position is calculated as:
<p />
<font face=consolas>
<pre>
DisplayPlayerPos.X &#61; VSize(PlayerPos) &#42; Cos( ATan(PlayerPos.Y, PlayerPos.X) - MapRotation);
DisplayPlayerPos.Y &#61; VSize(PlayerPos) &#42; Sin( ATan(PlayerPos.Y, PlayerPos.X) - MapRotation);
</pre>
</font>
<p />
<strong>7.</strong>	Notice we have set the DisplayPlayerPos by rotating the PlayerPos. We also need to set the RotPlayerPos by rotating the ClampedPlayerPos in the same manner.
<p />
<font face=consolas>
<pre>
RotPlayerPos.X &#61; VSize(ClampedPlayerPos) &#42; Cos( ATan(ClampedPlayerPos.Y, ClampedPlayerPos.X) - MapRotation);
RotPlayerPos.Y &#61; VSize(ClampedPlayerPos) &#42; Sin( ATan(ClampedPlayerPos.Y, ClampedPlayerPos.X) - MapRotation);
</pre>
</font>
<p />
<strong>8.</strong>	The DisplayPlayerPos is the actual position of the player on the rotated map and is used to draw the player box. The RotPlayerPos is the position on the map that represents the center of the displayed portion of the map. This is the position that is used to find the StartPos, or the top left corner of the portion of the map to be displayed. This is calculated by adding 0.5 to both the X and Y components since they are offsets from the center and we need absolute values now. Then, half the TileSize is subtracted from each. The result is then clamped between 0.0 and 1.0 minus the TileSize just as one last precaution to make sure no tiling occurs, though this value should already fall within these limits.
<p />
<font face=consolas>
<pre>
StartPos.X &#61; FClamp(RotPlayerPos.X + (0.5 - (TileSize / 2.0)),0.0,1.0 - TileSize);
StartPos.Y &#61; FClamp(RotPlayerPos.Y + (0.5 - (TileSize / 2.0)),0.0,1.0 - TileSize);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_018.jpg"/><br/> <strong><font color=blue>Figure 13.18 – The upper left corner of the portion to be drawn is the StartPos.</font></strong>
<p />
<strong>9.</strong>	The final aspect of rotating the map is to set the MapOffset values to be passed to the material to pan the transparency mask correctly. The R and G components of the MapOffset inversely correspond to the X and Y components of the RotPlayerPos. In other words, the RotPlayerPos values are multiplied by -1 and assigned to the R and G components of the MapOffset. But first, they are clamped to the same range the ClampedPlayerRot values were clamped to previously, again, as one last precaution.
<p />
<font face=consolas>
<pre>
MapOffset.R &#61;  FClamp(-1.0 &#42; RotPlayerPos.X,
          -0.5 + (TileSize / 2.0),
          0.5 - (TileSize / 2.0));
MapOffset.G &#61;  FClamp(-1.0 &#42; RotPlayerPos.Y,
          -0.5 + (TileSize / 2.0),
          0.5 - (TileSize / 2.0));
</pre>
</font>
<p />
<strong>10.</strong>	Save the script to preserve your progress.
<p />
<h2><a name="TUTORIAL 13.11 – THE MINIMAP, PART VII: SET MATERIAL PARAMS AND DRAW MAP"></a> TUTORIAL 13.11 – THE MINIMAP, PART VII: SET MATERIAL PARAMS AND DRAW MAP </h2>
<p />
Everything needed to commence updating the material parameters and drawing the map has been calculated and is ready to go. This tutorial will cover setting the parameters of the map and compass overlay materials as well as drawing the map, compass overlay, and player box.
<p />
<strong>1.</strong>	Open ConTEXT and the MinimapHUD.uc script.
<p />
<strong>2.</strong>	The map material has MapRotation, TileSize and MapOffset parameters. MapRotation is a scalar parameter that controls the rotation of the map texture. TileSize is also a scalar parameter that controls the tiling, and consequently the size, of the transparency mask. MapOffset is a vector parameter that controls the position of the transparency mask. The compass overlay material has a single scalar parameter, CompassRotation, which controls the rotation of the overlay. These can all be set using the appropriate Set*Paramater() function of the MaterialInstanceConstant class and passing the name of the parameter and the value to assign to it. The variables holding the values for each parameter have been named the same as the parameter names to make it easy to know what goes with what.
<p />
<font face=consolas>
<pre>
GameMinimap.Minimap.SetScalarParameterValue(&#39;MapRotation&#39;,MapRotation);
GameMinimap.Minimap.SetScalarParameterValue(&#39;TileSize&#39;,TileSize);
GameMinimap.Minimap.SetVectorParameterValue(&#39;MapOffset&#39;,MapOffset);
GameMinimap.CompassOverlay.SetScalarParameterValue(&#39;CompassRotation&#39;,CompassRotation);
</pre>
</font>
<p />
<strong>3.</strong>	Before we get into any drawing, we should briefly discuss how the HUD draws items to the screen. In reality, the HUD doesn’t ever do any drawing of its own. Another class, Canvas, contains all the drawing functionality. The HUD classes contain a reference to the current Canavs and that is used any time an item need to be drawn to the screen. Drawing the map is fairly simple once you understand how things work. One important thing to keep in mind is the order in which you draw items as an item drawn after another in the same location will draw on top of the first..
<p />
First, the drawing position of the Canvas needs to be set to the location the map should be drawn. This is specified by the MapPosition variable.
<p />
<font face=consolas>
<pre>
Canvas.SetPos(MapPosition.X,MapPosition.Y);
</pre>
</font>
<p />
<strong>4.</strong>	Next, the map is drawn using the DrawMaterialTile() function of the Canvas. This function takes in the material to be drawn, the width and height of the tile to be drawn, the position within the material to begin drawing, and the width and height of the portion of the material to be drawn.
<p />
<font face=consolas>
<pre>
Canvas.DrawMaterialTile(GameMinimap.Minimap,
            MapDim,
            MapDim,
            StartPos.X,
            StartPos.Y,
            TileSize,
         TileSize );
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_019.jpg"/><br/> <strong><font color=blue>Figure 13.19 – The map has been drawn to the screen.</font></strong>
<p />
<strong>5.</strong>	Next, the position of the Canvas is set to the location to draw the player at. This means the DisplayPlayerPos needs to be converted from an offset to an absolute position, which is done by adding 0.5. Then, it must be converted to an offset from the StartPos since only a portion of the full map is drawn by subtracting the StartPos. That value is divided by the current TileSize to normalize the value to the range 0.0-1.0. The normalized position in UV coordinates is multiplied by the dimensions of the map tile, or MapDim, to convert it to screen coordinates. Then, half the player box size is subtracted so that the player box will be centered on the location. Finally, the whole thing is added to the MapPosition.
<p />
<font face=consolas>
<pre>
Canvas.SetPos(   MapPosition.X + MapDim &#42; (((DisplayPlayerPos.X + 0.5) - StartPos.X) / TileSize) - (BoxSize / 2),MapPosition.Y + MapDim &#42; (((DisplayPlayerPos.Y + 0.5) - StartPos.Y) / TileSize) - (BoxSize / 2));
</pre>
</font>
<p />
<strong>6.</strong>	The DrawColor of the canvas is set to the first element in the PlayerColors array as this is the color we have chosen for the player.
<p />
<font face=consolas>
<pre>
Canvas.SetDrawColor(   PlayerColors&#91;0].R,
         PlayerColors&#91;0].G,
         PlayerColors&#91;0].B,
         PlayerColors&#91;0].A);
</pre>
</font>
<p />
<strong>7.</strong>	Now, the player box is drawn with the appropriate size.
<p />
<font face=consolas>
<pre>
Canvas.DrawBox(BoxSize,BoxSize);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_020.jpg"/><br/> <strong><font color=blue>Figure 13.20 – The player’s box has been drawn to the screen on top of the map.</font></strong>
<p />
<strong>8.</strong>	To draw the compass overlay, the position of the Canvas is set back to the MapPosition.
<p />
<font face=consolas>
<pre>
Canvas.SetPos(MapPosition.X,MapPosition.Y);
</pre>
</font>
<p />
<strong>9.</strong>	Then, the CompassOverlay material of the GameMinimap is drawn using the DrawMaterialTile() function again.
<p />
<font face=consolas>
<pre>
Canvas.DrawMaterialTile(GameMinimap.CompassOverlay,MapDim,MapDim,0.0,0.0,1.0,1.0);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_021.jpg"/><br/> <strong><font color=blue>Figure 13.21 – The compass overlay has now been drawn on top of the map.</font></strong>
<p />
<strong>10.</strong>	Save the script to preserve your progress.
<p />
<h2><a name="TUTORIAL 13.12 – THE MINIMAP, PART VIII: DRAWING OTHER PLAYERS"></a> TUTORIAL 13.12 – THE MINIMAP, PART VIII: DRAWING OTHER PLAYERS </h2>
<p />
In this tutorial, each of the other players within the level will be drawn on the map assuming they are located within the range visible in the minimap.
<p />
<strong>1.</strong>	Open ConTEXT and the MinimapHUD.uc script.
<p />
<strong>2.</strong>	After the code that draws the player but before the compass overlay is drawn, set up an AllControllers iterator using the WorldInfo reference and passing the base Controller class and the C local variable declared previously. The reason for doing this after the player box is drawn and before the compass overlay is drawn is two-fold. First, it allows us to reuse some of the variables used to calculate the player’s position with no worries about overwriting their values. Second, by drawing the compass overlay on top of everything, it hides the blinking out of existence of the other players’ boxes when they leave the viewable area of the map, resulting in a nice clean transition.
<p />
<font face=consolas>
<pre>
foreach WorldInfo.AllControllers(class&#39;Controller&#39;,C)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Now, use an If-statement to makes sure the current Controller in the iterator is not the PlayerOwner so we don’t draw over it.
<p />
<font face=consolas>
<pre>
if(PlayerController(C) !&#61; PlayerOwner)
{
}
</pre>
</font>
<p />
<strong>4.</strong>	Inside this If-statement, the normalized offset position of the current Controller’s Pawn needs to be calculated. This is the same as the DisplayePlayerPos calculated for the player earlier only for the current Controller. It is probably easiest just to copy the code calculating the PlayerPos and DisplayPlayerPos already present and paste them into the If-statement.
<p />
<font face=consolas>
<pre>
PlayerPos.X &#61; (PlayerOwner.Pawn.Location.Y - GameMinimap.MapCenter.Y) / ActualMapRange;
PlayerPos.Y &#61; (GameMinimap.MapCenter.X - PlayerOwner.Pawn.Location.X) / ActualMapRange;

DisplayPlayerPos.X &#61; VSize(PlayerPos) &#42; Cos( ATan(PlayerPos.Y, PlayerPos.X) - MapRotation);
DisplayPlayerPos.Y &#61; VSize(PlayerPos) &#42; Sin( ATan(PlayerPos.Y, PlayerPos.X) - MapRotation);
</pre>
</font>
<p />
Now, simply replace any occurrences of the term PlayerOwner with the C variable.
<p />
<font face=consolas>
<pre>
PlayerPos.X &#61; (C.Pawn.Location.Y - GameMinimap.MapCenter.Y) / ActualMapRange;
PlayerPos.Y &#61; (GameMinimap.MapCenter.X - C.Pawn.Location.X) / ActualMapRange;

DisplayPlayerPos.X &#61; VSize(PlayerPos) &#42; Cos( ATan(PlayerPos.Y, PlayerPos.X) - MapRotation);
DisplayPlayerPos.Y &#61; VSize(PlayerPos) &#42; Sin( ATan(PlayerPos.Y, PlayerPos.X) - MapRotation);
</pre>
</font>
<p />
<strong>5.</strong>	That gives us the actual rotated position of the current Controller’s Pawn relative to the center of the map. Now, we must make sure this position is within a specific distance from the player’s rotated position to determine whether this Controller should be drawn or not.
<p />
The VSize() function is used to get the distance from the player’s position to the Controller’s position.
<p />
<font face=consolas>
<pre>
VSize(DisplayPlayerPos - RotPlayerPos)
</pre>
</font>
<p />
The upper limit for this distance is basically half the TileSize less half the diagonal length of the player box. The only problem is the TileSize is normalized to the 0.0-1.0 range and the BoxSize is in screen coordinates so it must be normalized.
<p />
Half the diagonal length of the player box is calculated like so:
<p />
<font face=consolas>
<pre>
Sqrt(2 &#42; Square(BoxSize / 2))
</pre>
</font>
<p />
To normalize that length, it must then be divided by the dimensions of the map and multipled by the TileSize.
<p />
<font face=consolas>
<pre>
(TileSize &#42; Sqrt(2 &#42; Square(BoxSize / 2)) / MapDim)
</pre>
</font>
<p />
So the final distance is half the TileSize minus that calculation.
<p />
<font face=consolas>
<pre>
((TileSize / 2.0) - (TileSize &#42; Sqrt(2 &#42; Square(BoxSize / 2)) / MapDim))
</pre>
</font>
<p />
Now, make an If-statement comparing the distance between the two players and this distance.
<p />
<font face=consolas>
<pre>
if(VSize(DisplayPlayerPos - RotPlayerPos) &#60;&#61; ((TileSize / 2.0) - (TileSize &#42; Sqrt(2 &#42; Square(BoxSize / 2)) / MapDim)))
{
}
</pre>
</font>
<p />
<strong>6.</strong>	Copy the three lines of code that draw the player’s box on the screen and paste them inside the If-statement.
<p />
<font face=consolas>
<pre>
Canvas.SetPos(   MapPosition.X + MapDim &#42; (((DisplayPlayerPos.X + 0.5) - StartPos.X) / TileSize) - (BoxSize / 2),MapPosition.Y + MapDim &#42; (((DisplayPlayerPos.Y + 0.5) - StartPos.Y) / TileSize) - (BoxSize / 2));

Canvas.SetDrawColor(   PlayerColors&#91;0].R,
         PlayerColors&#91;0].G,
         PlayerColors&#91;0].B,
         PlayerColors&#91;0].A);

Canvas.DrawBox(BoxSize,BoxSize);
</pre>
</font>
<p />
<strong>7.</strong>	Change the index of the PlayerColors array being accessed in the SetDrawColor() function call to the second element.
<p />
<font face=consolas>
<pre>
Canvas.SetDrawColor(   PlayerColors&#91;1].R,
         PlayerColors&#91;1].G,
         PlayerColors&#91;1].B,
         PlayerColors&#91;1].A);
</pre>
</font>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_022.jpg"/><br/> <strong><font color=blue>Figure 13.22 – The other players in the level now appear on the map.</font></strong>
<p />
<strong>8.</strong>	Save the script and compile. Make sure the CompassContent.upk package provided on the DVD with the files for this chapter is located within the Unpublished\CookedPC directory. Fix any syntax errors which may be present.
<p />
<h2><a name="TUTORIAL 13.13 – THE MINIMAP, PART IX: MAP SETUP AND SCREENSHOT"></a> TUTORIAL 13.13 – THE MINIMAP, PART IX: MAP SETUP AND SCREENSHOT </h2>
<p />
Now it is time to start to put everything into place to test out the minimap system. First, we need to set up a map with the MU_Minimap actor and et a screenshot of it to use as the map.
<p />
<strong>1.</strong>	Open UnrealEd and open the COM-CH_13_Minimap.ut3 map provided on the DVD with the files for this chapter.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_023.jpg"/><br/> <strong><font color=blue>Figure 13.23 – The COM-CH_13_Minimap.ut3 map.</font></strong>
<p />
<strong>2.</strong>	Open the Actor Classes Browser and select the MU_Minimap class listed under Actor-&gt;Compass-&gt;MU_Minimap.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_024.jpg"/><br/> <strong><font color=blue>Figure 13.24 – The MU_Minimap class is selected.</font></strong>
<p />
<strong>3.</strong>	In the viewport, add a new MU_Minimap actor to the map. Place it near the center of the map as best you can. It doesn’t have to be exact, just close. You may also rotate the actor around the Y-axis if you wish to adjust the direction to be used as North in this map.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_025.jpg"/><br/> <strong><font color=blue>Figure 13.25 – The placement of the MU_Minimap actor.</font></strong>
<p />
<strong>4.</strong>	In the Top viewport, zoom out a good ways, and then open the Properties Window with the MU_Minimap actor selected.
<p />
Find the SphereRadius property in the MU_Minimap category by expanding the MapExtentsComponent section. Increase the value of this property until the sphere in the viewport encompasses the entire playable area of the map. Try to leave some empty space around the outside of the map as well. A good value for this property would be around 1600.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_026.jpg"/><br/> <strong><font color=blue>Figure 13.26 – The radius of the sphere has been adjusted.</font></strong>
<p />
<strong>5.</strong>	Save this map now as we are going to be tearing it apart over the remainder of this tutorial.
<p />
<strong>6.</strong>	Before we can assign a map material and compass overlay material, we need to take the screenshot of the level to be used for the minimap. Because this is an indoor level, taking a screenshot from the Top viewport requires a little more work than for an outdoor map; mainly the ceiling needs to be removed so we can see into the rooms in the Top viewport.
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	This isn’t all that difficult in this case. Select one of the static meshes making up the ceiling and then right-click on it and choose Select Matching Static Meshes (This Class). This will select the ceiling and the floor.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_027.jpg"/><br/> <strong><font color=blue>Figure 13.27 – All of the floor and ceiling meshes are selected.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>b.</strong>	In the Front or Side viewport, Hold Ctrl + Alt + Shift + Right Mouse Button and then drag the marquee selection around the floor meshes that are selected. This will remove them from the selection, leaving only the ceiling selected. Press the Delete key to remove the ceiling.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_028.jpg"/><br/> <strong><font color=blue>Figure 13.28 – The marquee selection removes the items from the selection.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>c.</strong>	Now, select the two light meshes in the center of each room, but do not select the light actors themselves, and press Delete again to remove them.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_029.jpg"/><br/> <strong><font color=blue>Figure 13.29 – The light meshes are removed.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>d.</strong>	Finally, select the blue Additive brush that surrounds the entire map and press Delete to remove it.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_030.jpg"/><br/> <strong><font color=blue>Figure 13.30 – The brush is removed.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>e.</strong>	Finally, press the Build All button in the main toolbar to update the BSP and lighting.
</div>
<p />
<strong>7.</strong>	Select the MU_Minimap actor and then right-click on the Sheet Brush builder button in the Toolbox to open the Sheet Brush options. Set the X and Y values to 3200 (the SphereRadius multiplied by 2) and click Build. The red builder brush should update in the viewports.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_031.jpg"/><br/> <strong><font color=blue>Figure 13.31 – The builder brush is centered on the MU_Minimap actor.</font></strong>
<p />
<strong>8.</strong>	Select the red builder brush and move it down below the geometry present in the level. Find and select the M_Black material located in the CompassContent package in the Generic Browsr and then click the CSG: Add button in the Toolbox to create an additive sheet using the red builder brush with the M_Black material applied.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_032.jpg"/><br/> <strong><font color=blue>Figure 13.32 – The sheet brush has been added.</font></strong>
<p />
<strong>9.</strong>	Maximize the Top viewport and press the Lit button in its toolbar to display a lit view of the map. Next, press the G key to toggle on game mode. You should basically now see what will become the map texture used for the minimap.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_033.jpg"/><br/> <strong><font color=blue>Figure 13.33 – The Top viewport showing the lit view.</font></strong>
<p />
<strong>10.</strong>	Getting from this point to the finished map texture is fairly easy.
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Zoom out until the black sheet just barely fits within the viewport and press the Print Screen key.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_034.jpg"/><br/> <strong><font color=blue>Figure 13.34 – The sheet brush fills the viewport.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>b.</strong>	Now, open an image editing program and create a new image. We will be using Photoshop for this example.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_035.jpg"/><br/> <strong><font color=blue>Figure 13.35 – A new image is created.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>c.</strong>	Press Ctrl + V to paste the copied screen shot into the image.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_036.jpg"/><br/> <strong><font color=blue>Figure 13.36 – The captured screenshot is pasted into the image.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>d.</strong>	Select the black portion representing the map texture and crop the image to that area.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_037.jpg"/><br/> <strong><font color=blue>Figure 13.37 – The image is cropped to the black area.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>e.</strong>	Now scale the image or adjust its size so that it is 2048x2048.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_038.jpg"/><br/> <strong><font color=blue>Figure 13.38 – The image is scaled.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>f.</strong>	Save the file in a format Unreal can import. A 24-bit Targa (.tga) file usually works best.
</div>
<p />
<strong>11.</strong>	You may save the map in UnrealEd if you wish to save it as you may need it later to grab another screen shot. Just make sure you save it with a different name so you don’t overwrite the real map.
<p />
<h2><a name="TUTORIAL 13.14 – THE MINIMAP, PART X: MINIMAP MATERIAL AND FINISHING TOUCHES"></a> TUTORIAL 13.14 – THE MINIMAP, PART X: MINIMAP MATERIAL AND FINISHING TOUCHES </h2>
<p />
With the image for the minimap created, it is now time to import it into UnrealEd and create the MaterialInstanceConstants for the minimap and CompassOverlay. These must also be assigned to the corresponding properties of the MU_Minimap actor within the level.
<p />
<strong>1.</strong>	Open UnrealEd and the map from the previous tutorial with the MU_Minimap actor added, not the map used for the screenshot.
<p />
<strong>2.</strong>	Open the Generic Browser and select Import from the File menu. Select the map image you saved in the previous tutorial and click Open.
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	 In the dialog that appears, select the COM-CH_13_Minimap package in the dropdown list of packages and name enter a new name if you like, or leave it at the default of the name of the file.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_039.jpg"/><br/> <strong><font color=blue>Figure 13.39 – The level’s package is selected.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>b.</strong>	In the Options list, set the LODGroup to TEXTUREGROUP_UI. This is important because Unreal Tournament 3 uses these groups to limit the sizes of textures. The UI group will allow the texture to be displayed at its full 2048x2048 size so no quality is lost beyond the usual compression artifacts.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_040.jpg"/><br/> <strong><font color=blue>Figure 13.40 – The TEXTUREGROUP_UI LODGRoup is selected.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>c.</strong>	If you want to speed up the import process, you can also check the DeferCompression option as well. This will keep the compression from being performed until you save the package, or in this case the map. Of course this will slow down the saving process so it is a wash in the end.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_041.jpg"/><br/> <strong><font color=blue>Figure 13.41 – The DeferCompression option is selected.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>d.</strong>	Click OK to import the texture.
</div>
<p />
Note: The package you choose should be the name of the level you are using. If you named it something different, choose that from the package list instead.
<p />
<strong>3.</strong>	Right-click on the newly imported Texture in the Generic Browser, or double-click it, to open its properties. Scroll down to the SRGB property and uncheck it. This turns off gamma correction. If this option is not turned off, the texture will appear very, very dark when displayed on the screen.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_042.jpg"/><br/> <strong><font color=blue>Figure 13.42 – The SRGB flag is toggled off.</font></strong>
<p />
<strong>4.</strong>	Now, find the M_minimap material in the CompassContent package. Right-click on it and choose New Material Instance Constant.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_043.jpg"/><br/> <strong><font color=blue>Figure 13.43 – A new MaterialInstanceConstant is created from the M_minimap material.</font></strong>
<p />
<strong>a.</strong>	In the dialog that appears, select the COM-CH_13_Minimap package in the dropdown list of packages and enter a new name if you like, or leave it at the default of M_minimap_INST. Click OK.
<p />
Note: The package you choose should be the name of the level you are using. If you named it something different, choose that from the package list instead.
<p />
<strong>5.</strong>	When the Material Instance Editor appears for the new MaterialInstanceConstant, expand the ScalarParameterValues section and click the checkboxes next to both the parameters listed. Then expand the TextureParameterValues section and click the checkboxes next to each of those parameters as well. Finally, expand the VectorParameterValues section and click the checkbox next the parameter found there.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_044.jpg"/><br/> <strong><font color=blue>Figure 13.44 – The MaterialInstance Editor.</font></strong>
<p />
<strong>6.</strong>	Select the map texture you imported and then press the Use Current Selection In Browser button of the MinimapTex parameter in the TextureParameterValues section to assign the map texture to the material.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_045.jpg"/><br/> <strong><font color=blue>Figure 13.45 – The map texture replaces the default.</font></strong>
<p />
<strong>7.</strong>	Back in the CompassContent package, right-click on the M_compass material and choose New Material Instance Constant.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_046.jpg"/><br/> <strong><font color=blue>Figure 13.46 – A new MaterialInstanceConstant is created from the M_compass material.</font></strong>
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	In the dialog that appears, select the COM-CH_13_Minimap package in the dropdown list of packages and enter a new name if you like, or leave it at the default of M_compass_INST. Click OK.
</div>
<p />
Note: The package you choose should be the name of the level you are using. If you named it something different, choose that from the package list instead.
<p />
<strong>8.</strong>	When the Material Instance Editor appears for the new MaterialInstanceConstant, expand the ScalarParameterValues section and click the checkboxes next to both the parameters listed. Then expand the TextureParameterValues section and click the checkboxes next to each of those parameters as well.
<p />
<strong>9.</strong>	Select the MU_Minimap actor in the level and open its properties by pressing F4. Select the minimap MaterialInstanceConstant you just created and then click the Use Current Selection In Browser button for the Minimap property. Then select the compass overlay MaterialInstanceConstant and click the Use Current Selection In Browser button for the CompassOverlay property.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_047.jpg"/><br/> <strong><font color=blue>Figure 13.47 – The MaterialInstanceConstants have been assigned to the MU_Minimap actor.</font></strong>
<p />
<strong>10.</strong>	Save this map with any name you wish as long as it begins with “COM-“ and then either publish it by clicking the Publish Map buttonin the main toolbar or since this is just a quick test, save a copy of it to the Published\CookedPC\CustomMaps folder. Don’t forget to copy the CompassContent.upk to the Published\CookedPC directory as well.
<p />
<h2><a name="TUTORIAL 13.15 – THE MINIMAP, PART XI: TESTING THE MINIMAP"></a> TUTORIAL 13.15 – THE MINIMAP, PART XI: TESTING THE MINIMAP </h2>
<p />
All of the code is in place and we now have a map set up to take advantage of the new minimap system. It’s time to test the minimap system in action.
<p />
<strong>1.</strong>	Load up UT3 and login or choose to play offline.
<p />
<strong>2.</strong>	Select an Instant Action game.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_048.jpg"/><br/> <strong><font color=blue>Figure 13.48 – Instant Action is selected.</font></strong>
<p />
<strong>3.</strong>	Choose the MinimapGame gametype from the next menu.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_049.jpg"/><br/> <strong><font color=blue>Figure 13.49 – The MinimapGame is selected.</font></strong>
<p />
<strong>4.</strong>	You should now see the map you saved in the previous tutorial as the only map in the list. Double-click on this map.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_050.jpg"/><br/> <strong><font color=blue>Figure 13.50 – The map is chosen.</font></strong>
<p />
<strong>5.</strong>	Set the number of bots to 2 or less on the next menu as there are only enough PlayerStarts in this small level for 2 bots to spawn besides the player.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_051.jpg"/><br/> <strong><font color=blue>Figure 13.51 – Bots are set up.</font></strong>
<p />
<strong>6.</strong>	Start the game. As soon as the level loads, you should see the map displayed in the upper left corner of the screen, though turning or moving will have no effect on it until the match begins.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_052.jpg"/><br/> <strong><font color=blue>Figure 13.52 – The map appears on the screen.</font></strong>
<p />
<strong>7.</strong>	Begin the match and you should now see the map reflect the actual location of the player within the map. Moving and turning should now cause the map to update. You should also see the bots displayed as green boxes when you are near enough for them to be displayed.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_053.jpg"/><br/> <strong><font color=blue>Figure 13.53 – The map reflects the player’s rotation and location.</font></strong>
<p />
The minimap system should be working just as we expected. Obviously, the effect would be much more useful and interesting in a larger, outdoor environment. This small indoor map was simply a quick means of testing it out.
<p />
<h2><a name="TUTORIAL 13.16 – THE CAPTURE VOLUME, PART I: INITIAL SETUP"></a> TUTORIAL 13.16 – THE CAPTURE VOLUME, PART I: INITIAL SETUP </h2>
<p />
Our mapper is back, and he has a new request. His map is in need of a new volume that he can connect to some cool effects. Up to this point, he has been working entirely in Kismet, and has created some very complicated sequences to achieve a couple very simple tasks. It has fallen on our shoulders to create this new volume and to implement the necessary Kismet definitions to replace his entire Kismet sequence.
<p />
After a meeting with him we have drafted the following list of specifications:
<p /> <ul>
<li> It must be a placeable brush volume
</li> <li> It should be Light Green in color, to set it apart from other brushes by default
</li> <li> It will have three output events in kismet <ul>
<li> Red Captured – When the red team accomplishes the capture
</li> <li> Blue Captured – When the blue team accomplishes the capture
</li> <li> Unstable – When contested or having its captured status change
</li></ul>
</li> <li> It will have a few configurable elements <ul>
<li> Time to Capture – an integer set in the editor for each volume (default 3)
</li> <li> Minimum number of players to be able to Capture  (default 1)
</li> <li> Rewarded Points – Rewarded to the capturers (default 1)
</li></ul>
</li> <li> It should have a timer, set to every half second, checking to see if the capture is beginning
</li> <li> It should be toggleable
</li></ul>
<p />
Even if we stay at the fifty thousand foot view of this it is a complicated problem to solve. We will approach this problem in parts, breaking this apart into the major bullet points, as that seems to be the most straightforward.
<p />
We’ll begin by defining the Interface to be used by the volume.
<p />
<strong>1.</strong>	Open ConTEXT and create a new file named ICaptureVolume.uc using the UnrealScript highlighter.
<p />
<strong>2.</strong>	Define the Interface for our new CaptureVolume.
<p />
<font face=consolas>
<pre>
interface ICaptureVolume;
</pre>
</font>
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Declare the OnToggle() function, which will tie into the enabled state of the volume
<p />
<font face=consolas>
<pre>
function OnToggle(SeqAct&#95;Toggle action);
</pre>
</font>
<p />
<strong>b.</strong>	Declare the CheckBeginCapture() function, which will be used to test the occupants of our volume and returning whether the volume has begun being captured.
<p />
<font face=consolas>
<pre>
function bool CheckBeginCapture();
</pre>
</font>
<p />
<strong>c.</strong>	The GetTouchingUTPawns() function is being used for its utility. It accumulates all touching pawns and tosses them into the red or blue bowls, which are then returned. Since we can only return a single value the out variables are used. The function will return the overall count of characters within the volume.
<p />
<font face=consolas>
<pre>
function int GetTouchingUTPawns(out array&#60;UTPawn&#62; redTouching, out array&#60;UTPawn&#62; blueTouching);
</pre>
</font>
<p />
<strong>d.</strong>	tCheckCapture() is the function hooked into our timer, and will be doing many calculations behind the scenes.
<p />
<font face=consolas>
<pre>
function tCheckCapture();
</pre>
</font>
<p />
<strong>e.</strong>	The UpdateEvents() function is driving the output kismet interface, accepting the flag for which event is being triggered.
<p />
<font face=consolas>
<pre>
function UpdateEvents(int flag);
</pre>
</font>
</div>
<p />
<strong>3.</strong>	Save this script to preserve your work.
<p />
<strong>4.</strong>	With our interface clearly defined, it is time to lay down some pipe work for the CaptureVolume itself. All volumes derive from the Volume class, and since there are not any necessary things to derive from in the other derived classes, we should follow suit. There isn’t a whole lot to this one, so we should just take the step of writing this volume’s code.
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Create a new file named CaptureVolume.uc using the UnrealScript highlighter.
<p />
<strong>b.</strong>	Defining our class, implementing the ICaptureVolume Interface
<p />
<font face=consolas>
<pre>
class CaptureVolume extends Volume placeable implements(ICaptureVolume) Config(UTBook);
</pre>
</font>
<p />
<strong>c.</strong>	We will now take a pitstop in the default properties. There is only one element here of note, and that is the BrushColor. It accepts the same integer values as we experienced in the compass tutorial.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   // For UnrealEd And to avoid removal
   BrushColor &#61; (B&#61;128, G&#61;255, R&#61;128, A&#61;255)
   bColored &#61; True
   bStatic &#61; false
}
</pre>
</font>
<p />
<strong>d.</strong>	We can compile at this point and actually see our new volume in the editor, if we follow the steps previously described. This volume will work just as the other volumes, and sow up in the volumes quick-listing, only this one will be a light green.
</div>
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_054.jpg"/><br/> <strong><font color=blue>Figure 13.54 -  Our New CaptureVolume in the UnrealEditor</font></strong>
<p />
<strong>5.</strong>	This is the point when things start getting tough. We are going to create a number of variables for our mappers to be able to configure the various elements of this volume. This is also the point when we can create a couple enumerations to help the readability of our code. Below you will find a block of code that contains inline commentary about the purpose of the variables. The default properties are updated and appended to the end.
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	ECaptureEvent is an enumeration of the three triggered status. This is mainly done for readability concerns, serving as a replacement for magic constants floating in our code.
<p />
<font face=consolas>
<pre>
enum ECaptureEvent
{
   CAP&#95;REDCONT,
   CAP&#95;BLUECONT,
   CAP&#95;UNSTABLE
};
</pre>
</font>
<p />
<strong>b.</strong>	ETeams is straight forward, and serves a similar purpose to the previous enumeration.
<p />
<font face=consolas>
<pre>
enum ETeams
{
   RED&#95;TEAM,
   BLUE&#95;TEAM,
   NO&#95;TEAM
};
</pre>
</font>
<p />
<strong>c.</strong>	Now we get into the meat of the class. iTimeToCapture is an integer variable that controls the number of seconds required to capture the volume. Each of the next three variables are available to the mapper, under the Capture subcategory, controlled by the (Capture) statement.
<p />
<font face=consolas>
<pre>
var (Capture) int iTimeToCapture;
</pre>
</font>
<p />
<strong>d.</strong>	iPointReward is the reward granted to the capturing group, on an individual basis. If the mapper chooses he doesn’t want a value here, she can change it to 0.
<p />
<font face=consolas>
<pre>
var (Capture) int iPointReward;
</pre>
</font>
<p />
<strong>e.</strong>	This variable is actually important. The volume will only be triggered if this number of players are present within the volume.
<p />
<font face=consolas>
<pre>
var (Capture) int iMinimumPlayersForCapture;
</pre>
</font>
<p />
<strong>f.</strong>	These two variables are used to keep track of the state of the volume, i.e. who is in control of it and who is trying to take control, respectively.
<p />
<font face=consolas>
<pre>
var int CapturingTeamID;
var int CapturedTeamID;
</pre>
</font>
<p />
<strong>g.</strong>	TimeCapturing keeps track of the Interval of time spent capturing this volume.
<p />
<font face=consolas>
<pre>
var float TimeCapturing;
</pre>
</font>
<p />
<strong>h.</strong>	In order to keep track of who is taking part in capturing this volume, CapturingMembers is used.
<p />
<font face=consolas>
<pre>
var array&#60;UTPawn&#62; CapturingMembers;
</pre>
</font>
<p />
<strong>i.</strong>	This is used by the toggle routine to make sure that our volume is able to be turned off or on as our mapper sees fit.
<p />
<font face=consolas>
<pre>
var bool bEnabled;
</pre>
</font>
</div>
<p />
<strong>6.</strong>	We should now update the default properties to reflect the new variables default variables. The default properties block stands on its own now, but I will point out the use of a constant from our enumeration beign assigned to CapturedTeamID, setting the default value to a clearly defined value. The other values have been handed down by our mapper.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   // For UEd setup mainly.
   BrushColor &#61; (B&#61;128, G&#61;255, R&#61;128, A&#61;255)
   bColored &#61; True
   bStatic &#61; false

   // Default values for the volume
   iMinimumPlayersForCapture &#61; 1
   CapturedTeamID &#61; NO&#95;TEAM
   iTimeToCapture &#61; 3
   iPointReward &#61; 5
}
</pre>
</font>
<p />
<strong>7.</strong>	Save the script to preserve your progress.
<p />
<h2><a name="TUTORIAL 13.17 – THE CAPTURE VOLUME, PART II: TOUCH AND TIME"></a> TUTORIAL 13.17 – THE CAPTURE VOLUME, PART II: TOUCH AND TIME </h2>
<p />
We have our volume in the editor, now we should step into some of the more interesting aspects  of the volume. There is one, in particular, that will prove to be much easier if we address it off the bat; when we the volume is being touched. This can be a very complicated matter, but luckily, we have been granted an event function, Touch.
<p />
This Touch Event will trigger a timer that will confirm our captured state changes. Timers are very useful for keeping track of things that do not need to be checked every tick, but need to be checked at a time interval nonetheless. You simply pass them a float value, whether it is recursive, and the callback function that we are trying to have executed at this interval. Our specification has already described this timer, so let’s get that taken care of as well.
<p />
<strong>1.</strong>	Open ConTEXT and the CaptureVolume.uc script.
<p />
<strong>2.</strong>	First we have to define our Touch event.
<p />
<font face=consolas>
<pre>
event Touch(Actor Other, PrimitiveComponent OtherComp, vector HitLocation, vector HitNormal )
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Within most derived functions it is in our interest to call the super version of it, to avoid breaking dependency or expected value assignments.
<p />
<font face=consolas>
<pre>
Super.Touch(Other, OtherComp, HitLocation, Hitnormal);
</pre>
</font>
<p />
<strong>4.</strong>	When our volume is enabled we will want to execute our timer, which is tied to a function. We have the interval set to 0.5 seconds here, and we also pass true as the second parameter to allow the timer to run every 0.5 seconds until we stop it.
<p />
<font face=consolas>
<pre>
if (bEnabled) // If we are enabled... go crazy.
   SetTimer(0.5f, true, &#39;tCheckCapture&#39;);
</pre>
</font>
<p />
<strong>5.</strong>	Moving on from the Touch event, we have to deal with the touching issue. Our utility function is going to prove itself to be invaluable, so let’s get this taken care of now. Defining the function and its arguments.
<p />
<font face=consolas>
<pre>
function int GetTouchingUTPawns(out array&#60;UTPawn&#62; redTouching, out array&#60;UTPawn&#62; blueTouching)
{
}
</pre>
</font>
<p />
<strong>6.</strong>	The Count variable will be the inclusive, that is – both teams, number of UTPawn’s within the volume. It will be returned at the end. P is used for iterating, in just a moment.
<p />
<font face=consolas>
<pre>
local int Count;
local UTPawn P;

Count &#61; 0;
</pre>
</font>
<p />
<strong>7.</strong>	Iterating through the necessary pawns is not as terrible as it may sound. UnrealScript has a number of very useful iterators, but make sure you don’t use them without purpose and thought. They can be very costly, especially within tick functions.
<p />
<font face=consolas>
<pre>
foreach self.TouchingActors(class&#39;UTPawn&#39;, P)
{
}
</pre>
</font>
<p />
<strong>8.</strong>	We want to make sure the Pawn is alive, and if not move on to the next one.
<p />
<font face=consolas>
<pre>
if (P &#61;&#61; None &#124;&#124; P.health &#60;&#61; 0 &#124;&#124; P.Controller.IsDead() &#124;&#124; P.GetTeam() &#61;&#61; None)
{
   continue;
}
</pre>
</font>
<p />
<strong>9.</strong>	Granting that they have lived, we need to add them to the appropriate team.
<p />
<font face=consolas>
<pre>
if (P.GetTeam().TeamIndex &#61;&#61; RED&#95;TEAM)
{
   redTouching.AddItem(P);
   Count++;
}
else
{
   blueTouching.AddItem(P);
   Count++;
}
</pre>
</font>
<p />
<strong>10.</strong>	Finally returning the Count.
<p />
<font face=consolas>
<pre>
return Count;
</pre>
</font>
<p />
<strong>11.</strong>	Save the script to preserve your progress.
<p />
<h2><a name="TUTORIAL 13.18 – THE CAPTURE VOLUME, PART III: THE CAPTURED STATE"></a> TUTORIAL 13.18 – THE CAPTURE VOLUME, PART III: THE CAPTURED STATE </h2>
<p />
We now have a good portion of the volume mapped out, and the vision is coming together. Our volume has a few interesting functions that serve a utility purpose,  or another, bu there are still a couple further hurdles to step over. Next we will be stepping into the CheckBeginCapture routine, which is going to return the Boolean truth of this situation.
<p />
<strong>1.</strong>	Open ConTEXT and the CaptureVolume.uc script.
<p />
<strong>2.</strong>	As usual, we need to define our function, as per our interface.
<p />
<font face=consolas>
<pre>
simulated function bool CheckBeginCapture()
{
}
</pre>
</font>
<p />
<strong>3.</strong>	We need a pair of arrays, to hold onto the red and blue pawns, the calculations will be driven by them.
<p />
<font face=consolas>
<pre>
local array&#60;UTPawn&#62; redTouching;
local array&#60;UTPawn&#62; blueTouching;
</pre>
</font>
<p />
<strong>4.</strong>	Create a counter that is used to keep track of the size of the capturing team, simplifying the final test.
<p />
<font face=consolas>
<pre>
local int Count;
</pre>
</font>
<p />
<strong>5.</strong>	We can use the GetTouchingUTPawns utility function to fill our arrays off the bat.
<p />
<font face=consolas>
<pre>
GetTouchingUTPawns(redTouching, blueTouching);
</pre>
</font>
<p />
<strong>6.</strong>	Check the size, if there are no players in this volume, clear the timer and return.
<p />
<font face=consolas>
<pre>
if (blueTouching.length &#61;&#61; 0 &#38;&#38; redTouching.length &#61;&#61; 0)
{
   ClearTimer(&#39;tCheckCapture&#39;, self);
          return false;
}
</pre>
</font>
<p />
<strong>7.</strong>	If there is more than one team present we need to send the CAP_UNSTABLE trigger, and return.
<p />
<font face=consolas>
<pre>
else if (!(blueTouching.length &#61;&#61; 0 ^^ redTouching.length &#61;&#61; 0))
{
   UpdateEvents(CAP&#95;UNSTABLE);
   return false;
}
</pre>
</font>
<p />
<strong>8.</strong>	With those two tests out of the way we can rest assured that we only have red or blue, but not both, teams present. Focusing on red first…
<p />
<font face=consolas>
<pre>
if (redTouching.length &#62; 0)
{
}
</pre>
</font>
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	Copy the players touching the volume into an array we will use later to do the payout of points.
<p />
<font face=consolas>
<pre>
CapturingMembers &#61; redTouching;
</pre>
</font>
<p />
<strong>b.</strong>	Get the count of the players here.
<p />
<font face=consolas>
<pre>
Count &#61; redTouching.length;
</pre>
</font>
<p />
<strong>c.</strong>	Set the CapturingTeamID to the red team
<p />
<font face=consolas>
<pre>
CapturingTeamID &#61; RED&#95;TEAM;
</pre>
</font>
</div>
<p />
<strong>9.</strong>	And now mirror what we just did for the blue team.
<p />
<font face=consolas>
<pre>
else
{
   CapturingMembers &#61; blueTouching;
   Count &#61; blueTouching.length;
   CapturingTeamID &#61; BLUE&#95;TEAM;
}
</pre>
</font>
<p />
<strong>10.</strong>	Test the count to make sure that this volume is able to be captured now, and make sure that the capturing team is not the captured team. This second test is to ensure that the volume doesn’t get captured by the same team, bloating scores.
<p />
<font face=consolas>
<pre>
if ((iMinimumPlayersForCapture &#60;&#61; Count) &#38;&#38; (CapturingTeamID !&#61; CapturedTeamID))
    return true;
else
   return false;
</pre>
</font>
<p />
<strong>11.</strong>	Save the script too preserve your work.
<p />
We now have a good majority of our class laid out. There are only a few functions left to address, so it will not be too much longer for us to be completed and see some really cool events in game.
<p />
<h2><a name="TUTORIAL 13.19 – THE CAPTURE VOLUME, PART IV: THE TIMER FUNCTION"></a> TUTORIAL 13.19 – THE CAPTURE VOLUME, PART IV: THE TIMER FUNCTION </h2>
<p />
The next step is going to be the timer function. This function is executed every 0.5 seconds, so it is good to keep that in mind, as real time game development can be very unfriendly to inefficient functions.
<p />
<strong>1.</strong>	Define our tCheckCapture function.
<p />
<font face=consolas>
<pre>
simulated function tCheckCapture()
{
}
</pre>
</font>
<p />
<strong>2.</strong>	We  need to create a couple variables to help with the iteration we will be doing later.
<p />
<font face=consolas>
<pre>
local UTPawn P;
local UTPlayerReplicationInfo ScorerPRI;
</pre>
</font>
<p />
<strong>3.</strong>	If the TimeCapturing is negative, clear its value.
<p />
<font face=consolas>
<pre>
if (TimeCapturing &#60; 0)
   TimeCapturing &#61; 0;
</pre>
</font>
<p />
<strong>4.</strong>	Now we call our CheckBeginCapture function, to see whether we need to be triggering anything. If not we need to clear quite a few things. Note that we will need to clear the timer when done.
<p />
<font face=consolas>
<pre>
if (!CheckBeginCapture())
{
   CapturingTeamID &#61; NO&#95;TEAM;
      TimeCapturing &#61; 0;
   ClearTimer(&#39;tCheckCapture&#39;, self);
   return;
}
</pre>
</font>
<p />
<strong>5.</strong>	If we are supposed to begin capturing we should update the time spent capturing now, which is not entirely intuitive, but thanks to Epic there is a function that will help us.
<p />
<font face=consolas>
<pre>
TimeCapturing +&#61; GetTimerRate(&#39;tCheckCapture&#39;, self);
</pre>
</font>
<p />
<strong>6.</strong>	With this new time value we can check against the configurable value for this volume. If it is greater or equal we need to go ahead with the capture.
<p />
<font face=consolas>
<pre>
if (TimeCapturing &#62;&#61; iTimeToCapture)
{
}
</pre>
</font>
<p />
<div style="padding-left:20px;">
<strong>a.</strong>	If the capturing team is Blue, send out the blue capture event, and vice versa for red.
<p />
<font face=consolas>
<pre>
UpdateEvents(CapturingTeamID &#61;&#61; BLUE&#95;TEAM ? CAP&#95;BLUECONT : CAP&#95;REDCONT);
</pre>
</font>
<p />
<strong>b.</strong>	Increment the scores for the capturing players. This is where we are using the two variables defined earlier.
<p />
<font face=consolas>
<pre>
foreach CapturingMembers(P)
{
   ScorerPRI &#61; UTPlayerReplicationInfo(P.Controller.PlayerReplicationInfo);
   ScorerPRI.Score +&#61; (iPointReward);
   ScorerPRI.bForceNetUpdate &#61; TRUE;
}
</pre>
</font>
<p />
<strong>c.</strong>	Update the Captured Team ID.
<p />
<font face=consolas>
<pre>
CapturedTeamID &#61; CapturingTeamID;
</pre>
</font>
<p />
<strong>d.</strong>	And finally, clear out the Capturing team ID as well as the time capturing counter, followed by clearing the timer. This is important to do so we don’t end up recalling this function.
<p />
<font face=consolas>
<pre>
CapturingTeamID &#61; NO&#95;TEAM;
TimeCapturing &#61; 0;
ClearTimer(&#39;tCheckCapture&#39;, self);
</pre>
</font>
</div>
<p />
<strong>7.</strong>	Save the script.
<p />
<h2><a name="TUTORIAL 13.20 – THE CAPTURE VOLUME, PART V: UPDATING THE EVENTS"></a> TUTORIAL 13.20 – THE CAPTURE VOLUME, PART V: UPDATING THE EVENTS </h2>
<p />
When we want to trigger the sequence events it is necessary to loop through all of the sequence events of our volume and send out the appropriate flag. This function handles this, including the looping.
<p />
<strong>1.</strong>	Open ConTEXT and the CaptureVolume.uc script.
<p />
<strong>2.</strong>	Define the function and declare a couple variables for ease of use, and iteration.
<p />
<font face=consolas>
<pre>
function UpdateEvents(int flag)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	Declare a local Int variable to be used in a For loop and a SeqEvent_VolumeCaptured object reference for use with an iterator.
<p />
<font face=consolas>
<pre>
local int i;
local SeqEvent&#95;VolumeCaptured CaptureEvent;
</pre>
</font>
<p />
<strong>4.</strong>	Begin a loop, over all GeneratedEvents.  This is an array that comes into play when working within kismet, and other event sequences.
<p />
<font face=consolas>
<pre>
for (i &#61; 0; i &#60; GeneratedEvents.Length; i++)
{
}
</pre>
</font>
<p />
<strong>5.</strong>	Inside the loop, cast the generated event into a VolumeCaptured sequence event and if the cast works send it the appropriate flag. This function, Notify_VolumeCaptured, will lead to our use of an interface.
<p />
<font face=consolas>
<pre>
CaptureEvent &#61; SeqEvent&#95;VolumeCaptured(GeneratedEvents&#91;i]);
if (CaptureEvent !&#61; None)
{
   CaptureEvent.Notify&#95;VolumeCaptured(flag);
}
</pre>
</font>
<p />
<strong>6.</strong>	Save the script.
<p />
<h2><a name="TUTORIAL 13.21 – THE CAPTURE VOLUME, PART VI:  TOGGLING THE VOLUME OFF  UPDATING OUR DEFAULTPROPERTIES BLOCK"></a> TUTORIAL 13.21 – THE CAPTURE VOLUME, PART VI:  TOGGLING THE VOLUME OFF &amp; UPDATING OUR DEFAULTPROPERTIES BLOCK </h2>
<p />
We only have a single function left for this class, and that is the toggle function.
<p />
<strong>1.</strong>	Open ConTEXT and the CaptureVolume.uc script.
<p />
<strong>2.</strong>	OnToggle is called when attached to a toggle event. This works just as the Lights and other actors do.
<p />
<font face=consolas>
<pre>
simulated function OnToggle(SeqAct&#95;Toggle action)
{
}
</pre>
</font>
<p />
<strong>3.</strong>	It accepts a Sequence Action and checks the impulses for them. The indexes are 0, 1 and 2, which are connected to On, Off and Toggle, respectively.
<p />
<font face=consolas>
<pre>
if (action.InputLinks&#91;0].bHasImpulse)
   bEnabled &#61; TRUE;
else if (action.InputLinks&#91;1].bHasImpulse)
   bEnabled &#61; FALSE;
else if (action.InputLinks&#91;2].bHasImpulse)
   bEnabled &#61; !bEnabled;
</pre>
</font>
<p />
<strong>4.</strong>	Then we force the network update
<p />
<font face=consolas>
<pre>
ForceNetRelevant();
</pre>
</font>
<p />
<strong>5.</strong>	Our default properties block needs to be updated now, to include the Capture sequence Event that we are going to be implementing in just a moment.
<p />
<font face=consolas>
<pre>
defaultproperties
{
   // For UEd setup mainly.
   BrushColor &#61; (B&#61;128, G&#61;255, R&#61;128, A&#61;255)
   bColored &#61; True
   bStatic &#61; false

   // Default values for the volume
   iMinimumPlayersForCapture &#61; 1
   CapturedTeamID &#61; NO&#95;TEAM
   iTimeToCapture &#61; 3
   iPointReward &#61; 5

   // Attach our output events
   SupportedEvents(0)&#61;Class&#39;UTBook.SeqEvent&#95;VolumeCaptured&#39;
}
</pre>
</font>
<p />
<strong>6.</strong>	Save the script.
<p />
<h2><a name="TUTORIAL 13.22 – THE CAPTURE VOLUME, PART VII: THE SEQUENCE EVENT’S INTERFACE AND IMPLEMENTATION"></a> TUTORIAL 13.22 – THE CAPTURE VOLUME, PART VII: THE SEQUENCE EVENT’S INTERFACE AND IMPLEMENTATION </h2>
<p />
We have completed the Volume and need to write the code for the Captured Volume Sequence Event. These can be a bit irritating, try not to let them get to you too much. This one is simple enough, so lets get started.
<p />
<strong>1.</strong>	Open ConTEXT and create a new file named ICaptureSequenceEvent.uc using the UnrealScript highlighter.
<p />
<strong>2.</strong>	The interface for our sequence event needs only to declare a single function. Let’s do that.
<p />
<font face=consolas>
<pre>
interface ICaptureSequenceEvent;

function Notify&#95;VolumeCaptured(int outputIndex);
</pre>
</font>
<p />
<strong>3.</strong>	Save the script.
<p />
<strong>4.</strong>	Implementing the function is going to be following the same pipework that was laid previously. Create a new file named SeqEvent_VolumeCaptured.uc using the UnrealScript highlighter.
<p />
<strong>5.</strong>	Define the class, extending SequenceEvent and implementing the interface we just declared.
<p />
<font face=consolas>
<pre>
class SeqEvent&#95;VolumeCaptured extends SequenceEvent DependsOn(CaptureVolume) implements(ICaptureSequenceEvent);
</pre>
</font>
<p />
<strong>6.</strong>	Define our function, Notify_VolumeCaptured().
<p />
<font face=consolas>
<pre>
function Notify&#95;VolumeCaptured(int outputIndex)
{
}
</pre>
</font>
<p />
<strong>7.</strong>	Declare a local dynamic array of Ints and create a log statement to output the value of the parameter sent to the function.
<p />
<font face=consolas>
<pre>
local array&#60;int&#62; ActivateIndices;
`log(&#34;Notify&#95;VolumeCaptured has been executed&#34; &#64; outputIndex,,&#39;UTBook&#39;);
</pre>
</font>
<p />
<strong>8.</strong>	We only send a single trigger at a time, since there is only one to worry about.
<p />
<font face=consolas>
<pre>
ActivateIndices&#91;0] &#61; outputIndex;
if (CheckActivate(Originator, None, false, ActivateIndices))
{
   `log(&#34;Notify&#95;VolumeCaptured has been activated&#34;,,&#39;UTBook&#39;);
}
</pre>
</font>
<p />
<strong>9.</strong>	Stepping into the default properties block, we have a few links to take into account and connect where necessary.
<p />
<font face=consolas>
<pre>
defaultproperties
{
}
</pre>
</font>
<p />
<strong>10.</strong>	These Links are important, their index are the actual values being sent around
<p />
<font face=consolas>
<pre>
OutputLinks(0) &#61; (LinkDesc&#61;&#34;Red Capture&#34;)
OutputLinks(1) &#61; (LinkDesc&#61;&#34;Blue Capture&#34;)
OutputLinks(2) &#61; (LinkDesc&#61;&#34;Unstable&#34;)
</pre>
</font>
<p />
<strong>11.</strong>	And now a couple tweaks to the kismet element, assigning its name, category and max trigger count defaults.
<p />
<font face=consolas>
<pre>
ObjName &#61; &#34;Volume Captured&#34;
ObjCategory &#61; &#34;Objective&#34;
MaxTriggerCount &#61; 0 // Default to being triggered infinite times.
</pre>
</font>
<p />
<strong>12.</strong>	Finally, we want to make sure the player does not trigger this event, exclusively.
<p />
<font face=consolas>
<pre>
bPlayerOnly &#61; False
</pre>
</font>
<p />
<strong>13.</strong>	Save the script.
<p />
<h2><a name="TUTORIAL 13.23 – PLACING A CAPTUREVOLUME AND SEEING IT IN ACTION"></a> TUTORIAL 13.23 – PLACING A CAPTUREVOLUME AND SEEING IT IN ACTION </h2>
<p />
With that, we have completed the volume and its sequence event, so you have a clear example of how to create either for your own mod. This tutorial illustrates iterators quite well, showing how they work like a for each loop does in other languages.
<p />
<strong>1.</strong>	Once again we have to load up our Editor and compiled code package. Load up the editor and create a new map.
<p />
<strong>2.</strong>	Open up the Actor Classes browser.
<p />
<strong>3.</strong>	Navigate to File &gt; Open then navigate to your Scripts directory, where your compiled .u file resides.
<p />
<strong>4.</strong>	Once the package has loaded, the new volume should be seen, under Actor &gt; Brush &gt; Volume, as seen in Figure 14. Select it and go over to your map. You should now be able to right click and an “Add Compass Here” menu option provided to you.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_055.jpg"/><br/> <strong><font color=blue>Figure 13.55 - Actor Class Browser with our CaptureVolume</font></strong>
<p />
<strong>5.</strong>	Place one of the volumes in the middle of the map. We are going to be setting up a kismet sequence in just a moment. In Figure 15 we can see the options that we designated for the new volume, visible in the Capture subcategory.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_056.jpg"/><br/> <strong><font color=blue>Figure 13.56 - The new settings for our mapper</font></strong>
<p />
<strong>6.</strong>	The next step is to open up kismet and see our new sequence event. With one of the volume selected, open up the kismet editor and right click. In the context menu should be an option to create new event for your selected capture volume, and under that should be our sequence event – Volume Captured. The element that is drawn for us will look like this:
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_057.jpg"/><br/> <strong><font color=blue>Figure 13.57  - Kismet of our Volume</font></strong>
<p />
<strong>7.</strong>	You can go ahead and create a sequence here, so that we can see this element in action. Here is mine.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_058.jpg"/><br/> <strong><font color=blue>Figure 13.58 - The Kismet Demo, featuring a Custom Kismet Event</font></strong>
<p />
<strong>8.</strong>	Now that you have that completed, we can save the map out and start it up. We should see something like the following in your log file:
<p />
<font face=consolas>
<pre>
Log: Family Asset Package Loaded: CH&#95;Corrupt&#95;Arms&#95;SF
Log: CONSTRUCTIONING: LoadFamilyAsset (LIAM) Took: -0.01 secs
ScriptLog: Finished creating custom characters in 1.8737 seconds
Error: Can&#39;t start an online game that hasn&#39;t been created
ScriptLog: START MATCH
ScriptLog:   Num Matches Played: 0
UTBook: Notify&#95;VolumeCaptured has been activated
Log: Kismet: Red Capture
UTBook: Notify&#95;VolumeCaptured has been activated
UTBook: Notify&#95;VolumeCaptured has been activated
Log: Kismet: Blue Capture
UTBook: Notify&#95;VolumeCaptured has been activated
Log: Kismet: Red Capture
Error: Can&#39;t end an online game that hasn&#39;t been created
Log: Closing by request
Log: appRequestExit(0)
</pre>
</font>
<p />
<strong>9.</strong>	We can see here, the scoreboard is being updated with our volume being captured during the game.
<p />
<img src="rsrc/Three/MasteringUnrealScriptInterfaces/CH_013_FIGURE_059.jpg"/><br/> <strong><font color=blue>Figure 13.59 –  The scoreboard shown 40 seconds in on the left and 95 seconds in on the right.</font></strong>
<p />
And with that we have completed this tutorial. Lets step back through it quickly and highlight some of the important aspects.
<p /> <ul>
<li> Interfaces can be created for any Class we are going to develop
</li> <li> Volumes are not difficult to create, or configure to do our bidding
</li> <li> Kismet is actually created through Sequence Events, and they have a very simple interface
</li> <li> Iterators save us a lot of time and energy, but can be very costly depending on where you call them.
</li> <li> Planning something out helps ease the process of developing and can speed it up if approached correctly
</li></ul>
<p />
<h2><a name="INTERFACES WITHIN UT3"></a> INTERFACES WITHIN UT3 </h2>
<p />
The listing that follows includes all non test related interfaces within Unreal Tournament 3 that may be helpful. There are others, but they are either native or relating to native processes within the game which are beyond the scope of this book.
<p />
<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						IQueryHandler
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						struct KeyValuePair
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						struct WebAdminQuery
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function init(WebAdmin)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function cleanup()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool handleQuery(WebAdminQuery)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool unhandledQuery(WebAdminQuery)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function registerMenuItems(WebAdminMenu)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
<p />
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						ISession
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function string getId()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function reset()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function Object getObject(string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function putObject(string, Object)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function removeObject(string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function string getString(string, optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function putString(string, string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function removeString(string)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
<p />
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						ISessionHandler
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function ISession create()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ISession get(string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool destroy(ISession)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function destroyAll()
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
<p />
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						IWebAdminAuth
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function init(WorldInfo)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function cleanup()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function IWebAdminUser authenticate(string, string, out string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function bool logout(IWebAdminUser)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool validate(string, string, out string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool validateUser(IWebAdminUser, out string)
<p />
					</td>
<p />
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
<p />
						IWebAdminUser
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						struct MessageEntry
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function string getUsername()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool canPerform(string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function PlayerController getPC()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function messageHistory(out array<MessageEntry>, optional int)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
<p />
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						OnlineAccountInterface
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool CreateOnlineAccount(string,string,string,optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						delegate OnCreateOnlineAccountCompleted(EOnlineAccountCreateStatus)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddCreateOnlineAccountCompletedDelegate(delegate<OnCreateOnlineAccountCompleted>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearCreateOnlineAccountCompletedDelegate(delegate<OnCreateOnlineAccountCompleted>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool CreateLocalAccount(string,optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool RenameLocalAccount(string,string,optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function bool DeleteLocalAccount(string,optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool GetLocalAccountNames(out array<string>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool IsKeyValid()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool SaveKey(string)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
<p />
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						OnlineContentInterface
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnContentChange()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddContentChangeDelegate(delegate<OnContentChange>, optional byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearContentChangeDelegate(delegate<OnContentChange>, optional byte)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnReadContentComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddReadContentComplete(byte,delegate<OnReadContentComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function ClearReadContentComplete(byte,delegate<OnReadContentComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ReadContentList(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function EOnlineEnumerationReadState GetContentList(byte, out array<OnlineContent>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool QueryAvailableDownloads(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnQueryAvailableDownloadsComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function AddQueryAvailableDownloadsComplete(byte,delegate<OnQueryAvailableDownloadsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearQueryAvailableDownloadsComplete(byte,delegate<OnQueryAvailableDownloadsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function GetAvailableDownloadCounts(byte,out int,out int)
<p />
					</td>
<p />
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
<p />
						OnlineGameInterface
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool CreateOnlineGame(byte,OnlineGameSettings)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnCreateOnlineGameComplete(bool)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddCreateOnlineGameCompleteDelegate(delegate<OnCreateOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearCreateOnlineGameCompleteDelegate(delegate<OnCreateOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool UpdateOnlineGame(OnlineGameSettings)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function OnlineGameSettings GetGameSettings()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool DestroyOnlineGame()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnDestroyOnlineGameComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddDestroyOnlineGameCompleteDelegate(delegate<OnDestroyOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearDestroyOnlineGameCompleteDelegate(delegate<OnDestroyOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool FindOnlineGames(byte,OnlineGameSearch)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						delegate OnFindOnlineGamesComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddFindOnlineGamesCompleteDelegate(delegate<OnFindOnlineGamesComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearFindOnlineGamesCompleteDelegate(delegate<OnFindOnlineGamesComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool CancelFindOnlineGames()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnCancelFindOnlineGamesComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function AddCancelFindOnlineGamesCompleteDelegate(delegate<OnCancelFindOnlineGamesComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearCancelFindOnlineGamesCompleteDelegate(delegate<OnCancelFindOnlineGamesComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function OnlineGameSearch GetGameSearch()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool FreeSearchResults(optional OnlineGameSearch)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool JoinOnlineGame(byte,const out OnlineGameSearchResult)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						delegate OnJoinOnlineGameComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddJoinOnlineGameCompleteDelegate(delegate<OnJoinOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearJoinOnlineGameCompleteDelegate(delegate<OnJoinOnlineGameComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool GetResolvedConnectString(out string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool RegisterPlayer(UniqueNetId,bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						delegate OnRegisterPlayerComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddRegisterPlayerCompleteDelegate(delegate<OnRegisterPlayerComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearRegisterPlayerCompleteDelegate(delegate<OnRegisterPlayerComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool UnregisterPlayer(UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnUnregisterPlayerComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function AddUnregisterPlayerCompleteDelegate(delegate<OnUnregisterPlayerComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearUnregisterPlayerCompleteDelegate(delegate<OnUnregisterPlayerComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool StartOnlineGame()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnStartOnlineGameComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddStartOnlineGameCompleteDelegate(delegate<OnStartOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearStartOnlineGameCompleteDelegate(delegate<OnStartOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool EndOnlineGame()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						delegate OnEndOnlineGameComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddEndOnlineGameCompleteDelegate(delegate<OnEndOnlineGameComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearEndOnlineGameCompleteDelegate(delegate<OnEndOnlineGameComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function EOnlineGameState GetOnlineGameState()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool RegisterForArbitration()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						delegate OnArbitrationRegistrationComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddArbitrationRegistrationCompleteDelegate(delegate<OnArbitrationRegistrationComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearArbitrationRegistrationCompleteDelegate(delegate<OnArbitrationRegistrationComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function array<OnlineArbitrationRegistrant> GetArbitratedPlayers()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddGameInviteAcceptedDelegate(byte,delegate<OnGameInviteAccepted>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearGameInviteAcceptedDelegate(byte,delegate<OnGameInviteAccepted>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnGameInviteAccepted(OnlineGameSettings)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool AcceptGameInvite(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool RecalculateSkillRating(const out array<UniqueNetId>)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
<p />
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						OnlineNewsInterface
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ReadGameNews(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnReadGameNewsCompleted(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function AddReadGameNewsCompletedDelegate(delegate<OnReadGameNewsCompleted>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearReadGameNewsCompletedDelegate(delegate<OnReadGameNewsCompleted>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function string GetGameNews(byte)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool ReadContentAnnouncements(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnReadContentAnnouncementsCompleted(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function AddReadContentAnnouncementsCompletedDelegate(delegate<OnReadContentAnnouncementsCompleted>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearReadContentAnnouncementsCompletedDelegate(delegate<OnReadContentAnnouncementsCompleted>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function string GetContentAnnouncements(byte)
<p />
					</td>
<p />
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
<p />
						OnlinePlayerInterface
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnLoginChange()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnLoginCancelled()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnMutingChange()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnFriendsChange()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function bool ShowLoginUI(optional bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool Login(byte,string,string,optional bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool AutoLogin()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnLoginFailed(byte,EOnlineServerConnectionStatus)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddLoginFailedDelegate(byte,delegate<OnLoginFailed>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearLoginFailedDelegate(byte,delegate<OnLoginFailed>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool Logout(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						delegate OnLogoutCompleted(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddLogoutCompletedDelegate(byte,delegate<OnLogoutCompleted>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearLogoutCompletedDelegate(byte,delegate<OnLogoutCompleted>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ELoginStatus GetLoginStatus(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool GetUniquePlayerId(byte,out UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function string GetPlayerNickname(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function EFeaturePrivilegeLevel CanPlayOnline(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function EFeaturePrivilegeLevel CanCommunicate(byte)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function EFeaturePrivilegeLevel CanDownloadUserContent(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function EFeaturePrivilegeLevel CanPurchaseContent(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function EFeaturePrivilegeLevel CanViewPlayerProfiles(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function EFeaturePrivilegeLevel CanShowPresenceInformation(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool IsFriend(byte,UniqueNetId)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool AreAnyFriends(byte,out array<FriendsQuery>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool IsMuted(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ShowFriendsUI(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddLoginChangeDelegate(delegate<OnLoginChange>,optional byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function ClearLoginChangeDelegate(delegate<OnLoginChange>,optional byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddLoginCancelledDelegate(delegate<OnLoginCancelled>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearLoginCancelledDelegate(delegate<OnLoginCancelled>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddMutingChangeDelegate(delegate<OnMutingChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearMutingChangeDelegate(delegate<OnMutingChange>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddFriendsChangeDelegate(byte,delegate<OnFriendsChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearFriendsChangeDelegate(byte,delegate<OnFriendsChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function bool ReadProfileSettings(byte,OnlineProfileSettings)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnReadProfileSettingsComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddReadProfileSettingsCompleteDelegate(byte,delegate<OnReadProfileSettingsComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearReadProfileSettingsCompleteDelegate(byte,delegate<OnReadProfileSettingsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function OnlineProfileSettings GetProfileSettings(byte)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool WriteProfileSettings(byte,OnlineProfileSettings)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnWriteProfileSettingsComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddWriteProfileSettingsCompleteDelegate(byte,delegate<OnWriteProfileSettingsComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearWriteProfileSettingsCompleteDelegate(byte,delegate<OnWriteProfileSettingsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ReadFriendsList(byte,optional int,optional int)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnReadFriendsComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddReadFriendsCompleteDelegate(byte,delegate<OnReadFriendsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function ClearReadFriendsCompleteDelegate(byte,delegate<OnReadFriendsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function EOnlineEnumerationReadState GetFriendsList(byte,out array<OnlineFriend>,optional int,optional int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function SetOnlineStatus(byte,int,const out array<LocalizedStringSetting>,const out array<SettingsProperty>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ShowKeyboardUI(byte,string,string,optional bool,optional bool,optional string,optional int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddKeyboardInputDoneDelegate(delegate<OnKeyboardInputComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearKeyboardInputDoneDelegate(delegate<OnKeyboardInputComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function string GetKeyboardInputResults(out byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						delegate OnKeyboardInputComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool AddFriend(byte,UniqueNetId,optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool AddFriendByName(byte,string,optional string)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnAddFriendByNameComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddAddFriendByNameCompleteDelegate(byte,delegate<OnAddFriendByNameComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearAddFriendByNameCompleteDelegate(byte,delegate<OnAddFriendByNameComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool AcceptFriendInvite(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function bool DenyFriendInvite(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool RemoveFriend(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnFriendInviteReceived(byte,UniqueNetId,string,string)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddFriendInviteReceivedDelegate(byte,delegate<OnFriendInviteReceived>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearFriendInviteReceivedDelegate(byte,delegate<OnFriendInviteReceived>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool SendMessageToFriend(byte,UniqueNetId,string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool SendGameInviteToFriend(byte,UniqueNetId,optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool SendGameInviteToFriends(byte,array<UniqueNetId>,optional string)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnReceivedGameInvite(byte,string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddReceivedGameInviteDelegate(byte,delegate<OnReceivedGameInvite>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearReceivedGameInviteDelegate(byte,delegate<OnReceivedGameInvite>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool JoinFriendGame(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						delegate OnJoinFriendGameComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddJoinFriendGameCompleteDelegate(delegate<OnJoinFriendGameComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearJoinFriendGameCompleteDelegate(delegate<OnJoinFriendGameComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function GetFriendMessages(byte,out array<OnlineFriendMessage>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnFriendMessageReceived(byte,UniqueNetId,string,string)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddFriendMessageReceivedDelegate(byte,delegate<OnFriendMessageReceived>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearFriendMessageReceivedDelegate(byte,delegate<OnFriendMessageReceived>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function bool DeleteMessage(byte,int)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
<p />
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						OnlinePlayerInterfaceEx
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ShowFeedbackUI(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function bool ShowGamerCardUI(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ShowMessagesUI(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool ShowAchievementsUI(byte)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ShowInviteUI(byte,optional string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool ShowContentMarketplaceUI(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function bool ShowMembershipMarketplaceUI(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool ShowDeviceSelectionUI(byte,int,bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddDeviceSelectionDoneDelegate(byte,delegate<OnDeviceSelectionComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearDeviceSelectionDoneDelegate(byte,delegate<OnDeviceSelectionComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function int GetDeviceSelectionResults(byte,out string)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnDeviceSelectionComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool IsDeviceValid(int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool UnlockAchievement(byte,int)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddUnlockAchievementCompleteDelegate(byte,delegate<OnUnlockAchievementComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearUnlockAchievementCompleteDelegate(byte,delegate<OnUnlockAchievementComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnUnlockAchievementComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool UnlockGamerPicture(byte,int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnProfileDataChanged()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddProfileDataChangedDelegate(byte,delegate<OnProfileDataChanged>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearProfileDataChangedDelegate(byte,delegate<OnProfileDataChanged>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool ShowFriendsInviteUI(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ShowPlayersUI(byte)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
<p />
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						OnlineStatsInterface
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool ReadOnlineStats(const out array<UniqueNetId>,OnlineStatsRead)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool ReadOnlineStatsForFriends(byte,OnlineStatsRead)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function bool ReadOnlineStatsByRank(OnlineStatsRead,optional int,optional int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool ReadOnlineStatsByRankAroundPlayer(byte,OnlineStatsRead,optional int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddReadOnlineStatsCompleteDelegate(delegate<OnReadOnlineStatsComplete>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearReadOnlineStatsCompleteDelegate(delegate<OnReadOnlineStatsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnReadOnlineStatsComplete(bool)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function FreeStats(OnlineStatsRead)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool WriteOnlineStats(UniqueNetId,OnlineStatsWrite)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool FlushOnlineStats()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnFlushOnlineStatsComplete(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddFlushOnlineStatsCompleteDelegate(delegate<OnFlushOnlineStatsComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearFlushOnlineStatsCompleteDelegate(delegate<OnFlushOnlineStatsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool WriteOnlinePlayerScores(const out array<OnlinePlayerScore>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function string GetHostStatGuid()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool RegisterHostStatGuid(const out string)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnRegisterHostStatGuidComplete(bool)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddRegisterHostStatGuidCompleteDelegate(delegate<OnFlushOnlineStatsComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearRegisterHostStatGuidCompleteDelegateDelegate(delegate<OnFlushOnlineStatsComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function string GetClientStatGuid()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool RegisterStatGuid(UniqueNetId,const out string)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
<p />
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						OnlineSystemInterface
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool HasLinkConnection();
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnLinkStatusChange(bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddLinkStatusChangeDelegate(delegate<OnLinkStatusChange>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearLinkStatusChangeDelegate(delegate<OnLinkStatusChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnExternalUIChange(bool)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddExternalUIChangeDelegate(delegate<OnExternalUIChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearExternalUIChangeDelegate(delegate<OnExternalUIChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function ENetworkNotificationPosition GetNetworkNotificationPosition()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function SetNetworkNotificationPosition(ENetworkNotificationPosition)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnControllerChange(int,bool)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddControllerChangeDelegate(delegate<OnControllerChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearControllerChangeDelegate(delegate<OnControllerChange>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool IsControllerConnected(int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnConnectionStatusChange(EOnlineServerConnectionStatus)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddConnectionStatusChangeDelegate(delegate<OnConnectionStatusChange>)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function ClearConnectionStatusChangeDelegate(delegate<OnConnectionStatusChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ENATType GetNATType()
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						delegate OnStorageDeviceChange()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function AddStorageDeviceChangeDelegate(delegate<OnStorageDeviceChange>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function ClearStorageDeviceChangeDelegate(delegate<OnStorageDeviceChange>)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
<p />
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						OnlineVoiceInterface
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool RegisterLocalTalker(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function bool UnregisterLocalTalker(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool RegisterRemoteTalker(UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool UnregisterRemoteTalker(UniqueNetId)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool IsLocalPlayerTalking(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool IsRemotePlayerTalking(UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function bool IsHeadsetPresent(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool SetRemoteTalkerPriority(byte,UniqueNetId,int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool MuteRemoteTalker(byte,UniqueNetId)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool UnmuteRemoteTalker(byte,UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnPlayerTalking(UniqueNetId)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						function AddPlayerTalkingDelegate(delegate<OnPlayerTalking>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearPlayerTalkingDelegate(delegate<OnPlayerTalking>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function StartNetworkedVoice(byte)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function StopNetworkedVoice(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool StartSpeechRecognition(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						function bool StopSpeechRecognition(byte)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool GetRecognitionResults(byte,out array<SpeechRecognizedWord>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						delegate OnRecognitionComplete()
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function AddRecognitionCompleteDelegate(byte,delegate<OnRecognitionComplete>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function ClearRecognitionCompleteDelegate(byte,delegate<OnRecognitionComplete>)
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool SelectVocabulary(byte,int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool SetSpeechRecognitionObject(byte,SpeechRecognition)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						function bool MuteAll(byte,bool)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						function bool UnmuteAll(byte)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
<p />
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						UIDataStoreSubscriber
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						native function SetDataStoreBinding(string, optional int)
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						native function string GetDataStoreBinding(optional int) const
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						native function bool RefreshSubscriberValue(optional int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
<p />
						native function NotifyDataStoreValueUpdated(UIDataStore, bool, name, UIDataProvider, int)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						native function GetBoundDataStores(out array<UIDataStore>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						native function ClearBoundDataStores()
<p />
					</td>
<p />
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
<p />
						UIDataStorePublisher extends UIDataStoreSubscriber
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						native function bool SaveSubscriberValue(out array<UIDataStore>, optional int)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
<p />
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						UIEventContainer
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						native final function GetUIEvents(out array<UIEvent>, optional class<UIEvent>)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						native final function bool AddSequenceObject(SequenceObject, optional bool)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						native final function RemoveSequenceObject(SequenceObject)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						native final function RemoveSequenceObjects(array<SequenceObject>)
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
<p />
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						UIListElementCellProvider
<p />
					</td>
				</tr><tr height="32">
<p />
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						const UnknownCellDataFieldName = 'NAME_None';
<p />
					</td>
				</tr></table>
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
<p />
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						UIStringRenderer
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						native final virtual function SetTextAlignment(EUIAlignment, EUIAlignment)
<p />
					</td>
				</tr></table>
<p />
				<table cellspacing="0" cellpadding="0" width="100%">
				<tr height="32">
					<td height="32" style="background:#ffffff;">
					</td>
				</tr>
				</table>
				<table cellspacing="0" cellpadding="0" width="100%" border="1"><tr height="20">
					<td style="padding-left:10px;background:#4f81bd;color:#ffffff;font:bold 12pt arial;" height="20">
						UIStyleResolver
<p />
					</td>
<p />
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
						native function name GetStyleResolverTag()
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#ffffff;" height="32">
						native function bool SetStyleResolverTag(name)
<p />
					</td>
				</tr><tr height="32">
					<td style="padding-left:10px;background:#d3dfee;" height="32">
<p />
						native function bool NotifyResolveStyle(UISkin, bool, optional UIState, const optional name)
					</td>
				</tr></table>
<p />
<h2><a name="SUMMARY"></a> SUMMARY </h2>
<p />
We have now taken another step out of the shadows and learned about interfaces, within UnrealScript. We have seen how they are defined, their purpose and their quirks within this environment and within the two tutorials we worked on two tutorial sets to implement them. Although they are really a very simple concept they can and should play an important role in your development project.
<p />
Interfaces allow us to rely upon the compiler to control our implementation between classes. They are a template through which we can depend upon a certain group of functions being provided, while their implementation may change. Interfaces may contain functions, delegates, constants or structures, in definition form, and nothing more.
<p />
<h2><a name="SUPPLEMENTAL FILES"></a> SUPPLEMENTAL FILES </h2>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptInterfaces/Chapter_13_Packages.rar" target="_top">Chapter_13_Packages.rar</a>: Compass &amp; Minimap Packages
</li></ul>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptInterfaces/Chapter13_CompleteSource.rar" target="_top">Chapter13_CompleteSource.rar</a>: Complete Source Files
</li></ul>
<p /> <ul>
<li> <a href="rsrc/Three/MasteringUnrealScriptInterfaces/COM-CH_13_Minimap.rar" target="_top">COM-CH_13_Minimap.rar</a>: COM-CH_13_Minimap.ut3 map
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
