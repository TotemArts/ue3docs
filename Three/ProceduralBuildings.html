<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | ProceduralBuildings    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">ProceduralBuildings  </b></div>
<div id="tooltext">
<a href="ProceduralBuildingsJP.html" class="twikiLink">日本語訳</a><br><a href="ProceduralBuildingsCH.html" class="twikiLink">中国翻译</a><br><a href="ProceduralBuildingsKR.html" class="twikiLink">한국어</a><br>

<!-- Three/ProceduralBuildings -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="StaticMeshHome.html" class="twikiLink">Static Meshes</a></b> &gt; Procedural Buildings <br/>
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="EnvironmentArtistHome.html" class="twikiLink">Environment Artist</a></b> &gt; Procedural Buildings
</div>
<hr size="1" noshade="noshade">
<h1><a name="Procedural Buildings"></a> Procedural Buildings </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="ProceduralBuildings.html#Procedural Buildings"> Procedural Buildings</a> <ul>
<li> <a href="ProceduralBuildings.html#Overview"> Overview</a>
</li> <li> <a href="ProceduralBuildings.html#Defining Buildings"> Defining Buildings</a>
</li> <li> <a href="ProceduralBuildings.html#Rulesets"> Rulesets</a>
</li> <li> <a href="ProceduralBuildings.html#LOD"> LOD</a>
</li> <li> <a href="ProceduralBuildings.html#Other Features"> Other Features</a>
</li> <li> <a href="ProceduralBuildings.html#Technical Information (for Programmers)"> Technical Information (for Programmers)</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
Creating good-looking buildings can be a very labor-intensive task, as it usually involves placing a lot of individual meshes. The 'ProcBuilding' system in UE3 is designed to allow designers to very quickly create and edit good looking city buildings. It also automatically creates a low-LOD version of the building using a simple mesh and render-to-texture, to allow you to create large cities.
<p />
The tool is <strong>not</strong> designed to create an entire city with one click. It will not lay out streets and city blocks for you. The level designer is responsible for creating the shape and layout of buildings, and then this tool can be used to quickly apply meshes to that shape.
<p />
A speech on this system was given at GDC 2010, and the slides are available at the <a href="http://unrealtechnology.com/" target="_top">Unreal Technology site</a>.
<p />
<strong>NOTE</strong>: <em>This is still a work in progress! As such, this feature is unsupported at this time. Feedback is welcome!</em>
<p />
<h2><a name="Defining Buildings"></a> Defining Buildings </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
ProcBuildings are just a special type of volume. So you place them like any other volume, by adjusting the builder brush, and then choosing ProcBuilding from the Volume list. Then you create a <em>ProcBuildingRuleset</em> in a package, using a new <a href="KismetUserGuide.html" class="twikiLink">Kismet</a>-like editor called Facade, which tells it how to apply meshes. Then you can try different rulesets on different buildings, change the shape of buildings etc. and it will update the meshing. To apply a ruleset you just need to set the <em>Ruleset</em> property of the volume, or simply drag-and-drop a ruleset from the ContentBrowser.
<p />
See the <a href="ProceduralBuildingsTutorial.html" class="twikiLink">Procedural Buildings Tutorial</a> page for a step by step example.
<p />
<h3><a name="Building Groups"></a> Building Groups </h3>
<p />
When working with a building that is not just a simple shape, it usually desirable to use multiple volumes. For performance reasons though, you should group these volumes together. This is done by choosing one volume to be the 'Base' volume, and then attaching other volumes to it using the 'Base' property. This can be made a lot easier using the <a href="AttachmentsBrowserReference.html" class="twikiLink">Attachments Editor</a>, or the 'ProcBuilding -&gt; Group Buildings' option in the context menu. The 'Prefab Lock' button on the editor toolbar (the letter P) is also used to choose whether you are selecting entire ProcBuilding 'groups' or individual ProcBuilding volumes within a group. The 'Base' ProcBuilding volume in a group will show its wireframe in light green instead of the usual yellow, and can be quickly selected using 'ProcBuilding -&gt; Select Base Building'.
<p />
You only need to set the <em>Ruleset</em> on the Base building, as child buildings will inherit this. You can set it on child Procbuilding volumes if you wish though, to override certain areas of the same ProcBuilding grouping. Note that all meshes that are used for a single building 'group' are owned by the 'Base' ProcBuilding volume, so if you click on them in the editor, you will find yourself selecting that volume.
<p />
<h3><a name="Building Properties"></a> Building Properties </h3>
<p />
The properties of a ProcBuilding volume are described below - more details on many of these are given later in this document.
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">Ruleset</font></strong>  </th><td bgcolor="#eaeaea"> The ProcBuildingRuleset that should be applied to this volume </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bGenerateRoofMesh</font></strong>  </th><td bgcolor="#ffffff"> Whether a roof polygon should be generated for this building </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bGenerateFloorMesh</font></strong>  </th><td bgcolor="#eaeaea"> whether a floor polygon should be generated for this building </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bApplyRulesToRoof</font></strong>  </th><td bgcolor="#ffffff"> If the Ruleset should be run on the roof of a building as well as the walls </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bApplyRulesToFloor</font></strong>  </th><td bgcolor="#eaeaea"> If the Ruleset should be run on the floor of a building as well as the walls </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bSplitWallsAtRoofLevels</font></strong>  </th><td bgcolor="#ffffff"> If entire building group should be split horizontally at each roof level </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bSplitWallsAtWallEdges</font></strong>  </th><td bgcolor="#eaeaea"> If building faces should be split vertically when another face intersects it </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">SimpleMeshMassiveLODDistance</font></strong>  </th><td bgcolor="#ffffff"> How far away the building should transition to the low-LOD version </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">RenderToTexturePullBackAmount</font></strong>  </th><td bgcolor="#eaeaea"> When generating the render-to-texture for LOD, how far to pull back from building (and clip detail) </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">RoofLightmapRes</font></strong>  </th><td bgcolor="#ffffff"> What resolution to use for lighting on the roof of the building </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">NonRectWallLightmapRes</font></strong>  </th><td bgcolor="#eaeaea"> What resolution to use for lighting on the non-rectangular wall polys </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">LODRenderToTextureScale</font></strong>  </th><td bgcolor="#ffffff"> Controls the resolution of the LOD render-to-texture </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">BuildingMaterialParams</font></strong>  </th><td bgcolor="#eaeaea"> Additional parameters that are set on MaterialInstances applied to meshes in particular building. Can be used for tinting walls etc. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bBuildingBrushCollision</font></strong>  </th><td bgcolor="#ffffff"> If collision should be enabled on the building volume itself </td></tr>
</table>
<p />
<h2><a name="Rulesets"></a> Rulesets </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
The first thing that the building system does is extract a set of rectangular  <em>scopes</em> from the designer-specified volume. These scopes form the basic working unit for the meshing system. Each scope has a location and rotation in space, and an X and Z dimension (X is across, Z is up). Obviously not all walls on the building are going to be rectangles however, and in those cases, the system extracts a rectangle by finding two parallel edges, and generating flat polygons to fill in the remaining areas.
<p />
<img alt="extract_rect.gif" src="rsrc/Three/ProceduralBuildings/extract_rect.gif" />
<p />
Once a set of scopes have been found that describe the walls of the building, the ruleset works by doing one of two things:
<p /> <ul>
<li> Break a scope into smaller scopes
</li> <li> Place a mesh that takes up the space of the scope
</li></ul>
<p />
In this way the ruleset is a graph of rules, where each 'top level' scope in turn is passed in on the left, broken down into smaller areas, and then meshes are placed to fill in those areas.
<p />
<img alt="Rules.jpg" src="rsrc/Three/ProceduralBuildings/Rules.jpg" />
<p />
Rules are not normally executed on the roof of a building. This is just filled in with a textured poly (similar to the 'holes' in non-rectangular walls mentioned earlier).
<p />
<h3><a name="Ruleset Properties"></a> Ruleset Properties </h3>
<p />
Once you have created a new Ruleset (in the normal way, using the Content Browser), you can open it in the Facade editor. With no rule nodes selected, the property window will show the properties of the Ruleset itself:
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">DefaultRoofMaterial</font></strong>  </th><td bgcolor="#eaeaea"> The material that should be applied to the roof polygon of the building </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">DefaultFloorMaterial</font></strong>  </th><td bgcolor="#ffffff"> The material that should be applied to the floor polygon of the building </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">DefaultNonRectWallMaterial</font></strong>  </th><td bgcolor="#eaeaea"> The material that should be used on polygons created to fill in holes around wall scopes </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">RoofZOffset</font></strong>  </th><td bgcolor="#ffffff"> Offset applied to the roof (at top of entire building) polygon along Z. Note that <em>RoofEdgeScopeRaise</em> is usually a better way to form walls around the roof. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">NotRoofZOffset</font></strong>  </th><td bgcolor="#eaeaea"> Offset applied to roof (of any volume other than top of entire building) polygon along Z. Note that <em>RoofEdgeScopeRaise</em> is usually a better way to form walls around the roof. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">FloorZOffset</font></strong>  </th><td bgcolor="#ffffff"> Offset applied to the floor (at bottom of entire building) polygon along Z. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">NotFloorZOffset</font></strong>  </th><td bgcolor="#eaeaea"> Offset applied to the floor (of any volume other than bottom of entire building) polygon along Z. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">RoofPolyInset</font></strong>  </th><td bgcolor="#ffffff"> How far to pull 'in' the vertices of the roof polygon </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">FloorPolyInset</font></strong>  </th><td bgcolor="#eaeaea"> How far to pull 'in' the vertices of the floor polygon </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">BuildingLODSpecular</font></strong>  </th><td bgcolor="#ffffff"> Controls overall specular of the building low-LOD version </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">RoofEdgeScopeRaise</font></strong>  </th><td bgcolor="#eaeaea"> Extend any scopes that touch a roof up by this amount, forming short walls around the roof of the building </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">LODCubemap</font></strong>  </th><td bgcolor="#ffffff"> Cubemap texture to use for cubemaps areas (normally glass) on the low-LOD version of the building </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bLODOnlyRoof</font></strong>  </th><td bgcolor="#eaeaea"> If TRUE, a roof poly is only created for the low-LOD version of the building </td></tr>
</table>
<p />
The small black rectangle in Facade is the 'root' or 'top level' connector. You can now add new rule 'nodes' and connect them from here to break up each wall of the building and apply meshes. The green 'tick' button in Facade will regenerate meshing on all buildings which use the Ruleset being edited, allowing you to get a preview of how it looks.
<p />
The following is an explanation of each different rule that can currently be used.
<p />
<h3><a name="Mesh Rule"></a> Mesh Rule </h3>
<p />
This is a very important rule, and actually adds a mesh to the building, using the size and location of the scope passed in. Meshes should always be authored so that the bottom-left corner is the origin, Z is up and X is right. You must specify how large a space you expect the mesh to take up. This is then used to adjust the size of the mesh to fill in the space that is provided for it. This allows you to have features (such as railings or trim) that extend outside the scope region that is passed in.
<p />
Each mesh node supports an array of specified StaticMeshes called <em>BuildingMeshes</em>, and it will pick randomly from that list. The following settings are available for each mesh in the array.
<p />
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">Mesh</font></strong>  </th><td bgcolor="#eaeaea"> The StaticMesh to use </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">DimX</font></strong>  </th><td bgcolor="#ffffff"> The X dimension (width) of Mesh </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">DimZ</font></strong>  </th><td bgcolor="#eaeaea"> The Z dimension (height) of Mesh </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">Chance</font></strong>  </th><td bgcolor="#ffffff"> How likely this mesh is to be picked from the array. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">Translation</font></strong>  </th><td bgcolor="#eaeaea"> An optional translation (or translation range) to apply to the mesh when placing </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">Rotation</font></strong>  </th><td bgcolor="#ffffff"> An option rotation (or rotation range) in degrees to apply to the mesh when placing </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bMeshScaleTranslation</font></strong>  </th><td bgcolor="#eaeaea"> If TRUE, the Translation specified is scaled by any scaling applied to the mesh </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bOverrideMeshLightMapRes</font></strong>  </th><td bgcolor="#ffffff"> If TRUE, use OverriddenLightMapRes instead of resolution set on the mesh </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">OverriddenMeshLightMapRes</font></strong>  </th><td bgcolor="#eaeaea"> Resolution to use for lighting on this mesh, if bOverrideMeshLightMapRes is TRUE </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">SectionOverrides</font></strong>  </th><td bgcolor="#ffffff"> Allows you specify, for each section of this mesh, a range of possible materials to apply as random overrides </td></tr>
</table>
<p />
<h4><a name="Occlusion Test"></a> Occlusion Test </h4>
<p />
Another important feature that a Mesh Rule performs is to test if the scope passed in is intersecting another part of the building. Consider the image below:
<p />
<img alt="OcclusionRule.jpg" src="rsrc/Three/ProceduralBuildings/OcclusionRule.jpg" />
<p />
As you can see, the windows are intersecting with the roof of the building, and it looks bad. The Mesh Rule can determine if the scope is occluded, partially occluded, or not occluded. In the case where it is fully occluded (ie. entirely inside another part of the building), no mesh will be placed. If it is not occluded, one of the meshes specified in the BuildingMeshes array will be chosen. If it is partially occluded (like in the example above) the mesh specified by the <em>PartialOccludedBuildingMesh</em> option will be used instead.
<p />
<img alt="OcclusionRuleDemo.jpg" src="rsrc/Three/ProceduralBuildings/OcclusionRuleDemo.jpg" />
<p />
If you wish you can disable this occlusion test by setting the <em>bDoOcclusionTest</em> option to FALSE, so a mesh from the BuildingMeshes array is always added. Note that occlusion tests are performed using 4 points just inside the corners of the scope.
<p />
<h4><a name="Collision"></a> Collision </h4>
<p />
By default, meshes used as part of a ProcBuilding do not have non-zero extent player collision (only zero-extent weapon collision). Player collision only happens with the volume itself (like a blocking volume) which has several advantages:
<p /> <ul>
<li> Collision is smooth and fast
</li> <li> Collision does not change when the ProcBuilding's ruleset changes
</li></ul>
<p />
Occasionally though you do want player collision against a StaticMesh that is part of the building, and to do this you just set the <em>bBlockAll</em> flag in the rule node to TRUE.
<p />
<h3><a name="Repeat Rule"></a> Repeat Rule </h3>
<p />
This rule takes a scope and breaks it into a number of smaller scopes along an axis.
<p />
<img alt="RepeatRule.jpg" src="rsrc/Three/ProceduralBuildings/RepeatRule.jpg" />
<p />
You first choose an axis (X or Z) using the <em>RepeatAxis</em> option and it will break up the scope along that axis into equal size pieces. It does this by making as many pieces as necessary to ensure no piece is larger than the size defined with <em>RepeatMaxSize</em>.  This will generate a varying number of new scopes depending on the building size.
<p />
Below is an example of using a Repeat Rule along Z to break a large surface into a series of 'floors', and then a Repeat Rule along X to break each floor into a series of window scopes, and then a Mesh Rule to actually place the window mesh.
<p />
<img alt="RepeatRuleMain.jpg" src="rsrc/Three/ProceduralBuildings/RepeatRuleMain.jpg" />
<p />
<h3><a name="Split Rule"></a> Split Rule </h3>
<p />
This node is similar to the Repeat Rule, as it takes a scope and breaks it into smaller scopes based on the defined <em>SplitAxis</em>. However, the Repeat Rule will generate a varying number of scopes depending on the input scope size, whereas the Split Rule will always (unless the input is too small) generate the same number of output scopes.
<p />
<img alt="SplitRule.jpg" src="rsrc/Three/ProceduralBuildings/SplitRule.jpg" />
<p />
To define how the scope should be split up, the designer fills out the <em>SplitSetup</em> array. Each entry in the array will result in one output scope, as well as an additional output connector on the rule node. This allows you do to different things with each part of the scope. These are the properties for each entry in the array:
<p />
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bFixSize</font></strong>  </th><td bgcolor="#eaeaea"> If TRUE, this output will be fixed to <em>FixedSize</em>. If FALSE, this output will expand as the input scope does. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">FixedSize</font></strong>  </th><td bgcolor="#ffffff"> Only used if bFixSize   is TRUE, to define exactly how big the output scope should be </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">ExpandRatio</font></strong>  </th><td bgcolor="#eaeaea"> When multiple entries have bFixSize set to FALSE, this controls how they stretch. A larger number means more stretching as the input gets bigger </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">SplitName</font></strong>  </th><td bgcolor="#ffffff"> This is used to label the output created on the rule node </td></tr>
</table>
<p />
You should always have at least 1 entry in the SplitSetup set to expand (ie. bFixSize set to FALSE). Also, if the size of the scope passed in is larger than the size of all fixed entries, some pieces will not be generated as there is no room to fit them in.
<p />
<h3><a name="Alternate Rule"></a> Alternate Rule </h3>
<p />
Some areas of buildings always start and end with the same feature, with another type of feature placed between. This is not easy to do with just Repeat and Split rules, so the Alternate Rule can be used.
<p />
<img alt="AlternateRuleDemo.jpg" src="rsrc/Three/ProceduralBuildings/AlternateRuleDemo.jpg" />
<p />
As with both Repeat and Split rules, you need to specify an axis using the <em>RepeatAxis</em> property. There are two outputs from this rule, labeled <em>A</em> and <em>B</em>. In the default configuration, as the scope gets larger, the B regions will stretch, but the A region will not. You specify how large B should get before another one is added using the <em>BMaxSize</em> property, and how large A should always be using <em>ASize</em>.
<p />
<img alt="AlternateRule.jpg" src="rsrc/Three/ProceduralBuildings/AlternateRule.jpg" />
<p />
There are some other options that give you additional control:
<p />
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bInvertPatternOrder </font></strong>  </th><td bgcolor="#eaeaea"> This option lets you start and end with a variable size B, instead of the fixed size A (ie. changing it from ABABA to BABAB) </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bEqualSizeAB</font></strong>  </th><td bgcolor="#ffffff"> If TRUE, forces A and B to be the same size </td></tr>
</table>
<p />
<h3><a name="Occlusion Rule"></a> Occlusion Rule </h3>
<p />
As was mentioned in the Mesh Rule node, it is sometimes desirable to perform an occlusion test on a scope. This Rule Node allows you to perform this test on any scope, rather than just before placing a mesh. You may want to, for example, test a floor of a building before splitting it up to make room for a central door.
<p />
<h3><a name="Top/Bottom Rule"></a> Top/Bottom Rule </h3>
<p />
Because each scope extracted from the building volume is processed by the same set of rules, you can sometimes get odd-looking features on more complicated buildings. If your ruleset put shops in at the bottom of each scope for example, upper areas of the building may end up with shop fronts, when that does not make any sense. To fix this, the Top/Bottom Rule Node allows you to test whether the top or bottom of the scope is the same as the top or bottom of the entire ProcBuilding volume group. The example below helps illustrate this:
<p />
<img alt="TopBottomRule.jpg" src="rsrc/Three/ProceduralBuildings/TopBottomRule.jpg" />
<p />
This node works by first seeing if the top of the input scope is the top of the entire building. If it is, it will remove split off the amount defined by <em>ExtractTopZ</em> and pass that scope out of the 'Top' output. If it is not, it will split off the amount defined by <em>ExtractNotTopZ</em> and pass that out of the 'Not Top' output. In this way you can, for example, have a larger trim at the top of the whole building than at the top of each step. A similar process is performed for the bottom of the building using the <em>ExtractBottomZ</em> and <em>ExtractNotBottomZ</em> values. Then the remainder of the scope is passed out of the 'Mid' output. If nothing is connected to one of the 'Top', 'Not Top', 'Bottom' or 'Not Bottom', then nothing will be split from the input scope in that case.
<p />
<h3><a name="Random Rule"></a> Random Rule </h3>
<p />
The Mesh Rule already allows you to select one mesh from a set, but sometimes you want control earlier on in your ruleset, for example choosing a totally different look for a particular floor or face of the building. In addition, you might sometimes want to choose more than one option from a set. The Random Rule lets you do this. You first indicate how many outputs you would like using the <em>NumOutputs</em> property. Then you decide how many of those outputs may fire using the <em>MinNumExecuted</em> and <em>MaxNumExecuted</em> properties. Using this rule you can 'stack' meshes on top of each other in random ways, for example choosing a different A/C unit, sign and light for a particular area of the building. The pictures below show an example of this:
<p />
<img alt="RandomRule2.jpg" src="rsrc/Three/ProceduralBuildings/RandomRule2.jpg" />
<p />
<img alt="RandomRule3.jpg" src="rsrc/Three/ProceduralBuildings/RandomRule3.jpg" />
<p />
<img alt="RandomRule1.jpg" src="rsrc/Three/ProceduralBuildings/RandomRule1.jpg" />
<p />
<h3><a name="Quad Rule"></a> Quad Rule </h3>
<p />
Sometimes there are areas of a building where a flat quad mesh with a tiling material is the best solution, and this rule node allows you to do that. As well as adding a 2-triangle quad mesh to the building, this rule will also adjust the UVs to allow you to do tiling based on the size of the scope. This is controlled with the <em>RepeatMaxSizeX</em> and <em>RepeatMaxSizeZ</em> parameters, in a similar way to the Repeat Rule. Note that there is only one copy of the quad mesh in memory, and per-instance UV adjustment is performed using material instances. This is done automatically, but you must ensure that your base Material applied to the quad (using the <em>Material</em> parameter) supports 4 material instance parameters: U_Scale, U_Offset, V_Scale, V_Offset. There is a master material you can use as the basis for material instances applied to quad's called <em>EngineBuildings.BuildingQuadMaterial</em>. Below is an example of using a quad rule for one side of a building:
<p />
<img alt="QuadNode.jpg" src="rsrc/Three/ProceduralBuildings/QuadNode.jpg" />
<p />
Note in this example the brick pattern is being tiled, but the dirt pattern is only happening once across the whole mesh. This can be easily set up in the material. If you want no tiling to be performed, you can set the <em>bDisableMaterialRepeat</em> to TRUE. You can also control the lightmap resolution on each quad mesh placed with the <em>QuadLightmapRes</em> property. You can also offset the quad mesh along Y (ie. into or out from the building) using the <em>YOffset</em> setting.
<p />
<h3><a name="Sub Ruleset"></a> Sub Ruleset </h3>
<p />
When working with Rulesets, it is possible to create some quite complicated graphs. Also, you sometimes create parts of a Ruleset that you wish to use in multiple other Rulesets (for example, a particularly detailed shop-front area). The help with this, it is possible to create a SubRuleset Node, and use the <em>SubRuleset</em> property to point to another Ruleset. Whatever scope is passed into the node will then be passed into the start of that Ruleset. In this way you can keep each Ruleset small, and avoid some unnecessary duplication. Note that you should be careful not to create 'cycles', where Rulesets refer to each other.
<p />
<h3><a name="Size Rule"></a> Size Rule </h3>
<p />
This offers you a simple choice based on the dimensions of a scope. You first pick the axis that you are interested in with the <em>SizeAxis</em> property, and then the size at which the decision will be made. If the scope dimension is small than this, then it will be passed out of the 'Less' output, otherwise it  will be passed out of the 'Greater/Equal' output. The <em>bUseTopLevelScopeSize</em> option let you make this decision based on the 'top level' scope (ie. the entire building face size) instead of the scope passed in.
<p />
The Size Rule can be used to avoid meshes becoming too squished. In the example below, the 3-window mesh is being squished and does not look good. The designer then uses a Size rule to use a 2 or 1 window version of the mesh when the space is small. The same is done with the trim work.
<p />
<img alt="SizeRule.jpg" src="rsrc/Three/ProceduralBuildings/SizeRule.jpg" />
<p />
<h3><a name="Comment"></a> Comment </h3>
<p />
This special node does not perform any action, but allows you to put a box around areas of the Ruleset and comment them, in the same way as Kismet.
<p />
<h3><a name="Variation Rule"></a> Variation Rule </h3>
<p />
By default the Ruleset applied to a ProcBuilding is applied to all faces. However, it is sometimes desirable to have a different appearance on different faces. To support this, you can use a Variation Rule. To add a 'variation' to a Ruleset, you first have to select the Ruleset itself in Facade (you do this by deselecting all nodes). Then you can add an element to the <em>Variations</em> array, giving a name for that variation (for example 'PlainBrickSide'). Then, whenever you place a Variation Rule node in Facade, it will have one output for each new variation you created for the Ruleset, plus a 'default' output at the top.
<p />
When the level designer wishes to use a particular variation on a face of the building, they simply do the following: <ol>
<li> Go into geometry editing mode
</li> <li> Select the face(s) of the building volume you wish to change
</li> <li> Right click and choose the ProcBuilding menu
</li> <li> Select the desired variation name from the list
</li></ol>
<p />
You can clear all variations assigned to a building by right-clicking on the building and choosing 'ProcBuilding -&gt; Clear Face Variation Assignments'.
<p />
<img alt="VariationsDemo.jpg" src="rsrc/Three/ProceduralBuildings/VariationsDemo.jpg" />
<p />
Here are some other examples of what can be done with a ruleset with many variations. This can be a very good way to create variety in a city, without creating a large number of unique rulesets.
<p />
<img alt="VariationsDemo2.jpg" src="rsrc/Three/ProceduralBuildings/VariationsDemo2.jpg" />
<p />
<h3><a name="Edge Mesh Rule"></a> Edge Mesh Rule </h3>
<p />
Is it sometimes possible to create a ruleset where the edges of each face are flat, and so corners just work naturally. An example of this is below:
<p />
<img alt="TrimCorners1.jpg" src="rsrc/Three/ProceduralBuildings/TrimCorners1.jpg" />
<p />
However, this is not always the case. One approach for making corners look better when the meshes do not perfectly match is to place a mesh down the edge, at an angle half way between the faces. The Edge Mesh Rule does this. It will take the left edge of the scope passed in, and generate a new scope out of the 'Edge' output, angled half way between the two faces. The rest of the scope is slightly 'pulled in' from each vertical edge by the amount specified with the <em>MainXPullIn</em> property. If the angle between the faces is less than <em>FlatThreshold</em> degrees, no Edge scope is generated. The result looks like the example below:
<p />
<img alt="TrimCorners2.jpg" src="rsrc/Three/ProceduralBuildings/TrimCorners2.jpg" />
<p />
<h3><a name="Corner Rule"></a> Corner Rule </h3>
<p />
To get the best looking corners on buildings, it is often desirable to create a custom corner mesh to handle different angles between faces. The Corner Rule node was designed to make this easy. When using the Corner Rule, each scope is designated as 'owning' its left-hand edge. It will split off a portion on the left and right of the scope passed in, and pass the scope it makes on the left out of the output that most closely matches the angle between faces. On the right it will just leave a gap, expecting that area to be filled in by the scope around the building to the right.
<p />
<img alt="CornerRule1.jpg" src="rsrc/Three/ProceduralBuildings/CornerRule1.jpg" />
<p />
You can make a corner node support any number of angles (for example, 0, -90 and +90 degrees), by adding entries to the <em>Angles</em> array. You also control how much X space is taken up by the edge scopes using the <em>CornerSize</em> property. If you wish to override the amount of space to use for each angle, you can change the <em>CornerSize</em> in the <em>Angles</em> array entry to a non-zero value instead. Some other properties of the corner node are:
<p />
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">FlatThreshold</font></strong>  </th><td bgcolor="#eaeaea"> If the angle between two scopes is less than this amount (in degrees), no mesh is added. </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">bNoMeshForConcaveCorners</font></strong>  </th><td bgcolor="#ffffff"> If TRUE, no space is left or mesh inserted for concave corners </td></tr>
</table>
<p />
By default, the Corner node will remove the same amount on the left (for the corner mesh) and the right (for the gap). If you set the <em>bUseAdjacentRulesetForRightGap</em> property to TRUE however, the system will find the corner node used by the scope on the right, and use that corner size for the gap on the right. By doing this, variations with different corner styles can work nicely together, as seen in the picture below. Note that for this to work correctly, the corner sizes at all levels on the building need to be the same.
<p />
<img alt="CornerRule2.jpg" src="rsrc/Three/ProceduralBuildings/CornerRule2.jpg" />
<p />
<h4><a name="Roof Corners"></a> Roof Corners </h4>
<p />
One problem that you run into when using curved or beveled corners is that the roof polygon (generated based on the ProcBuilding volume faces) does not match the actual shape of the roof. The fix this, you can specify some additional information in the corner node, and this will be used to reshape the corners of the roof poly. Note that the system finds the highest corner node to get this information.
<p />
<img alt="Roof1.jpg" src="rsrc/Three/ProceduralBuildings/Roof1.jpg" />
<p />
<img alt="Roof2.jpg" src="rsrc/Three/ProceduralBuildings/Roof2.jpg" />
<p />
The properties in the Corner Rule node that control the roof corner shape are:
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">CornerType</font></strong>  </th><td bgcolor="#eaeaea"> The shape of the corner - this can be EPBC_Default (the standard square corner), EPBC_Chamfer (diagonally cut corner) or EPBC_Round (rounded corner) </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">RoundTesselation</font></strong>  </th><td bgcolor="#ffffff"> If the corner shape is EPBC_Round, this controls how much tessellation is used to round the corner </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">RoundCurvature</font></strong>  </th><td bgcolor="#eaeaea"> This controls the shape of the rounded corner </td></tr>
<tr><th bgcolor="#dadada" class="twikiFirstCol">  <strong><font color="#000000">CornerShapeOffset</font></strong>  </th><td bgcolor="#ffffff"> How far from start of curve mesh region to actually chamfer/round adjust roof poly corner </td></tr>
</table>
<p />
<h4><a name="Horizontal Splitting"></a> Horizontal Splitting </h4>
<p />
In order to process a building, the system has to find which top-level scopes meet at each edge. This can be difficult when more than 2 edges meet at a single edge, as shown in the image below:
<p />
<img alt="CornerRule3.jpg" src="rsrc/Three/ProceduralBuildings/CornerRule3.jpg" />
<p />
From looking at this, it is clear that it would not be possible to choose one corner mesh for the yellow edge and make the results look good. To fix this, the system will 'cut' all scopes at each different roof level in the ProcBuilding group. This can seen in this image:
<p />
<img alt="CornerRule4.jpg" src="rsrc/Three/ProceduralBuildings/CornerRule4.jpg" />
<p />
You can disable this behavior if you wish by setting the <em>bSplitWallsAtRoofLevels</em> on the ProcBuilding volume to FALSE. This process does normally work quite well though, as many real building will continue trim at a roof level around the entire building, as can be seen here:
<p />
<img alt="roof_cut_example.JPG" src="rsrc/Three/ProceduralBuildings/roof_cut_example.JPG" />
<p />
Here is an example of a ProcBuilding with and without that option turned on. As you can see, the building on the left has some holes, because it cannot do a good job of adding trim where the lower roof level meets the rest of the building.
<p />
<img alt="CornerRule6.jpg" src="rsrc/Three/ProceduralBuildings/CornerRule6.jpg" />
<p />
<h2><a name="LOD"></a> LOD </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
All ProcBuilding groups will automatically generate a low-detail StaticMesh version of the building using a render-to-texture technique. This allows the engine to draw the entire low-LOD building with one draw call - all faces are atlased onto a single material. The geometry of the building is essentially the shape of the volume used, although features like <em>RoofEdgeScopeRaise</em> are still used on the LOD building, so small walls around the roof are still present in the LOD, so that the building silhouette does not change. Below is an example of a single-mesh LOD generated for the building:
<p />
<img alt="building_lod2.jpg" src="rsrc/Three/ProceduralBuildings/building_lod2.jpg" />
<p />
The process of rendering the faces of the building into a texture is quite time-consuming, so it not performed as you edit the building. If you wish to generate the lowLOD textures, you can either rebuild lighting in your map (ensuring the 'Generate Building LOD Textures' option is checked), or select the ProcBuildings you want and choose 'Tools -&gt; Generate Selected Buildings LOD Textures' from the main editor menu.
<p />
<h3><a name="Windows"></a> Windows </h3>
<p />
Buildings usually  have glass windows, and this usually done with reflective cubemaps.  As a result, the LOD needs a mask for the reflective windows or this will lose the reflection and create a very noticeable pop when transitioning. This is done automatically, but does require some setup on the meshes. The generate the low LOD textures, 3 rendering passes are made on the building. They are:
<p /> <ol>
<li> Unlit, to gather diffuse color
</li> <li> Lighting Only, to gather lighting information
</li> <li> Window Mode, where all windows are white and non-window areas are black
</li></ol>
<p />
The following image demonstrates these 3 render states:
<p />
<img alt="Windows.jpg" src="rsrc/Three/ProceduralBuildings/Windows.jpg" />
<p />
To make you meshes support 'Window Mode', they must first have a MaterialInstance (and not a Material) applied to them. The MaterialInstance should support a Scalar Parameter called ' RenderWindowCubemapMask'. This will be set to 1.0 when rendering the building in 'Window Mode'. There is also an optional parameter called 'RenderLOD' which is set to 1.0 during all 3 passes if, for example, you wish to disable some features of your material during LOD texture generation.
<p />
This process generates 2 textures . One is for the diffuse, unlit color, with a 1-bit 'window mask' stored in its alpha channel. The other texture is a lighting texture, which is usually much lower resolution. This textures are modulated together in the material on the low-LOD building mesh. The reason for 2 textures is because you need to apply lighting on top of the cubemap texture in the window areas. Below are the textures applied to the low-LOD building shown above:
<p />
<img alt="Windows2.jpg" src="rsrc/Three/ProceduralBuildings/Windows2.jpg" />
<p />
<h3><a name="Streaming"></a> Streaming </h3>
<p />
It is often desirable to have the high-detail building (made from many mesh instances) in a different sub-level from the low-LOD, single section mesh. This is automatically supported by the system. When you add a ProcBuilding to a streaming sub-level, it will automatically generate a new sublevel, with the same name as the 'high detail' level, but with the '_LOD' suffix. For example, if you add a ProcBuilding to CityBlock_01, a new streaming level called CityBlock_01_LOD will automatically be created and a ProcBuilding_SimpleLODActor (which is just a subclass of StaticMeshActor) will be added to it. The reason for having the low-LOD in its own sublevel instead of in the _P map is so that areas of the city can be worked on without requiring the _P map to be checked out.  As you edit the high-detail ProcBuilding, the low detail is automatically updated. It is usually a good idea to check both the high and low detail version of a city block
<p />
Note that when adding a ProcBuilding to a map without sublevels, no LOD map will be added - the ProcBuilding itself will own the low-detail mesh.
<p />
<h3><a name="Attachments"></a> Attachments </h3>
<p />
When you attach a StaticMeshActor to a ProcBuilding (using the usual Base property), it will cause that mesh to be hidden when the building switches to its low-LOD version. This is usually desirable, as the low-LOD version will probably have a version of that static mesh rendered into its texture. When you place a StaticMeshActor (eg. an A/C unit) on top of a ProcBuilding, it will automatically attach itself to the building. This behavior can be disabled with the <em>bDisableAutoBaseOnProcBuilding</em> property on the StaticMeshActor.
<p />
<h3><a name="Transitions"></a> Transitions </h3>
<p />
Unreal Engine uses a dither approach to transitions/LOD.  In order for this to function, however, you need to set the <em>bUsedWithScreenDoorFade</em> property to TRUE on any materials applied to building meshes (or meshes used on StaticMeshActors attached to the building).
<p />
<h2><a name="Other Features"></a> Other Features </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
<h3><a name="Building Stats"></a> Building Stats </h3>
<p />
There is a new tab in the editor which allows you to see stats for buildings in your city. There is one row for each building, and you can see stats for components, triangles and lighting and LOD texture memory usage. This can be very useful for spotting buildings that might need a simpler ruleset because they are very large, or Rulesets that may need their lighting settings adjusted or meshes simplified. Double-clicking on a row will take you to that building.
<p />
<img alt="building_stats.jpg" src="rsrc/Three/ProceduralBuildings/building_stats.jpg" />
<p />
<h3><a name="Material Parameters"></a> Material Parameters </h3>
<p />
It is possible to set parameters that you have exposed in the building mesh Materials on a per-building basis. To do this, add elements to the <em>BuildingMaterialParams</em> array on the ProcBuilding, and fill in the name and desired color for that parameter. This can be a good way to add visual variety to a city without creating a large number of unique rulesets. Below is an example of a row of buildings using the same rulesets, but with the wall color changed using this feature.
<p />
<img alt="proc_color_variations.jpg" src="rsrc/Three/ProceduralBuildings/proc_color_variations.jpg" />
<p />
<h3><a name="Overriding Materials"></a> Overriding Materials </h3>
<p />
You can override the material used  on the generated roof, floor or non-rectangular wall polys on a per-ProcBuilding basis. To do this, enter geometry mode, select the Material you want to use instead, select the face(s), right click and choose 'ProcBuilding -&gt; Apply Material (MaterialName) To Face'. You can clear all per-face Material overrides by right-clicking on a building and selecting 'ProcBuilding -&gt; Clear Material Face Assignments'.
<p />
<h3><a name="Meshing Roof  Floor"></a> Meshing Roof &amp; Floor </h3>
<p />
As mentioned earlier, by default meshing rules are not applied to roofs or floors of buildings. However, there are some cases where this is desirable (for example, adding supporting beams under a bridge-like building). There are two modes of doing this. Setting <em>bApplyRulesToFloor</em> or <em>bApplyRulesToRoof</em> on the ProcBuilding will actually enable a scope being extracted and rules being run on the roof and/or floor area. There is an additional option within the Ruleset variation settings called <em>bMeshOnTopOfFacePoly</em>. Enabling this will make the system generate the usual floor or roof poly, and then apply rules on top of this. An example of this can be seen here, on the underside of the walkway:
<p />
<img alt="floor_mesh.jpg" src="rsrc/Three/ProceduralBuildings/floor_mesh.jpg" />
<p />
<h2><a name="Technical Information (for Programmers)"></a> Technical Information (for Programmers) </h2>
<div style="margin-top:-10px;"><hr size="1" noshade="noshade"></div>
<p />
This section is intended to give more detailed technical explanations for programmers working with the ProcBuilding system
<p />
<h3><a name="Instanced Rendering"></a> Instanced Rendering </h3>
<p />
ProcBuildings make extensive use of the InstancedStaticMeshComponent. This component allows the engine to render many instances of the same mesh in one draw call, thus increasing vertex performance and reducing draw calls. The system will try to create one ISMC per Procbuilding 'group' per mesh, but this may not be possible due to the way that meshes are grouped onto lightmaps, or if different materials or lighting options are used. The INSTCOMPCOUNT console command in the editor will print in the log a histogram of instances-per-component.
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
