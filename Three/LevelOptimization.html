<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | LevelOptimization    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">LevelOptimization  </b></div>
<div id="tooltext">
<a href="LevelOptimizationJP.html" class="twikiLink">日本語訳</a><br><a href="LevelOptimizationCH.html" class="twikiLink">中国翻译</a><br><a href="LevelOptimizationKR.html" class="twikiLink">한국어</a><br>

<!-- Three/LevelOptimization -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<p />
<div style=";hdding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="PerformanceHome.html" class="twikiLink">Performance, Profiling, and Optimization</a></b>&gt; &gt; Level Optimization Guide
</div>
<hr size="1" noshade="noshade">
<h1><a name="Level Optimization Guide"></a> Level Optimization Guide </h1>
<p />
<div class="twikiToc"> <ul>
<li> <a href="LevelOptimization.html#Level Optimization Guide"> Level Optimization Guide</a> <ul>
<li> <a href="LevelOptimization.html#Overview"> Overview</a> <ul>
<li> <a href="LevelOptimization.html#CPU Overhead"> CPU Overhead</a>
</li> <li> <a href="LevelOptimization.html#GPU Overhead"> GPU Overhead</a>
</li> <li> <a href="LevelOptimization.html#Stats"> Stats</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Lightmaps"> Lightmaps</a> <ul>
<li> <a href="LevelOptimization.html#Overview"> Overview</a>
</li> <li> <a href="LevelOptimization.html#Usage"> Usage</a>
</li> <li> <a href="LevelOptimization.html#LightMaps vs. Vertex Lighting"> LightMaps vs. Vertex Lighting</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Dynamic Shadows"> Dynamic Shadows</a> <ul>
<li> <a href="LevelOptimization.html#Overview"> Overview</a>
</li> <li> <a href="LevelOptimization.html#Performance limitations with dynamic shadows"> Performance limitations with dynamic shadows</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Static Meshes and other Primitives"> Static Meshes and other Primitives</a> <ul>
<li> <a href="LevelOptimization.html#Overview"> Overview</a>
</li> <li> <a href="LevelOptimization.html#Primitives Stats Browser"> Primitives Stats Browser</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Materials"> Materials</a>
</li> <li> <a href="LevelOptimization.html#Decals"> Decals</a>
</li> <li> <a href="LevelOptimization.html#Skyboxes"> Skyboxes</a> <ul>
<li> <a href="LevelOptimization.html#Overview"> Overview</a>
</li> <li> <a href="LevelOptimization.html#Quick summary"> Quick summary</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Explanation of common properties"> Explanation of common properties</a> <ul>
<li> <a href="LevelOptimization.html#Primitive component"> Primitive component</a>
</li> <li> <a href="LevelOptimization.html#Light component"> Light component</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Misc"> Misc</a> <ul>
<li> <a href="LevelOptimization.html#Unlit translucency"> Unlit translucency</a>
</li> <li> <a href="LevelOptimization.html#BSP"> BSP</a> <ul>
<li> <a href="LevelOptimization.html#Lighting flags"> Lighting flags</a>
</li> <li> <a href="LevelOptimization.html#Run the 'Clean BSP materials' tool"> Run the 'Clean BSP materials' tool</a>
</li> <li> <a href="LevelOptimization.html#Use '_RemoveSurfaceMaterial'"> Use 'RemoveSurfaceMaterial'</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Levels"> Levels</a> <ul>
<li> <a href="LevelOptimization.html#Cull Distance Volumes"> Cull Distance Volumes</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Terrain"> Terrain</a>
</li> <li> <a href="LevelOptimization.html#Audio"> Audio</a>
</li> <li> <a href="LevelOptimization.html#Textures"> Textures</a>
</li> <li> <a href="LevelOptimization.html#Particles"> Particles</a>
</li> <li> <a href="LevelOptimization.html#Animation"> Animation</a>
</li> <li> <a href="LevelOptimization.html#Physics"> Physics</a>
</li></ul>
</li> <li> <a href="LevelOptimization.html#Other Considerations"> Other Considerations</a> <ul>
<li> <a href="LevelOptimization.html#Previous generation optimizations that no longer work"> Previous generation optimizations that no longer work</a>
</li> <li> <a href="LevelOptimization.html#Verify loaded content in-game (not in-editor)"> Verify loaded content in-game (not in-editor)</a>
</li> <li> <a href="LevelOptimization.html#Run <code>analyzereferencedcontent</code> commandlet"> Run analyzereferencedcontent commandlet</a>
</li> <li> <a href="LevelOptimization.html#Platform Specific Debugging"> Platform Specific Debugging</a> <ul>
<li> <a href="LevelOptimization.html#PC"> PC</a>
</li> <li> <a href="LevelOptimization.html#Playstation 3"> Playstation 3</a>
</li> <li> <a href="LevelOptimization.html#Xbox 360"> Xbox 360</a> <ul>
<li> <a href="LevelOptimization.html#Performance Investigator for Xbox (PIX)"> Performance Investigator for Xbox (PIX)</a>
</li></ul>
</li></ul>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<p />
In Unreal Engine 3, interactions between lights and objects are responsible for the majority of CPU and GPU work that needs to be done to render a level. When optimizing content in a level, the best place to start is usually by examining how things are lit.
<p />
Also check out: <a href="https://udn.epicgames.com/Three/MasteringUnrealLevelOptimization" class="restricted" class="restricted" class="twikiLink">Mastering Unreal Level Optimization</a>
<p />
<h3><a name="CPU Overhead"></a> CPU Overhead </h3>
<p />
On the CPU side, the major expense of lighting lies in figuring out what objects need to be rendered, and whether or not they are using light environments; and if so, which type of light environment they are using. Since most games using UE3 Have a lot of dynamicly lit moving objects, it is easy to use too many light environments. There are several settings, however, that you can use to reduce the cost of light environments.
<p />
Here are the light environment settings from most expensive to least (on the game thread) and when they should be used:
<p />
     1) bEnabled=True, bDynamic=True (the default)
<p />
     These should only be used where needed, they will update based on InvisibleUpdateTime and MinTimeBetweenFullUpdates.  There probably shouldn't be more than 50 of these active at any given time.  They do extra visibility checks when visible, close to a player or when they are moving.
<p />
     2) bEnabled=True, bDynamic=False, bForceNonCompositeDynamicLights=True
<p />
     These should be very cheap, the environment is updated on the first tick and never again.  bForceNonCompositeDynamicLights is necessary to allow dynamic lights to affect them, which doesn't have any significant game thread overhead.  There can be hundreds of these, the only cost (after the first tick) will be line checks to dynamic lights (and only when the owner is visible).  These look better than using precomputed shadows because they can rotate and the lighting will still be correct.  They are used by fractured meshes, GDO's, and some other things.
<p />
     3) bEnabled=False, bUsePrecomputedShadows (on the primitive component)=True (also have to take it out of the dynamic channel and put it in the static lighting channel)
<p />
     These will be lightmapped, very cheap to render and should have virtually no game thread overhead (except that the UDynamicLightEnvironmentComponent::Tick function is still called).  They will look wrong when moved.
<p />
You can also type 'SHOWLIGHTENVS' in the console and you will get a list of all environments that got ticked that frame.  The output in UnrealConsole should look like:
<p />
Log: LE: SP_MyMap_01_S.TheWorld:PersistentLevel.InterpActor_12.DynamicLightEnvironmentComponent_231 No_Detailed_Info_Specified 1
Log: LE: SP_MyMap_01_S.TheWorld:PersistentLevel.InterpActor_55.DynamicLightEnvironmentComponent_232 No_Detailed_Info_Specified 0
Log: LE: SP_MyMap_01_S.TheWorld:PersistentLevel.InterpActor_14.DynamicLightEnvironmentComponent_432 No_Detailed_Info_Specified 1
...
<p />
A '1' at the end of the line means bDynamic is set to TRUE.
<p />
The other command you can try to retrieve all the dynamic lights in the level is 'GETALL' command.
For example, type 'GETALL DynamicLightEnvironmentComponent bDynamic' will show all DynamicLightEnvironmentComponent and the flag for bDynamic.
<p />
The difference between 'SHOWLIGHTENVS' and 'GETALL' is that 'SHOWLIGHTENVS' shows every environments 'TICKED' at that frame where as 'GETALL' displays all of environments whether they ticked or not.
<p />
Another major CPU expense is the overhead associated with driver state changes. With our multi- threaded renderer this usually is only a factor on single CPU systems.
<p />
The <code>STAT SCENERENDERING</code> console command lists <em>occluded primitives</em>, <em>visible static mesh elements</em> and <em>visible dynamic primitives</em> and can be used to determine how many individual primitives are being rendered each frame.
<p />
It is fairly hard to pin down driver CPU overhead or GPU time spent on the PC. The asynchronous nature
of modern GPUs can often result in seemingly random calls appearing taking more time than usual, when in fact these calls are typically waiting for the GPU to finish before they can proceed. The engine synchronizes with the GPU each frame and reports the per thread wait time in <code>STAT THREADING</code>. A high <em>Game thread idle time</em> means that the rendering thread is slower and a high <em>Rendering thread idle time</em> means the gameplay code is the bottleneck. In case of game thread idle time being high, trying different resolutions can be used to determine whether the rendering thread is CPU or GPU bound.
<p />
<h3><a name="GPU Overhead"></a> GPU Overhead </h3>
<p />
For the GPU, having to render a pass per light per object can be quite expensive for objects covering a large portion of unoccluded screen space. The main limiting factor on the GPU is usually shader throughput. For example, having an object lit by three lights, in addition to suffering the additional per-pass overhead, will cause the lighting equation and material to be evaluated three times.
<p />
At higher resolutions (for example, 1280x720 - commonly referred to as 720P), even high end GPUs can become the bottleneck, at frame times of around 30ms. The main cost of lit dynamic scenes at these resolutions is using shadow buffers, as they use a very expensive shader to blur the shadow edges. There are various approachs to optimizing this with different trade-offs with respect to visual fidelity. Also, post processing at any resolution is a constant overhead that can be optimized.
<p />
Console-specific tools or <a href="http://developer.nvidia.com/object/nvperfhud_home.html" target="_top">nvPerfHUD</a> on the PC can be used to get a much more detailed picture of what is taking time and why. For general optimization, however, the biggest bang for the buck is usually making sure your levels follow the guidelines below.
<p />
<h3><a name="Stats"></a> Stats </h3>
<p />
In general, stats commands can be used for various asset types in a level. See the <a href="StatsDescriptions.html" class="twikiLink">Stats Descriptions</a> page for detailed descriptions of stat commands supported by the engine.
<p />
<p />
<h2><a name="Lightmaps"></a> Lightmaps </h2>
<p />
<h3><a name="Overview"></a> Overview </h3>
<p />
Lightmaps have the benefit of reducing both CPU and GPU load. On the CPU side, fewer light-object  interactions need to be taken into account; as far as the engine is concerned, the objects aren't relevant to the light, as all lighting information has been baked into the lightmap.  On the GPU side, the object  doesn't have to be rendered in multiple passes and additionally the lightmap pass is collapsed into the  emissive pass to further reduce the number of passes and induce state change overhead.
<p />
<code>VIEWMODE LIGHTCOMPLEXITY</code> and the associated Editor button can be used to visualize how many non- lightmapped lights are affecting an object. The color scheme is as follows:
<p />
<table cellspacing="1" cellpadding="1" class="twikiTable" border="0"><tr><td bgcolor="#eaeaea" align="right" class="twikiFirstCol"> Lights </td><td bgcolor="#eaeaea"> Mesh Color </td></tr>
<tr><td bgcolor="#ffffff" align="right" class="twikiFirstCol"> 0 </td><td bgcolor="#ffffff"> (R=0,G=0,B=0,A=1) </td></tr>
<tr><td bgcolor="#eaeaea" align="right" class="twikiFirstCol"> 1 </td><td bgcolor="#eaeaea"> (R=0,G=255,B=0,A=1) </td></tr>
<tr><td bgcolor="#ffffff" align="right" class="twikiFirstCol"> 2 </td><td bgcolor="#ffffff"> (R=63,G=191,B=0,A=1) </td></tr>
<tr><td bgcolor="#eaeaea" align="right" class="twikiFirstCol"> 3 </td><td bgcolor="#eaeaea"> (R=127,G=127,B=0,A=1) </td></tr>
<tr><td bgcolor="#ffffff" align="right" class="twikiFirstCol"> 4 </td><td bgcolor="#ffffff"> (R=191,G=63,B=0,A=1) </td></tr>
<tr><td bgcolor="#eaeaea" align="right" class="twikiFirstCol"> 5 </td><td bgcolor="#eaeaea"> (R=255,G=0,B=0,A=1) </td></tr>
</table>
<p />
<img alt="lightingcomplexity.jpg" src="rsrc/Three/LevelOptimization/lightingcomplexity.jpg" />
<p />
In this image, the scene is almost entirely lightmapped (black), but a single dynamic light was added to show how it makes the level appear green.
<p />
<h3><a name="Usage"></a> Usage </h3>
<p />
Overall, lightmaps are a clear win from a performance point of view. The two ways to invoke the use of  lightmaps are either setting UseDirectLightMap to true on the light or setting <code>bForceDirectLightMap</code> to <strong>TRUE</strong> on the primitive (terrain, static mesh, skeletal mesh, ...). Like other precomputed shadowing information, lightmaps can only be used on static objects. See the <a href="LightingReference.html" class="twikiLink">LightingReference</a> for details.
<p />
The downside of lightmaps is that the engine has no way of knowing the contribution of a single light to the lightmap, meaning that general dynamic shadowing becomes impossible. In other words, a dynamic object cannot cast a shadow from a light onto a static mesh if said light is part of the lightmap. A workaround for this limitation are modulated shadows as they project onto any surface though have their own share of drawbacks.
<p />
<h3><a name="LightMaps vs. Vertex Lighting"></a> LightMaps vs. Vertex Lighting </h3>
<p />
See the attached <a href="rsrc/Three/LevelOptimization/LightMapVSVertexLightingCosts.xlsx" target="_top">LightMapVSVertexLightingCosts.xlsx</a> spread sheet for the cost comparison.
Also keep in mind that vertex lighting and lightmap data are handled very differently memory-wise. All lightmap data is put into the streaming-texture pool, so those texture will not be adding to the actual memory footprint.  Vertex lighting however, is always stored in system memory and is a constant memory overhead when a level is loaded.
'Stat memory' reports a vertex lighting field, generally this number should be as low as possible, and if you are having memory issues, the first thing you can do is make sure you are using lightmaps whenever possible.
This is especially true when using fracture meshes, as the polycount tends to be quite high with fracture meshes, so vertex lighting will really eat memory.
<p />
<p />
<h2><a name="Dynamic Shadows"></a> Dynamic Shadows </h2>
<p />
<h3><a name="Overview"></a> Overview </h3>
<p />
Another potential source of performance problems is dynamic shadowing. A quick way to gauge whether dynamic shadowing has an impact on performance is to toggle it off via the <code>SHOW DYNAMICSHADOWS</code> console command. It is advisable to bind a key to this command, so that while the key is pressed dynamic shadows are turned off and then enabled again when the key is released. This can be done from the console - for example: <code>SETBIND F SHOW DYNAMICSHADOWS | ONRELEASE SHOW DYNAMICSHADOWS</code>.
<p />
<h3><a name="Performance limitations with dynamic shadows"></a> Performance limitations with dynamic shadows </h3>
<p />
The GPU cost of shadow buffers is directly proportional to the screenspace size of the shadow frustum. This means a nearby character using shadow buffers is much more expensive than a far away one. It also means that a large object casting a dynamic shadow buffer shadow is much more expensive than a small one. See the <a href="https://udn.epicgames.com/Three/ShadowBufferFilteringOptions" class="restricted" class="restricted" class="twikiLink">Shadow Buffer Filtering Options</a> page for more details.
<p />
Also see the <a href="ShadowingReference.html" class="twikiLink">Shadowing Reference</a> page and <a href="ModulatedShadows.html" class="twikiLink">Modulated Shadows</a> page for more shadow optimizations.
<p />
<p />
<h2><a name="Static Meshes and other Primitives"></a> Static Meshes and other Primitives </h2>
<p />
<h3><a name="Overview"></a> Overview </h3>
<p />
A common source of performance problems is in Static Meshes. In general, you should replace any Static Meshes that are used only once or twice, and replace them with similar ones that are already used frequently. Try to avoid using unique meshes for skyboxes whenever possible. Whenever possible, apply the proper trade-off for vertex lighting vs. lightmap lighting. You can also use the Primitive Stats Browser to look for biggest <em>bang for the buck</em> optimizations (sort by instanced triangle count).
<p />
<h3><a name="Primitives Stats Browser"></a> Primitives Stats Browser </h3>
<p />
What follows is a description of the columns in the Primitive Stats Browser (formerly Static Mesh Stats Browser): <ul>
<li> <strong>Type</strong> - Type of the resource, either skeletal mesh, static mesh, terrain or BSP (model)
</li> <li> <strong>Count</strong> - Number of instances of that mesh in the level.
</li> <li> <strong>Triangles</strong> - Triangle count per instance.
</li> <li> <strong>Resource Size</strong> - Size of resource in KByte as reported by "view resource usage", only relevant for static and skeletal meshes
</li> <li> <strong>Lights (avg LM/ other/ total)</strong> - Average number of lightmapped (LM), non lightmapped (other) and total lights affecting each instance.
</li> <li> <strong>Obj/ Light cost</strong> - The object/ light interaction cost.  This number indicates how many times this static mesh is going to be re-rendered for lighting purposes. It is the number of non-lightmapped lights times the total sections count of all instances. Lightmaps are not included in this number, as they are rendered as part of the emissive pass and are therefore can considered "free".
</li> <li> <strong>Triangle cost</strong> - The number of triangles that need to be rendered for lighting purposes. This number excludes the z-prepass, emissive and lightmaps as those are constant overhead regardless of the number of lights.
</li> <li> <strong>Lightmap</strong> - The amount of memory used by lightmap data.
</li> <li> <strong>Shadowmap</strong> - The amount of memory used by shadowmap data.
</li> <li> <strong>LM Res</strong> - The average lightmap resolution per instance.
</li> <li> <strong>Sections</strong> - The number of sections this mesh has.
</li> <li> <strong>Radius (min/max/avg)</strong> - Min/max/average radius of the bounding box for each instance of the mesh.
</li></ul>
<p />
<img alt="primitivestats.jpg" src="rsrc/Three/LevelOptimization/primitivestats.jpg" />
<p />
<h2><a name="Materials"></a> Materials </h2>
The complexity of the materials in a scene can greatly affect the GPU overhead of the scene. The more dynamic lights that are used, the more costly an expensive material becomes.
The editor offers a Shader Complexity Viewmode, and it looks like this:
<p />
<img alt="shadercomplexity.jpg" src="rsrc/Three/LevelOptimization/shadercomplexity.jpg" />
<p />
Lighter shades of green mean the material is fairly cheap, darker shades indicate a more expensive material, or multiple dynamic lights affecting. Note that to see an accurate representation of shader complexity, the level must have lighting rebuilt.
Tips for optimizing materials: <ul>
<li> Try and limit the amount of Dependent Texture reads, this means modifying UVs with a texture, such as BumpOffset.
</li> <li> Use Material Instancing, and use StaticSwitchParameters for expensive effects so that they can be toggled on/off easier to make performance tradeoffs.
</li> <li> Consider removing specular from materials that do not have very much specular. This removes a significant amount of pixel shader instructions and in many cases is not noticeable.
</li> <li> Try and limit the number of texture lookups in each material, the more texture lookups the longer it will take the GPU to get the textures it needs.
</li></ul>
<p />
<p />
<h2><a name="Decals"></a> Decals </h2>
<p />
Static Decals that are placed in the level can eat up performance quickly if not handled properly. If left unchecked, they will project onto extra meshes that are not necessary, and this will skyrocket the amount of Sections that have to be rendered.  They should be set to only affect the static meshes/BSP that they need to affect, since this can significantly reduce section count.
<p />
For more information on using decals and the Decal System, see the <a href="UnsingDecals#Controlling receiving surfaces">UsingDecals#Controlling receiving surfaces</a> page.
<p />
<p />
<h2><a name="Skyboxes"></a> Skyboxes </h2>
<p />
<h3><a name="Overview"></a> Overview </h3>
<p />
Skyboxes usually contain very large objects whose bounding boxes/spheres encompass large portions of the world. This has several notable side effects. Firstly, objects intersecting the near clipping plane will not use occlusion queries and always be rendered, even if no pixels of the mesh are visible. This is usually not a big deal for unlit domes that aren't affected by light, as the engine first renders a depth pass to maximize the utility of early hardware z-rejection. There can be some cost associated with state changes and additional overhead if your skybox is lit and hit by many lights.
<p />
The skybox's bounding box being the size of the entire world suggests that every single light in the world that isn't explicitly excluded via either the lighting channel or manual exclusion functionality is affecting the skybox. This makes skybox actors a prime candidate for having <code>bForceDirectLightMap</code> set to <strong>TRUE</strong> and <code>bAcceptsDynamicLights</code> to <strong>FALSE</strong> so it doesn't get re-rendered for every single dynamic light in the level (e.g. muzzle flashes). Changing the skybox actors to neither have collision nor accept decals is also generally a good idea.
<p />
For unlit moving or rotating objects in the skybox, it is usually best to set <code>bAcceptsLights</code> to <strong>FALSE</strong> to avoid much work on the CPU side that is necessary done regardless of whether the material is lit or not.
<p />
<h3><a name="Quick summary"></a> Quick summary </h3>
<p />
A quick summary of what to do for skyboxes:
<p /> <ul>
<li> Disable collision and ability to receive decals;
</li> <li> Set <code>bAcceptsLights</code> to <strong>FALSE</strong> for unlit objects;
</li> <li> Set <code>bAcceptsDynamicLights</code> to <strong>FALSE</strong> for other objects;
</li> <li> Use the skybox lighting channel if needed and either set skybox objects to force LM or force LM on lights.
</li> <li> Disable <code>CastShadow</code> on skybox where appropriate and disable <code>bCastDynamicShadow</code>.
</li></ul>
<p />
<p />
<h2><a name="Explanation of common properties"></a> Explanation of common properties </h2>
<p />
<h3><a name="Primitive component"></a> Primitive component </h3>
<p /> <ul>
<li> <strong>CastShadow</strong> controls whether the primitive component should cast a shadow or not. Currently dynamic primitives will not receive shadows from static objects unless both this flag and bCastDynamicShadow are enabled.
</li> <li> <strong>bCastDynamicShadow</strong> controls whether the primitive should cast shadows in the case of non precomputed shadowing -- for example, when the primitive is between a light and a dynamic object. This flag is only used if CastShadow is TRUE. Currently, dynamic primitives will not receive shadows from static objects unless both this flag and CastShadow are enabled.
</li> <li> <strong>bForceDirectLightMap</strong> forces the use of lightmaps for all static lights affecting this primitive even though the light might not be set to use light maps. This means that the primitive will not receive any shadows from dynamic objects obstructing static lights. It will correctly shadow in the case of dynamic lights
</li> <li> <strong>bAcceptsLights</strong> controls whether the primitive accepts any lights. A nice optimization, and should be set to FALSE for any objects that do not require lighting.
</li> <li> <strong>bAcceptsDynamicLights</strong> controls whether the object should be affected by dynamic lights.
</li> <li> <strong>LightingChannels</strong> define what lights can affect this primitive.
</li></ul>
<p />
<h3><a name="Light component"></a> Light component </h3>
<p /> <ul>
<li> <strong>CastShadows</strong> controls whether the light should cast shadows.
</li> <li> <strong>CastStaticShadows</strong> controls whether the light should cast shadows from objects that can receive static shadowing.
</li> <li> <strong>CastDynamicShadows</strong> controls whether the light should cast shadows from objects that cannot receive static shadowing.
</li> <li> <strong>bForceDynamicLight</strong> forces the use of shadow volumes/stencil shadows.  This avoids potential issues with cubemaps and also avoids any memory used for static shadowing.
</li> <li> <strong>UseDirectLightMap</strong> determines whether to use lightmaps for this light.
</li> <li> <strong>LightingChannels</strong> define which primitives this light can affect.
</li></ul>
<p />
<p />
<h2><a name="Misc"></a> Misc </h2>
<p />
<h3><a name="Unlit translucency"></a> Unlit translucency </h3>
<p />
Unlit translucency can have a severe impact on performance if there is significant overdraw with a complex material. An easy way to gauge its performance impact is to either toggle its use via <code>SHOW UNLITTRANSLUCENCY</code> on the console, or unchecking the respective show flag in the Editor viewport.
<p />
Tips: <ul>
<li> Check performance on target platform via <code>SHOW UNLITTRANSLUCENCY</code>.
</li> <li> Use <code>VIEWMODE SHADERCOMPLEXITY</code> to visualize.
</li> <li> Avoid layering, especially for light cones and stuff.
</li> <li> Make use of cull distance where possible.
</li></ul>
<p />
<h3><a name="BSP"></a> BSP </h3>
<p />
<h4><a name="Lighting flags"></a> Lighting flags </h4>
<p />
BSP is split into chunks, based primarily on location. This implies that individual BSP segments (model components) are moderately large and are thus hit by several lights. One way to control the light/BSP interaction is to make use of the BSP lighting channel and the "Accepts Lights", "Accepts Dynamic Lights" and "Force LightMap" surface options. Changing these options will only have affect when BSP is rebuilt, as those flags are propagated to the BSP chunks, and the chunks are created in part based on those options. They directly correspond to bAcceptsLights, bAcceptsDynamicLights and bForceDirectLightMap on primitive components. Using these flags can significantly increase performance for levels that make elaborate use of BSP.
<p />
<h4><a name="Run the 'Clean BSP materials' tool"></a> Run the 'Clean BSP materials' tool </h4>
<p />
Run the CLEANBSPMATERIALS editor exec (accessed in UnrealEd via the 'Clean BSP Materials' option in the 'Tools' menu) to clear references held by brushes to materials for those faces that don't exist in the final BSP.  Examples include 'add' brushes fully contained by additive space, 'cospatial' polys (e.g. abutting cubes that share a face), etc.
<p />
Note that this operation should only be performed after a level's BSP is finalized.  Because material references on hidden faces are cleared, if the BSP is later edited so that hidden brushes become visible, material assignments will need to be reapplied to these newly-visible faces.
<p />
This feature appears in QA_APPROVED_BUILD_JUN_2007.
<p />
<h4><a name="Use '_RemoveSurfaceMaterial'"></a> Use 'RemoveSurfaceMaterial' </h4>
<p />
The EngineMaterials package contains a special material called RemoveSurfaceMaterial that should be applied to all BSP surfaces that the player will never see.  Under the hood, BSP surfaces marked with this material will not contribute renderable triangles to the BSP mesh, nor will they receive any static lighting (and consume associated lightmap real-estate).
<p />
Surfaces marked with RemoveSurfaceMaterial are visible in the editor and in PIE so that designers can test the surfaces for visibility and revert the material as necessary.  However, they're not visible when the game is run outside of the editor.
<p />
This feature appears in QA_APPROVED_BUILD_JUN_2007.
<p />
<h3><a name="Levels"></a> Levels </h3>
<p />
Here are some tips for optimizing levels: <ul>
<li> Make sure skybox is unlit, doesn't accept decals, lights, doesn't collide
</li> <li> In the Primitive Stats Browser, sort by count and instanced triangles: <ul>
<li> Eliminate/ reduce instances for meshes that are used a lot.
</li> <li> Make sure simplest mesh is used for high inst. triangle counts (for example if 2000 triangle is used 100 times, consider using 200 triangle column).
</li></ul>
</li> <li> Use collision view modes to disable collision where not needed.
</li> <li> Play the game to see what is visible, often times meshes are added that are not visible when playing the game normally as Editor viewpoint doesn't match where the player moves, eye height, etc.
</li> <li> Make sure there are no meshes hidden below the world, inside geometry, etc.
</li> <li> Mark all BSP surfaces that are no visible as to not accepting lighting.
</li> <li> Set default texture on invisible BSP surfaces.
</li> <li> Use <code>VIEWMODE LIGHTCOMPLEXITY</code> to ensure level is black where there are no dynamic lights: <ul>
<li> Only use toggleable lights of small radius.
</li> <li> Don't use toggleable directional lights.
</li></ul>
</li> <li> Keep total static mesh and static mesh section count under budget.
</li></ul>
<p />
<h4><a name="Cull Distance Volumes"></a> Cull Distance Volumes </h4>
<p />
Unreal Engine has used CullDistance to cull objects based on distance for a while now. If you can cull a significant number of your objects, it will cut down on the visible elements and the occlusion time, it can be a big performance boon.
<p />
Rather than spend time setting CullDistance by hand, we assign it automatically based on CullDistance Volumes. A CullDistance Volume is a volume, and the actor has an array. Each field added to the array has a CullDistance and Size setting.
<p />
When you save the level, the editor will check the diameter of the bound sphere of every object in the level, and assign it a cull distance automatically based on which Size category it most closely matches.
<p />
To add a CullDistance volume, make the builder brush large enough to encompass your whole level, right click the "Add Volume" button, and select "CullDistanceVolume" from the list.
<p />
<img alt="culldistancevolume.jpg" src="rsrc/Three/LevelOptimization/culldistancevolume.jpg" />
<p />
To set up the CullDistance Volume, start by creating the CullDistance for your smallest objects, and adjust the distance/size of that field until you can barely see small objects popping in/out in the distance. Then you create the next largest one (with a slightly further culldistance), until you finally hit the largest mesh that you are willing to automatically cull. A CullDistance of 0 means it will not be culled. In the example image above, no mesh that is approximately 10,000 units or larger will use CullDistanceVolumes.
<p />
The distances should be tweaked until you cannot see any obvious popping.
<p />
A mesh can 'opt out' of CullDistanceVolumes by setting the following flag
<code>StaticMeshComponent.Rendering.bAllowCullDistanceVolume=False</code>
<p />
The non-editable field <code>CachedCullDistance</code> displays the cull distance currently assigned to a mesh from cull distance volumes.
<p />
See the <a href="VisibilityCulling.html" class="twikiLink">Visibility Culling</a> page for more details.
<p />
<h3><a name="Terrain"></a> Terrain </h3>
<p />
Here are some tips for optimizing terrain: <ul>
<li> Use patch bounds view.
</li> <li> Use wireframe to sanity check tessellation.
</li> <li> See the Terrain Reference<sup>?</sup> page for more details.
</li></ul>
<p />
<h3><a name="Audio"></a> Audio </h3>
<p />
Here are some tips for optimizing audio: <ul>
<li> Ensure that multiple music tracks aren't being used unless they are absolutely necessary.  It's a good idea to keep music tracks in their own streaming maps so that they can be streamed in and out when they are needed(this will not affect performance, but it will affect the overall level budget).
</li> <li> Check budget via <code>STAT AUDIO</code>, <code>STAT MEMORY</code>.
</li> <li> Use <code>LISTSOUNDS</code> to see what is the currently loaded sounds - displays waves stored on a per group basis so you can see what types of sounds take up the most memory.
</li> <li> <code>LISTWAVES</code> lists the currently playing sounds (PC only).
</li> <li> <code>LISTAUDIOCOMPONENTS</code> lists the currently <em>considered</em> sounds.
</li></ul>
<p />
<h3><a name="Textures"></a> Textures </h3>
<p />
Unreal Engine 3 Uses a Texture Streaming Pool. This means that all streaming textures have a total known memory footprint, and the engine will do its best to load only textures that are large/near the player at the highest resolution.  However it still leaves the potential for you to add too many textures and cause blurryness everywhere. In this case, the only way to fix it is to cut your texture usage down to realistic levels.
Here are some tips for optimizing textures: <ul>
<li> Check STAT STREAMING and streaming fudge factor. If this number  is at 1.0 then you have nothing to worry about, anything higher than 1.0 means that the textures do not fit and some of them will be blurry.
</li> <li> Use <code>LISTTEXTURES</code> to see what is loaded.  This will spit out a list of textures that are loaded into the log. This information can be copied into excel, and automatically organized into rows/columns by pressing the "Text to Columns" button (under Data), and choosing Delimited-&gt;Comma-&gt; finish. Then press sort to allow you to sort each row by ascending or descending order.
</li> <li> Once you have a listtextures output into excel, sorting by DESCENDING in the "Current Size" row, and you can use that to start analyzing the worst-case-offenders..... the textures that are taking up the most memory.
</li></ul>
<p />
<h3><a name="Particles"></a> Particles </h3>
<p />
Here are some tips for optimizing particles: <ul>
<li> Disable collision on minor stuff (in UT the Enforcer weapon sparks used collision!).
</li> <li> Avoid overdraw.
</li> <li> Use PIX and <code>VIEWMODE SHADERCOMPLEXITY</code>.
</li> <li> Use <code>STAT PARTICLES</code> to see count.
</li> <li> Manually set bounding boxes for common effects or large ones.
</li> <li> Ensure Editor generated max active counts are sane.
</li> <li> See the <a href="ParticleSystemReference.html" class="twikiLink">Particle System Reference</a> page for more details
</li> <li> Use <code>MEMORYSPLIT</code>, it will show how much particle data is currently loaded as Active and how much is could be loaded as Peak (the max possible memory that could be allocated to particles at one time).
</li></ul>
<p />
<h3><a name="Animation"></a> Animation </h3>
<p />
Here are some tips for optimizing animations: <ul>
<li> Make sure all animations are compressed: <ul>
<li> If there is a reason not to compress, follow up with programmer.
</li> <li> There really shouldn't be a reason not to compress; and it's a bug if it doesn't look good.
</li></ul>
</li> <li> Stitched together cinematics need to be baked and pruned.
</li> <li> <code>OBJ LIST CLASS=ANIMSET</code>.
</li> <li> <code>OBJ LIST CLASS=ANIMSEQUENCE</code>. <ul>
<li> If an anim sequence is loaded all anim sequences in set will be loaded!
</li></ul>
</li></ul>
<p />
<h3><a name="Physics"></a> Physics </h3>
<p />
In general, turn on <em>rigid body collision view</em> (you can use <code>SHOW RIGIDBODY</code> at the console). Then set <em>BlockRigidBody</em> to <strong>FALSE</strong> on anything that vehicles or ragdolls can't collide with. For large high structures, you might want to turn off rigid-body collision for all meshes and put a big blocking volume over it.
<p />
<p />
<h2><a name="Other Considerations"></a> Other Considerations </h2>
<p />
<h3><a name="Previous generation optimizations that no longer work"></a> Previous generation optimizations that no longer work </h3>
<p />
A common optimization in previous generation PC titles was to merge smaller objects with the same materials into larger ones. This is <strong>not</strong> advisable with this generation due to the increased impact of object/light interaction. A larger object will be touched by more lights and will be considered for shadowing by more dynamic objects.
<p />
<h3><a name="Verify loaded content in-game (not in-editor)"></a> Verify loaded content in-game (not in-editor) </h3>
<p />
You can make sure only vehicle and weapon assets that are loaded are being used by running the <code>OBJ LIST CLASS=SKELETALMESH</code> command. Follow up with gameplay programmer if this is proven otherwise. For example, in the past we've had issues where certain Kismet actions referenced too much content.
<p />
Other useful commands: <ul>
<li> LISTSOUNDS for audio
</li> <li> LISTTEXTURES for textures
</li></ul>
<p />
<h3><a name="Run <code>analyzereferencedcontent</code> commandlet"></a> Run <code>analyzereferencedcontent</code> commandlet </h3>
<p />
Make sure there are no meshes with excessive convex hull counts. Also try to optimize the most-used meshes. Optimize worst case material offenders, especially once used a lot.
<p />
<a href="CommandletList.html#analyzereferencedcontent" class="twikiAnchorLink">CommandletList#analyzereferencedcontent</a>
<p />
<h3><a name="Platform Specific Debugging"></a> Platform Specific Debugging </h3>
<p />
It is always important to test performance and memory on the platform that you plan to ship on. The debugging tools in the editor will help you sort out the worst offenders, but the only way to truly optimize your content for a shipping product is to analyze how it is running on the target platform. See the <a href="StatsDescriptions.html" class="twikiLink">Stats Descriptions</a> page for detailed descriptions of stat commands supported by the engine.
<p />
Note that memory also comes with fragmentation (whether system fragmentation or internal engine fragmentation). This means you need to have a buffer of % of total usage depending on how your game uses.
<p />
Say you're using 200 mbs, then you'd like to expect fragmentation of % depending on how game got to the point. This fragmentation could get worse as game session gets longer, but it should not be linear. It will converse to the point where worst could be. (Could be 10% or 20%)
Please consult programmers.
<p />
<h4><a name="PC"></a> PC </h4>
<p />
For PC testing it's important to constantly gather stats on a PC that fits within your Target Minimum Spec range, as well as make sure that all material fallback options are working correctly.
<p />
<h4><a name="Playstation 3"></a> Playstation 3 </h4>
<p />
Forthcoming.
<p />
<h4><a name="Xbox 360"></a> Xbox 360 </h4>
<p />
It's very important to check all texture streaming, memory and performance issues and stats on an actual devkit since results can vary from the PC.
The most important tool for debugging performance issues on the xbox is Microsoft's Performance Investigator for Xbox (PIX).
<p />
<h5><a name="Performance Investigator for Xbox (PIX)"></a> Performance Investigator for Xbox (PIX) </h5>
<p />
Please refer to the <a href="http://msdn.microsoft.com/en-us/library/bb173085(VS.85).aspx" target="_top">PIX documentation</a> on the MSDN. <ul>
<li> <a href="rsrc/Three/LevelOptimization/LightMapVSVertexLightingCosts.xlsx" target="_top">LightMapVSVertexLightingCosts.xlsx</a>: updated to take into account N instances
</li></ul>
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
