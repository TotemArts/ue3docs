<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | NavMeshConstraintsAndGoalEvaluators    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">NavMeshConstraintsAndGoalEvaluators  </b></div>
<div id="tooltext">
<a href="NavMeshConstraintsAndGoalEvaluatorsJP.html" class="twikiLink">日本語訳</a><br><a href="NavMeshConstraintsAndGoalEvaluatorsCH.html" class="twikiLink">中国翻译</a><br><a href="NavMeshConstraintsAndGoalEvaluatorsKR.html" class="twikiLink">한국어</a><br>

<!-- Three/NavMeshConstraintsAndGoalEvaluators -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<style type="text/css" media="all">@import "rsrc/UDNCSS_test.css";</style>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AIAndNavigationHome.html" class="twikiLink">AI &amp; Navigation</a></b> &gt; Nav Mesh Path constraints and Goal Evaluators
</div>
<hr size="1" noshade="noshade">
<p />
<h1><a name="Nav Mesh Path constraints and Goal Evaluators"></a> Nav Mesh Path constraints and Goal Evaluators </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Nav Mesh Path constraints and Goal Evaluators"> Nav Mesh Path constraints and Goal Evaluators</a> <ul>
<li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Overview"> Overview</a> <ul>
<li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Why?"> Why?</a>
</li></ul>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Path Constraints"> Path Constraints</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Path Goal Evaluators"> Path Goal Evaluators</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Constraint/_GoalEval Pooling"> Constraint/GoalEval Pooling</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Example usage"> Example usage</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Quick summary of current path constraints and what they are for"> Quick summary of current path constraints and what they are for</a> <ul>
<li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshPath_AlongLine"> NavMeshPath_AlongLine</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshPath_EnforceTwoWayEdges"> NavMeshPath_EnforceTwoWayEdges</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshPath_MinDistBetweenSpecsOfType"> NavMeshPath_MinDistBetweenSpecsOfType</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshPath_SameCoverLink"> NavMeshPath_SameCoverLink</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshPath_Toward"> NavMeshPath_Toward</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshPath_WithinDistanceEnvelope"> NavMeshPath_WithinDistanceEnvelope</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshPath_WithinTraversalDist"> NavMeshPath_WithinTraversalDist</a>
</li></ul>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#Quick summary of current path goal evaluators and what they are for"> Quick summary of current path goal evaluators and what they are for</a> <ul>
<li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_At"> NavMeshGoal_At</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_ClosestActorInList"> NavMeshGoal_ClosestActorInList</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_Filter"> NavMeshGoal_Filter</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_GenericFilterContainer"> NavMeshGoal_GenericFilterContainer</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_Null"> NavMeshGoal_Null</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_PolyEncompassesAI"> NavMeshGoal_PolyEncompassesAI</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_Random"> NavMeshGoal_Random</a>
</li> <li> <a href="NavMeshConstraintsAndGoalEvaluators.html#NavMeshGoal_WithinDistanceEnvelope"> NavMeshGoal_WithinDistanceEnvelope</a>
</li></ul>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
<p />
This document outlines the purpose and usage of path constraints and path goal evaluators as they pertain to path finding and generic path traversals.
<p />
<h3><a name="Why?"></a> Why? </h3>
The advent of these modular and customizable constraints allows the AI programmer to run path queries tailored to fit the needs of the game exactly, with very little code overhead. In the past if one wanted to do something like <em>find a path from A -&gt; B that stays away from enemies</em> one would have to add a special case if block to the path cost function in native code, and continue doing so for each new situation. This quickly becomes unwieldy. For each different combination of custom considerations (constraints) one needs for a particular path search, new code must be added to take into account each new query.
<p />
Our approach instead packages concerns into self-contained objects called <strong>PathConstraints</strong> which gets added to a list of which all are considered during path finding. So if you're just trying to find the shortest path to your destination you could simply add the <strong>Path_TowardGoal</strong> constraint, which would get you the classical straight line A* heuristic favored by AI programmers. However, if you want to do something more complex say, find shortest path from A -&gt; B that avoids fire you would simply add both the <strong>Path_TowardGoal</strong> constraint and a (hypothetical) <strong>Path_AvoidFire</strong> constraint. This is easily done, and is script accessible so it becomes trivial to cobble together custom, one-off path queries to fit your exact situation.
<p />
The constraints are only half the picture though. One also needs the ability to specify the completion conditions for a path search as well as have a chance to interrogate the data as it is traversed. This is what path goal evaluators are for.  They both dictate when the search is finished (e.g. when we found a valid goal node) as well as handle interrogation and storage of computed data. For example in Gears of War, when searching for cover a <em>cover goal evaluator</em> is used.  This custom goal evaluator will continue the search until a cover node of sufficient quality is found, and it will keep track of cover nodes found thus far, scoring them along the way. The most basic (and commonly used) path goal evaluator is <strong>Goal_AtActor</strong>, which simply stops the search when a navigation mesh polygon is found which contains the search goal point. This is the goal evaluator you would use to find the shortest path from A -&gt; B.
<p />
Constraints and goal evaluators are stored in two lists within the <a href="NavigationMeshTechnicalGuide.html" class="twikiLink">Navigation Handle</a>. <!--  -->
<p />
<p />
<h2><a name="Path Constraints"></a> Path Constraints </h2>
<hr size="1" noshade="noshade">
As mentioned above path constraints can both modify the stored actual distance (g), as well as the heuristic distance (h). Lastly path constraints can also return false on a particular node which indicates this node is absolutely unfit and should not be added to the open list at all.
<p />
Things path constraints should be used for: <ul>
<li> Shaping the traversal toward a goal (e.g. optimize the search by trying nodes toward the goal first)
</li> <li> Restricting traversal through conditionally untraversable areas (e.g. fire, lava, friendly-only doors)
</li> <li> Nudging traversals away from undesirable objects (e.g. enemy players)
</li></ul>
<p />
Things path constraints should/can not be used for: <ul>
<li> Gathering/storing data (your constraint may not get called if a previous constraint returns false)
</li></ul>
<p />
<!--  -->
<p />
<h2><a name="Path Goal Evaluators"></a> Path Goal Evaluators </h2>
<hr size="1" noshade="noshade">
Path goal evaluators are a bit more complicated as they handle more of the basic path finding functionality such as determining the start and end nodes, and determining which node to call the 'goal' once a search stops for any reason.  The goal evaluator sets up the search, and then determines when it's completed, as well as saves the found path back out to the navigation handle once one is found.
<p />
<img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note:</strong> the <em>first</em> path goal evaluator in the list has special meaning. It will be treated as the master evaluator, and thus it will have control over initialization of the search (e.g. seedworkingset, initializesearch).
<p />
Here is the life of a typical path goal evaluator<!--  -->: <ol>
<li> <strong>InitializeSearch()</strong> - This is called at the very beginning of a path search. This allows the goal evaluator to set up whatever it needs to for the search to progress. The default functionality will find the polygon containing <strong>SearchStart</strong> and set that as the <strong>AnchorPoly</strong>.
</li> <li> <strong>SeedWorkingSet()</strong> - This is called next.  This function is responsible populating the open list with one or more polygons to begin searching from.  The default functionality simply adds the anchor polygon to the working set.
</li></ol>
<p />
Now, we enter the main loop of the path search.  <ol>
<li> <strong>EvaluateGoal()</strong> - This will be called after the best node is popped off of the working set.. This function will go through the path goal evaluator list calling EvaluateGoal() on each one in turn.  This allows each goal evaluator in the list a chance to interrogate the polygon, as well as call a halt to the search if a suitable node was found.
</li> <li> <strong>DetermineFinalGoal()</strong> - This will be called once the path has completed. (either because a goal was found or because the search ran out of nodes to test) This allows the goal evaluator to do final computation and determine what the actual best goal was (if any). The default here is just to check to see if a goal was found, but in more complicated evaluators such as <strong>Goal_AtCover</strong> a final stock is taken of polygons visited so far to determine what the most fit goal is.
</li> <li> <strong>SaveResultingPath()</strong> - This is the very last function to get called on the evaluator. On almost all goal evaluators this function simply walks the predecessor chain in reverse to save the path from start to goal.  But this allows a custom evaluator to do something different here. For example, <strong>Goal_ClosestActorInList</strong> (which path finds from goal to start) saves the path in forward order since it's reversed to start (see more on this evaluator below).
</li> <li> <strong>NotifyExceededMaxPathVisits()</strong> - This is one more function called in exceptional cases. This will get called when the number of polygons visited exceeds the <strong>MaxPathVisits</strong> parameter on the navigation handle. In most cases this indicates a failure (e.g. no goal was found within the maximum sample size). But occasionally this just indicates the search is complete (e.g. <strong>Goal_Null</strong> which just searches until it runs out of nodes or hits the max visits cap.. useful for finding the best node in an area).
</li></ol>
<p />
The only function required to be implemented by new path goal evaluators is <strong>EvaluateGoal()</strong>. This is the primary function of goal evaluators (that is, determining when a valid goal has been found).
<p />
There are a couple of booleans which affect the way <strong>EvaluateGoal()</strong> operates. 99% of the traversals we do use the default settings (and actually most traversals only have one goal evaluator so these don't even come into play), but for composition of goal evalators these booleans have been added to make things easier:
<p /> <ul>
<li> <strong>bUseORforEvaluateGoal</strong> (on UNavigationHandle) - by default <strong>all</strong> goal evaluators must return true from <strong>EvaluateGoal()</strong> in order for the search to be considered finished.  This can be modified via the <strong>bUseORforEvaluateGoal</strong> on the navigation handle. (when true, if any goal evaluator returns true from <strong>EvaluateGoal()</strong> the search will be stopped)
</li> <li> <strong>bAlwaysCallEvaluateGoal</strong> (on GoalEvaluator) - when this is true for a particular goal evaluator that goal evalator's <strong>EvaluateGoal()</strong> function will be called even if it has already been determined that the current node is or isn't the final goal.  This is useful for goal evalators that need to store information or compute something for each path iteration.
</li></ul>
<p />
<p />
<h2><a name="Constraint/_GoalEval Pooling"></a> Constraint/GoalEval Pooling </h2>
<hr size="1" noshade="noshade">
In order to keep from needlessly newing path constraints and goal evaluators all the time, they are newed on-demand and cached.  This allows cached constraints and goal evalators to be re-used without newing and garbage collecting large numbers of constraints.
<p />
For this purpose you should never new PathConstraints or GoalEvaluators directly. Instead, you should call <strong>CreatePathConstraint()</strong> or <strong>CreatePathGoalEvaluator()</strong> on the NavigationHandle. This will either new a copy of that constraint if one has not been cached already or retrieve a cached copy.
<p />
As part of the caching process the <strong>Recycle()</strong> event is called when a constraint is cleared from a handle. Within this function all state is cleared and reset to defaults.  When overriding PathConstraints and GoalEvaluators it's important to override this function and clear out any new state that might be a part of your derived class so that you don't get stale data coming with recycled constraints.
<p />
<p />
<h2><a name="Example usage"></a> Example usage </h2>
<hr size="1" noshade="noshade">
It's convenient to implement a static function on constraints/evaluators such that you can call it to add the constraint or evaluator to the handle's lists. Here is an example of one such static function for the <strong>Path_TowardGoal</strong> constraint:
<p />
<div class="codetitlebar">
Path_TowardGoal.uc
</div>
<div class="codesnippet">
<pre>
static function bool TowardGoal(NavigationHandle NavHandle, Actor Goal)
{
  local NavMeshPath&#95;Toward Con;

  if (NavHandle !&#61; None &#38;&#38; Goal !&#61; None)
  {
    Con &#61; NavMeshPath&#95;Toward(NavHandle.CreatePathConstraint(default.class));
    if (Con !&#61; None)
    {
      Con.GoalActor &#61; Goal;
      NavHandle.AddPathConstraint( Con );
      return TRUE;
    }
  }

  return FALSE;
}
</pre>
</div>
<p />
As you can see it calls <strong>CreatePathConstraint()</strong> to retrieve a cached version of that class, and then calls <strong>AddPathConstraint()</strong> to place it in the list of constraints to be used during the search. <strong>AddPathConstraint()</strong>, <strong>AddGoalEvaluator()</strong> and <strong>ClearConstraints()</strong> are the interface for specifying constraints for your traversal.
<p />
<img src="rsrc/TWiki/TWikiDocGraphics/warning.gif" alt="ALERT!" title="ALERT!" width="16" height="16" border="0" /> <strong>Note:</strong> It is usually not necessary to call <strong>ClearConstraints()</strong> as constraints will automatically be cleared after you call <strong>FindPath()</strong>.
<p />
More information about <strong>FindPath()</strong> and its usage can be found on the <a href="NavigationMeshTechnicalGuide.html" class="twikiLink">NavigationMeshTechnicalGuide</a>.  Also, be sure to check out the <a href="NavigationMeshPathDebugging.html" class="twikiLink">NavigationMeshPathDebugging</a> page for more info on how to debug your path searches.
<p />
<p />
<h2><a name="Quick summary of current path constraints and what they are for"></a> Quick summary of current path constraints and what they are for </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="NavMeshPath_AlongLine"></a> NavMeshPath_AlongLine </h3>
This will add heuristic cost to nodes the further away from the direction specified.
<p />
<h3><a name="NavMeshPath_EnforceTwoWayEdges"></a> NavMeshPath_EnforceTwoWayEdges </h3>
This will filter out edges which don't have a corresponding edge back. (keeps AIs from getting into situations they can't get out of).
<p />
<h3><a name="NavMeshPath_MinDistBetweenSpecsOfType"></a> NavMeshPath_MinDistBetweenSpecsOfType </h3>
This will walk back along the predecessor chain at each step to ensure there is a minimum distance between edges of a certain type.  (For example ensuring a minimum distance between mantles)
<p />
<h3><a name="NavMeshPath_SameCoverLink"></a> NavMeshPath_SameCoverLink </h3>
This only allows polys that contain cover from the specified CoverLink.
<p />
<h3><a name="NavMeshPath_Toward"></a> NavMeshPath_Toward </h3>
This will add heuristic cost according to the distance to the passed goal point.  Use this to bias normal path searches toward your a particular goal.
<p />
<h3><a name="NavMeshPath_WithinDistanceEnvelope"></a> NavMeshPath_WithinDistanceEnvelope </h3>
Allows the user to specify an envelope within which paths are valid, and either throw out nodes outside this envelope or penalize them increasingly as they leave it.  (e.g. I want to find a point within some max range to me)
<p />
<h3><a name="NavMeshPath_WithinTraversalDist"></a> NavMeshPath_WithinTraversalDist </h3>
Will throw out paths that exceed a specified value
<p />
<p />
<h2><a name="Quick summary of current path goal evaluators and what they are for"></a> Quick summary of current path goal evaluators and what they are for </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="NavMeshGoal_At"></a> NavMeshGoal_At </h3>
The simplest and most common goal evaluator.  Will end the search when a polygon which contains the goal point is found.
<p />
<h3><a name="NavMeshGoal_ClosestActorInList"></a> NavMeshGoal_ClosestActorInList </h3>
One of the more interesting goal evaluators.  This guy will efficiently find the closest actor (in path distance) to the requesting entity.  This is accomplished via doing a search in reverse.  The working set is seeded with all polygons which contain actors in the list to search for, and then the search continues until the polygon which contains the searchstart is found.  At this point the path is saved in forward order since we're already going in reverse.
<p />
<h3><a name="NavMeshGoal_Filter"></a> NavMeshGoal_Filter </h3>
This is a helper base class which is for filters that are meant to be used in conjunction with NavMeshGoal_GenericFilterContainer. These goals should only answer this question "is this a valid final goal or not?" and do nothing else.
<p />
<!-- <ul>
<li> <strong>NavMeshGoalFilter_MinPathDistance</strong> -
</li> <li> <strong>NavMeshGoalFilter_NotNearOtherAI</strong> -
</li> <li> <strong>NavMeshGoalFilter_OutOfViewFrom</strong> -
</li> <li> <strong>NavMeshGoalFilter_OutSideOfDotProductWedge</strong> -
</li> <li> <strong>NavMeshGoalFilter_PolyEncompassesAI</strong> -
</li></ul>
-->
<p />
<h3><a name="NavMeshGoal_GenericFilterContainer"></a> NavMeshGoal_GenericFilterContainer </h3>
This goal evaluator will not stop until its out of paths, and will simply return the node with the least cost.
<p />
<h3><a name="NavMeshGoal_Null"></a> NavMeshGoal_Null </h3>
This goal evaluator will simply keep searching until the max number of iterations is hit, or the search runs out of nodes. Useful for finding the best node in an area. (e.g. could be used in conjunction with a <strong>NavMeshPath_WithinDistanceEnvelope</strong> constraint to find the furthest away polygon within some max range)
<p />
<h3><a name="NavMeshGoal_PolyEncompassesAI"></a> NavMeshGoal_PolyEncompassesAI </h3>
This goal evaluator will throw out polygons which can't fully fit the entity searching this is useful for open-ended path searches (e.g. find any polygon outside of a radius) because an edge may support the entity allowing the traversal to enter a polygon, but the entity might not necessarily fully fit inside the polygon, even though he could move through it.
<p />
<h3><a name="NavMeshGoal_Random"></a> NavMeshGoal_Random </h3>
This goal evaluator will not stop until its out of paths, and will return one of the nodes traversed at random.
<p />
<h3><a name="NavMeshGoal_WithinDistanceEnvelope"></a> NavMeshGoal_WithinDistanceEnvelope </h3>
This goal evaluator will throw out nodes (polygons) if they are outside the distance envelope specified.
<p />
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
