<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title> UDK | CreatingAnimations    </title>

<style type="text/css" media="all">@import "rsrc/twiki_webs.css";</style>
<style type="text/css" media="all">@import "rsrc/udn_new.css";</style>
<link rel="icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="rsrc/Three/WebPreferences/favicon.ico" type="image/x-icon" />


<!-- view.static_udn3.tmpl  -->
<script language="JavaScript" type="text/javascript" src="rsrc/udn.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

</head>
<p />
<body id="webbgThree">
<p />

<p />
<div id="webThree"><div id="head">
<!--
<div class="header">
 -->
<div style="background: url(/pub/webbg_udn.jpg); background-repeat: no-repeat; height:140px; width: 100%;" >
<!--
<div style="background: transparent url(/pub/udn_header_bg.jpg); background-repeat: repeat-x; height:140px; width: 100%; margin-left: 991px;">
 -->
<p />
<div id="nav">
<ul class="nav">
<font color=black>|</font>&nbsp;&nbsp;<li class=nav_Three><a href="../Main/WebHome.html" class="twikiLink">Main</a></li><font color=black>|</font><li class=nav_Three><a href="../Two/WebHome.html" class="twikiLink">UnrealEngine2</a></li><font color=black>|</font><li class=nav_Three><a href="WebHome.html" class="twikiLink">UnrealEngine3</a></li><font color=black>|</font><li class=nav_Three><a href="https://docs.unrealengine.com" class="twikiLink">UnrealEngine4</a></li><font color=black>|</font><li class=nav_Three><a href="../Main/BusinessAndLegal.html" class="twikiLink">Business &amp; Legal</a></li><font color=black>|</font>
</ul><br><br><br>
</div>
</div>
</div> <!-- end head -->
<div id="pagedefault">
<div id="maincol">
<div id="tool">
<div id="tooltop">UDN</div>
<div id="tooltext" style="padding: 10px 10px 10px 10px;">
Search public documentation: <br>
<form ACTION="/search/index.php" METHOD="GET" NAME="main" ID="main">
<input TYPE="TEXT" NAME="q" SIZE="15" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;">
<input TYPE="SUBMIT" VALUE="Search" STYLE="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: xx-small;"><br>
</form>
</div>
<div id="toolband">CreatingAnimations  </b></div>
<div id="tooltext">
<a href="CreatingAnimationsJP.html" class="twikiLink">日本語訳</a><br><a href="CreatingAnimationsCH.html" class="twikiLink">中国翻译</a><br><a href="CreatingAnimationsKR.html" class="twikiLink">한국어</a><br>

<!-- Three/CreatingAnimations -->
<hr size="1" noshade="noshade" />
Interested in the Unreal Engine? <br>
Visit the <a href="http://www.unrealtechnology.com" target="_top">Unreal Technology</a> site.<br>
<br>
Looking for jobs and company info? <br>
Check out the <a href="http://www.epicgames.com" target="_top">Epic games</a> site.<br>
<br>
Questions about support via UDN? <br>
Contact the <a href="../Main/ContactUDNStaff.html" class="twikiLink">UDN Staff</a> <br>
<br>
</div> <!-- end toolbox content -->
<div id="toolbottom"></div>
</div> <!-- end tool -->
<p />
<noautolink>
<div style="padding:0px 0px 0px 4px;font:10px Verdana;">
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AnimationHome.html" class="twikiLink">Animation</a></b> &gt; Creating Animations for the Unreal Engine <br/>
<b><a href="WebHome.html" class="twikiLink">UE3 Home</a></b> &gt; <b><a href="AnimatorHome.html" class="twikiLink">Animators</a></b> &gt; Creating Animations for the Unreal Engine
</div>
<hr size="1" noshade="noshade">
<h1><a name="Creating Animations for the Unreal Engine"></a> Creating Animations for the Unreal Engine </h1>
<hr size="1" noshade="noshade">
<p />
<div class="twikiToc"> <ul>
<li> <a href="CreatingAnimations.html#Creating Animations for the Unreal Engine"> Creating Animations for the Unreal Engine</a> <ul>
<li> <a href="CreatingAnimations.html#Overview"> Overview</a>
</li> <li> <a href="CreatingAnimations.html#Development Tools"> Development Tools</a>
</li> <li> <a href="CreatingAnimations.html#Characters"> Characters</a>
</li> <li> <a href="CreatingAnimations.html#Weapons"> Weapons</a>
</li> <li> <a href="CreatingAnimations.html#Morph Targets"> Morph Targets</a>
</li> <li> <a href="CreatingAnimations.html#Faces"> Faces</a>
</li> <li> <a href="CreatingAnimations.html#Vehicles"> Vehicles</a>
</li> <li> <a href="CreatingAnimations.html#Cameras"> Cameras</a>
</li> <li> <a href="CreatingAnimations.html#Editor Tools"> Editor Tools</a>
</li> <li> <a href="CreatingAnimations.html#Motion Capture"> Motion Capture</a>
</li> <li> <a href="CreatingAnimations.html#Development Assets"> Development Assets</a>
</li></ul>
</li></ul>
</div>
<p />
<h2><a name="Overview"></a> Overview </h2>
<hr size="1" noshade="noshade">
This document will serve as a starting point for identifying the different types of art assets that are used in animation creation for the Unreal Engine content pipeline.
<p />
<h2><a name="Development Tools"></a> Development Tools </h2>
<hr size="1" noshade="noshade">
<!--
!~---+++ ActorX
<p />
All skeletal characters and animations must be exported from your 3D package and imported into the Unreal Editor through ActorX.
<p />
See the <a href="ActorX.html" class="twikiLink">ActorX</a> page for download information.
-->
Modern 3D content creation packages such as 3DSMax and Maya support FBX. Unreal Engine 3 supports FBX importing and exporting natively.
<p />
<h2><a name="Characters"></a> Characters </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="Character Setup and Rigging"></a> Character Setup and Rigging </h3>
<p />
Character models should be created in a fairly neutral pose, usually in a “T-Pose”, but it is okay to pose the joints in a relaxed, natural position.  The bone structure should be a single hierarchy of bones, mimicking the human skeleton, posed to fit within the character mesh, and parented under a main “root” bone placed at the origin.
<p />
Although the Editor can import skeletal meshes created with the Y-Up axis orientation, we prefer to work with Z-Up in all 3D Packages.  This makes things consistent across the board and allows us to transfer meshes and animations between Max and Maya with no axis issues.
<p />
With Z-Up being the standard, the characters should be modeled and rigged facing down the +Y axis in Max, or the –Y axis in Maya.  (This axis is flipped between the two packages).  In the Editor we apply a rotation offset to the characters to make them face the +X axis in the Editor.
<p />
<img alt="Marcus_Skeleton_Overlay.jpg" src="rsrc/Three/CreatingAnimations/Marcus_Skeleton_Overlay.jpg" />
<p />
The skeleton can also contain extra bones weighted to parts like cloth, armor or hair, and can also contain bones to be used just as attachment points, such as weapon bones or IK bones.
<p />
It’s best to keep your character animation rig completely separate from the skeletal hierarchy.  Adding locators and nodes within the skeletal hierarchy can cause issues when exporting.
<p />
If multiple characters are modeled and proportioned to fit around the same skeleton, these characters can then share animation sets, reducing the amount of animations needed.  Even characters with slightly different proportions can usually share animations.
<p />
<strong><em>Technical note</em></strong>: <ul>
<li> The maximum number of mesh-influencing bones in a skeleton is <strong>75</strong>.
</li> <li> The maximum number of total bones in a skeleton is <strong>256</strong>.
</li></ul>
(Increasing either of these numbers beyond their maximum will cause a second rendering pass on the character, reducing optimization) <ul>
<li> For the mesh, the maximum number of bone influences per vertex is <strong>4</strong>. (Upon import, any vertex that is influenced by more than 4 bones will have its lowest influences removed and normalized among the remaining 4 influences for that vertex.) Note that there is a cost based on the max you use for a particular LOD. So if you can get away with using no more than 3, it will be faster. We generally try and use just 1 for LOD 1 and below.
</li></ul>
<p />
<strong><em>Optimization note</em></strong>:  If multiple characters are modeled and proportioned to fit around the same skeleton, these characters can then share animation sets, reducing the amount of animations needed.  Even characters with slightly different proportions can share animations.
<p />
<strong><em>3D Studio Max note</em></strong>:  We will setup a Biped character first, and then build a skeleton proportioned to match that biped, then constrain that skeleton to the Biped.  This allows us to animate onto the Biped, but then bake out the animation to the skeleton and delete the Biped for exporting as FBX.
<p />
<strong><em>Maya note</em></strong>:  When setting up bone rotations for the bind pose, the initial rotation values of the bind pose can either be put in the main Rotate fields, or in the Joint Orient fields.  Putting these values in the main Rotate fields will let you always see the true rotation values of each joint.  Putting these values in the Joint Orient fields acts as an offset, and allows you “zero out” the main Rotate values of each joint and still retain the proper bind pose.  In the figure below, the characters are in the exact same pose.  On the left, though, the arm bone has an initial rotation value, and on the right, the values are zeroed out without changing the pose by applying the initial rotation to the Joint Orient value.  It's completely personal preference as to which method you choose to use, but it is good to choose one and make sure everyone sticks with it.  Switching between these methods can cause inconsistencies in the pipeline.
<p />
<img alt="JointOrient.JPG" src="rsrc/Three/CreatingAnimations/JointOrient.JPG" />
<p />
<h3><a name="Bones Hierarchy"></a> Bones Hierarchy </h3>
<p />
Having a root bone separate of the pelvis is important. It doesn't matter that much where it is, although it may make things a bit more complicated for certain things. We find it easier to make sure animations will work together when the root is at the feet and origin. If it's somewhere up in the air, it's harder to detect when animations won't chain/blend properly and create a visible pop. For example, when doing <a href="RootMotion.html" class="twikiLink">root motion</a> animations where Marcus climbs up something, it is easier to visualize where the root bone should be put because it should be where his feet are going to be touching the ground.
<p />
For IK, we use IK Bones for the feet and hands, direct children of the root bone. This eliminates position/rotation errors when blending animations with a long bone hierarchy.
<p />
Depending on the animations involved, the location of weapon bones in the hierarchy always has pros and cons. Most of the time our characters are holding guns so it makes sense for them to be children of the hand since no matter how heavily we compress the animations or how low of a framerate we animate at, the gun will maintain a solid position in the hands. The disadvantage is when weapons have to leave the hand. During certain reload animations like the sniper rifle, or when holstering the gun, you might get a lot of fighting between the bones and need to have a higher framerate so it isn't noticeable. Since those types of animations are rare in our case, we decided that having them as children of the hands would give us the best memory savings. If we were animating a bunch of melee weapons where they are constantly spinning them around or something, we would have have chosen to put the weapon bones higher in the hierarchy, maybe even as children of the root.
<p />
The weapon end bones were a put in as a way to change the pivot points of the guns to the center, but still have all of the animations look correct without having to change the weapon bone position in all the animations and then re-export them. There are some minor rig advantages with animating, but it would be better not to have them at all. It was a change that had to happen when we finished how mirroring animations worked without much time to get it implemented. It can be useful to reduce foot sliding. When you blend 2+ animations with a long hierarchy of bones you may get some errors; IK on the feet was a way to ensure the feet would remain at the right place. This was quite noticeable in directional blends. We did keep it on for much larger creatures, like the Brumak boss fight in <a href="https://udn.epicgames.com/Three/GearsOfWar" class="restricted" class="restricted" class="twikiLink">Gears of War</a> (PC).
<p />
The armroll bones - direct children of the upper arm bones - are there just to twist half the amount of the upperarm bone to help the verts deform better. This works better in-game than having roll bones going straight down the arm in the hierarchy, so that way we can still have a two jointed arm for working with IK.
<p />
<img alt="Marcus_Heirarchy.jpg" src="rsrc/Three/CreatingAnimations/Marcus_Heirarchy.jpg" />
<p />
<h3><a name="Character Export"></a> Character Export </h3>
<p />
Once the character mesh is bound to the skeleton and properly weighted in your 3D package, it can be exported as a FBX file which is natively supported in the majority of 3D content creation packages. <!-- If there are extra bones or weighted meshes in the scene that you do not wish to export, you must either remove them from the scene, or (in Maya only) you can rename individual bones with the postfix <strong>_noexport</strong>, or rename the topmost hierarchy bone with the postfix <strong>_ignore</strong>. --> See the <a href="FBXSkeletalMeshPipeline.html#ExportMesh" class="twikiAnchorLink">FBX Skeletal Mesh Exporting</a> page for more information.
<p />
<h3><a name="Character Import and Setup"></a> Character Import and Setup </h3>
<p />
See the <a href="FBXSkeletalMeshPipeline.html#ImportMesh" class="twikiAnchorLink">FBX Skeletal Mesh Importing</a> page for more information.
<p />
<h2><a name="Weapons"></a> Weapons </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="First Person Weapon Setup and Rigging"></a> First Person Weapon Setup and Rigging </h3>
<p />
1st Person weapons are the weapons you see yourself holding in-game.  Since they are placed very close to the player's view, and are usually in the view a majority of the time, the models are usually much higher poly, and have much higher resolution textures on them.
<p />
<strong><em>Tip</em></strong>:  Since the 1st person weapon is usually only seen from one side, the model can be optimized by removing any polygons or objects that are never seen by the viewer (usually on the front/right side of the model.).  Only optimize the model after the final animations are complete, so you know which parts are never seen.
<p />
In your 3D package, place a camera at the origin and align it down the +X axis.  This will represent the in-game view of the player.  Position the 1st person weapon mesh in front of this camera view as it would be seen in-game.  Adjust the camera FOV and mesh position to get the desired look.
<p />
<strong><em>Technical note</em></strong>:  The 1st person models are displayed with a different rendering pass, so view offsets and FOV changes can be made that only affect the 1st person objects without affecting the entire scene view.  Work with a programmer to adjust the FOV, view offset, and clipping planes for 1st person items.
<p />
The first major decision when setting up 1st person weapons is whether you will be able to see your own arms.  The decision to have 1st person arms in view can add levels of complexity to the setup.  On top of that, the decision to have multiple types of arms (male, female, robotic, creature, etc) with each weapon, adds yet another level of complexity.
<p />
<img alt="1P_Weapon.jpg" src="rsrc/Three/CreatingAnimations/1P_Weapon.jpg" />
<p />
<strong><em>1) 1st person weapon only.  No 1st person arms.</em></strong>  This is the least complex option and only requires the rigging and animation of the weapon.  The weapon should be bound to a heirarchy of bones.  This bone structure should be parented under a “root” bone that remains at the origin.  Animate the weapon from the point of view of the camera at the origin.  Once the animations are complete, export the skeletal mesh and animations as separate FBX files.
<p />
<strong><em>2) 1st person weapon and 1st person arms, but no arm variants.</em></strong>  If all characters have similar arms, and you only require one model of the 1st person arms, the arms and weapons can be part of a single skeleton.  This single skeleton should be parented under a “root” bone that remains at the origin.  Animate the weapon and arms from the point of view of the camera at the origin.  Once the animations are complete, export the weapon and arms meshes together as a single FBX file, and export the animations as separate FBX files.
<p />
<strong><em>3) 1st person weapon and multiple variations of 1st person arms.</em></strong>  If your characters are vastly different, and you require multiple 1st person arm meshes that need to work with each weapon, you will need two separate skeletons, one for the weapon, and one for the arms.  Each skeleton needs to be parented under its own “root” bone at the origin of the scene.  From a modeling standpoint, all arm mesh variants should be modeled in the same pose with the same proportions and bound to the same skeleton.  You will export out each arm mesh variant into individual FBX files, and separately export out each weapon mesh into individual FBX files; and then import them into Unreal Editor.  These individual arm skeletal meshes will then be able to share a single AnimSet.
<p />
Once you’ve animated the weapon and arms together in your 3D package, bake out the animations and remove the constraints between them.  Save this file but rename it as an “ExportReady” version, so you have a version with both skeletons.  Delete the arms skeleton and export the weapon animations as a FBX file.  Reopen the “ExportReady” file with both skeletons.  Now delete the weapon skeleton and export the arm animations with the same animation names and frame ranges, but into a different FBX file.  Import each FBX into their own AnimSets.  You will end up with an Arm AnimSet and a Weapon AnimSet for each weapon.
<p />
In-game, the weapon skeletal mesh and the arm skeletal mesh will be put back together and play synchronized animations, and any Arm skeletal mesh will then be able to play the animations from any Arm AnimSet.
<p />
<img alt="1P_Arm_Variants.JPG" src="rsrc/Three/CreatingAnimations/1P_Arm_Variants.JPG" />
<p />
<h4><a name="Tweaking in the Engine"></a> Tweaking in the Engine </h4>
<p />
It’s best to work with a programmer to get the 1st person weapons and arms working in game with the correct camera FOV, loading the correct arm mesh variant, and get the weapon and arm animations synchronized.  Since the animations were based on the origin of the scene, no offset should be needed to get them in view.  You can either apply offsets to the mesh, or a programmer can hard-code offsets if they need some slight tweaking.
<p />
<h3><a name="Third Person Weapon Setup and Rigging"></a> Third Person Weapon Setup and Rigging </h3>
<p />
3rd person weapons are the weapons you see other characters holding.  To setup a 3rd person weapon model, it should first be bound to its own small hierarchy of bones and exported as a skeletal mesh.  The weapon’s “root” bone should be positioned so that when it is constrained to the character’s “weapon” bone, the weapon lines up properly in the character’s hands.
In your 3D package, animate the character and weapon together in the same scene with the weapon’s “root” bone constrained to the character’s “weapon” bone.  You will eventually export out two separate but synchronized animations.  One for the weapon and one for the character.
<p />
<img alt="3P_Weapon_Attach.JPG" src="rsrc/Three/CreatingAnimations/3P_Weapon_Attach.JPG" />
<p />
To animate the weapon and character together, such as a reload animation, bring the rigged character and weapon into the same scene, and constrain the weapon’s “root” bone to the character’s “weapon” bone.  You will eventually export out the weapon and character as two separate, but synchronized, animations.
<p />
Animate the character and weapon as you desire, using constraints to keep hands locked to weapon parts or vice versa.  Once this character-plus-weapon animation is ready, bake the animation out onto both skeletal hierarchies, and remove all constraints between them.  Remove all animation keys from only the weapon’s “root” bone, and set it’s position and rotation values to &lt;0,0,0&gt;.  This will retain animation on all the animated weapon bits, but keep the weapon at the scene’s origin.  Save this file but rename it as an “ExportReady” version.
<p />
<h3><a name="Weapon Export"></a> Weapon Export </h3>
<p />
Open your "Export Ready" file containing the baked animations for the weapon and the character.  Delete the character skeleton and mesh from the scene, and export the weapon animation as a FBX file.  Reopen the “ExportReady” file with both skeletons, and this time delete the weapon skeleton and mesh.  Export the character animation with the same animation name and frame-range, but into a different FBX file.
<p />
<h3><a name="Weapon Import"></a> Weapon Import </h3>
<p />
In Unreal Editor, import the character’s FBX file into the character’s AnimSet, and import the weapon’s FBX file into the weapon AnimSet.
<p />
<h3><a name="Tweaking in the Engine"></a> Tweaking in the Engine </h3>
<p />
Work with a programmer to constrain the weapon skeletal mesh to the character’s “weapon” bone during gameplay.  This may require the creation of a Socket onto the character’s “weapon” bone.  When the animation is then played on both the character and weapon, they should be synchronized.
<p />
<h2><a name="Morph Targets"></a> Morph Targets </h2>
<hr size="1" noshade="noshade">
<p />
<h3><a name="Morph Target Setup"></a> Morph Target Setup </h3>
<p />
<a href="MorphTargets.html" class="twikiLink">Morph Targets</a> (also known as Blend Shapes) are used to change the shape of a mesh, or part of a mesh by offsetting a group of vertices.  This vertex deformation can be a good alternative when bone deformation will not suffice.  Morph Targets can have many applications, including facial animation, muscle simulation, or even vehicle damage.
<p />
<h3><a name="Morph Target Export"></a> Morph Target Export </h3>
<p />
For use in Unreal Editor, Morph Targets can be exported together with Skeletal Meshes in a single FBX file and imported into Unreal Editor all in one go. Or if it is preferred, you may also export them individually and import them in individually. See the <a href="FBXMorphTargetPipeline.html#ImportingMorphs" class="twikiAnchorLink">FBX Importing Morph Targets</a> page for more information.
<p />
<!--
In your 3D package, target all morphs onto the same mesh.  With this target mesh selected, turn on the first morph and export the target mesh as a .PSK file using the ActorX exporter.  Turn off the first morph and then turn on the next one, and export out that same target mesh as another .PSK.  Repeat this until each morph is exported into individual .PSK files.
-->
<p />
<strong><em>Morph Note</em></strong>:  All morphs should be exported from, and imported into, the same mesh to ensure that the vertex order remains the same.  Importing a morph onto a mesh with a different vertex order will most likely cause problems.  Be sure not to move the mesh, or change the skeletal bind pose when exporting each morph.  Re-importing the source skeletal mesh can also cause vertex order problems and may require re-importing the morph targets.
<p />
<h3><a name="Morph Target Import and Setup in the Editor"></a> Morph Target Import and Setup in the Editor </h3>
<p />
See the <a href="FBXMorphTargetPipeline.html#ImportingMorphs" class="twikiAnchorLink">FBX Importing Morph Targets</a> page for more information
<p />
<!--
To import and setup morph targets in the Unreal Editor, you must create a MorphTargetSet Asset.  Then import your PSKs into that MorphTargetSet to create a list of morphs.  Then attach the morph list to your skeletal mesh in the Animtree.  At that point, a programmer can access and apply the morphs, or they can be applied and modified in Matinee.
<p />
To create a MorphSet asset, double click on the skeletal mesh you wish to apply the morphs to.  This will open the Animset Editor.  In the Animset Editor, select the menu item File -&gt; NewMorphTargetSet.  Enter the Package, Group, and Name of the new MorphTargetSet asset you would like to create.
<p />
Click on the "Morph" tab at the top of the Browser section of the Animset Editor.  Your new MorphTargetSet should be selected.  If not, click on the drop-down menu and find your new MorphTargetSet.
<p />
To import your PSK files into the morph list, select the menu item File -&gt; Import MorphTarget.  Select your list of PSKs (you can shift select multiple PSK files), and click on "OK".  Each morph will bring up a dialog box allowing you to either double-check or change the name of the morph.  Morphs for high polygon meshes can take a while to import.  After import, click on each morph in the MorphTargets list.  This will preview the selected morph onto the source mesh in the 3D window, so you can verify that they imported correctly.
-->
<p />
<strong><em>Technical Note</em></strong>:  When importing new morphs, the editor compares vertices, in vertex order, between the imported PSK and the source skeletal mesh, and finds the ones where the positions have changed, and only saves data for the vertices that have moved.
<p />
To connect the morph targets to your skeletal mesh, open the AnimTree for your skeletal mesh.  This will open the AnimTree Editor. In the AnimTree Editor select the AnimTree node.
<p />
<img alt="Morph_AnimtreeNode.jpg" src="rsrc/Three/CreatingAnimations/Morph_AnimtreeNode.jpg" />
<p />
You first need to connect the AnimTree to the MorphTartetSet you created. In the Properties section, expand the "Preview Mesh List" properties. Then add an item in the Preview Morph Sets. Expand the "Preview Morph Sets" list.
<p />
<img alt="Morph_AnimtreeProperties_AddMorphItem.jpg" src="rsrc/Three/CreatingAnimations/Morph_AnimtreeProperties_AddMorphItem.jpg" />
<p />
With the AnimTree Editor window open, go back to the Content Browser and select your MorphTargetSet.  Then come back to this AnimTree Editor window and click on the green arrow to add the selected MorphTargetSet to the Preview Morph Set list.
<p />
<img alt="Morph_AnimtreeProperties_ApplyMorphSet.jpg" src="rsrc/Three/CreatingAnimations/Morph_AnimtreeProperties_ApplyMorphSet.jpg" />
<p />
Now you must connect the individual morphs to the AnimTree.  Click on a blank area of the AnimTree Editor window to display a list of nodes.  Select "MorphNodeWeight" to create that node.  Right click again on a blank area, and select "MorphPose" to create that node.  Link the morph nodes and the animtree as shown.
<p />
<img alt="Morph_AnimtreeHeirarchy.jpg" src="rsrc/Three/CreatingAnimations/Morph_AnimtreeHeirarchy.jpg" />
<p />
Select on the MorphPose node and, in the properties section, enter the name of an existing morph in your MorphTargetSet.  You should now be able to drag the value bar below the MorphNodeWeight node and see the Morph blend in and out in the 3D window.  Rename the MorphNodeWeight node.  The name of the MorphNodeWeight node will be used through Matinee or by a programmer to apply the morph in-game.
<p />
To quickly duplicate this tree, and add more morphs to the AnimTree, select both the MorphNodeWeight node and the MorphPose node and press Ctrl+W to duplicate the nodes and links.  Change the morph name in the new MorphPose node, and rename the MorphNodeWeight node.
<p />
<h2><a name="Faces"></a> Faces </h2>
<hr size="1" noshade="noshade">
<p />
For information on setting up FaceFX, please see the <a href="IntroductionToFaceFX.html" class="twikiLink">Introduction to Face FX</a> page.
<p />
<h2><a name="Vehicles"></a> Vehicles </h2>
<hr size="1" noshade="noshade">
<p />
For information on setting up and rigging vehicles, please see the <a href="SettingUpVehicles.html" class="twikiLink">Setting up Vehicles</a> page.
<p />
<h2><a name="Cameras"></a> Cameras </h2>
<hr size="1" noshade="noshade">
<p />
For information on setting up and rigging cameras, please see the <a href="SettingUpCameras.html" class="twikiLink">Setting up Cameras</a> page.
<p />
<!--
!---++ Creatures
<hr size="1" noshade="noshade">
-->
<p />
<h2><a name="Editor Tools"></a> Editor Tools </h2>
<hr size="1" noshade="noshade">
<p />
<!--
!---++ Understanding PSKs and PSAs
<hr size="1" noshade="noshade">
<p />
When importing skeletal meshes and animations into the editor, you will be working with two file types: PSK's and PSA's
<p />
A <strong>PSK</strong> file contains all the information about the skeletal mesh, including the mesh itself, material numbers, edge smoothing, bone hierarchy, bone position and orientation at the bind pose, as well as the vertex weighting information.  It contains no animation info.  When imported into the editor, this will create a mesh weighted to a hierarchy of bones.  The mesh will be exported in the pose that it was in at the beginning of the timeline of your 3D package, and in the Editor, this will be its Bind Pose.
<p />
A <strong>PSA</strong> file contains a list of animations.  These animations contain bone position and orientation data over a range of time.  This data is relative to its parent bone, so if the hierarchy changes, animations may have to be re-exported.  When imported into the editor, this will add the list of animations into an Animset, containing its own list of bone tracks, and position and rotation data for those tracks.
<p />
<strong><em>PSA Note</em></strong>: Keep in mind that this list of bone tracks is completely independent of the bones in the skeletal mesh it is linked to, and will only apply animation to the skeletal mesh bones that match the animset's track list.  Bones can be added to the track list by importing an animation containing the extra bones.  Bones can be removed from the track list by selecting the "Delete tracks" menu item in the animation browser.  Deleting tracks from an animset will not add or remove bones from any skeletal mesh.  Linking an animset to a different skeletal mesh will not change the animset's track list of bones.
-->
<p />
<h3><a name="Content Import and Setup in the Editor"></a> Content Import and Setup in the Editor </h3>
<p />
<!--
To import your PSK file into the Unreal Editor, you must first open the Asset Browser, and load the package you wish to import your character into.
<p />
Right click on the package in the list, and choose "Import..."
<p />
Select your PSK file, and click "Open"
<p />
In the import dialog box that opens, verify the package name is the correct one.  Typing a new, unused name in this field will create a new package upon import.  You can also add a name to the "Group" field, if you wish to add a new sub group, or import into an existing sub group.  In the "Name" field, verify that the name is correct.  By default, it will use the name of the PSK file.  Type the name of an existing skeletal mesh to overwrite it.
<p />
If you are using Y-Up in Maya, you can check on the "bAssumeMayaCoordinates" box, and this will apply offsets to reorient the mesh to look correct in the Editor.
<p />
Click "OK", and this will create a new skeletal mesh in the package.  High polygon meshes may take a while to import.
-->
See the <a href="FBXSkeletalMeshPipeline.html#ImportMesh" class="twikiAnchorLink">FBX Skeletal Mesh Importing</a> page for more information about importing skeletal meshes into Unreal Engine 3. To view and edit this mesh, double click on it within the Content Browser.  This will open the AnimSet Editor window.  This window is used to modify AnimSets, Skeletal Meshes and Morph Targets.
<p />
<h3><a name="Animation Set Editor"></a> Animation Set Editor </h3>
<p />
<!--
The Animset Editor Window is used to view and modify AnimSets, Skeletal Meshes and Morph Targets.
<p />
<img alt="AnimsetEditor_ColorCoded.jpg" src="rsrc/Three/CreatingAnimations/AnimsetEditor_ColorCoded.jpg" />
<p />
<font color="#0000ff">Preview Buttons</font>: for manipulating what is shown in the 3D view <br />
<font color="#008080">Browser</font>: for listing and selecting meshes, animations, or morphs. <br />
<font color="#008000">Skeleton Tree</font>:  for viewing the hierarchy and hiding bones in the 3D view <br />
<font color="#ff00ff">Properties</font>: for modifying settings for meshes, animations, or morphs. <br />
<font color="#800000">3D View</font>: for viewing meshes, animations, and morphs <br />
<font color="#808000">Time Slider</font>: for playing and pausing animations, and viewing animnotifies
<p />
In the 3D view, use the left mouse button to orbit the view around your mesh.   The right button moves your view closer and farther away, and the middle mouse button pans your view to the left, right, up or down.
<p />
Holding the "L" key while dragging in the 3D window, will allow you to move the light.
<p />
<strong>General buttons</strong>:
<p />
<img alt="AnimsetEditor_MainButtons.jpg" src="rsrc/Three/CreatingAnimations/AnimsetEditor_MainButtons.jpg" />
<p /> <dl>
<dt> <strong>Show Skeleton</strong> </dt><dd> This displays the bones structure in the 3D window, overlaid over the mesh.  With this turned on, you can show and hide certain bones by right clicking on them in the Skeleton Tree section.
</dd></dl>
<p /> <dl>
<dt> <strong>Show Bone Names</strong> </dt><dd> This displays the names of each bone in the 3D window.
</dd></dl>
<p /> <dl>
<dt> <strong>Show Wireframe</strong> </dt><dd> This toggles between wireframe view and shaded view
</dd></dl>
<p /> <dl>
<dt> <strong>Show Reference Pose</strong> </dt><dd> This will force the skeletal mesh into its bind pose (the pose it was imported in).
</dd></dl>
<p /> <dl>
<dt> <strong>Show Mirror</strong> </dt><dd> This will mirror the animation along the XZ plane.  It is for preview only.  It does not actually modify the animation.
</dd></dl>
<p /> <dl>
<dt> <strong>Socket Manager</strong> </dt><dd> This opens the Socket Manager window allowing you to add Sockets to bones.  Sockets are use to attach items such as weapons or particles.  Sockets can be offset from the bone if needed.
</dd></dl>
<p /> <dl>
<dt> <strong>New Notify</strong> </dt><dd> This adds an AnimNotify to the timeline of the selected animation.  Animnotifies are points in the timeline that can trigger an event, such as a sound, a particle, attachment swap, or any number of things that a programmer can hook up.
</dd></dl>
<p /> <dl>
<dt> <strong>Toggle Cloth</strong> </dt><dd> This allows you to view vertex cloth simulation.
</dd></dl>
<p /> <dl>
<dt> <strong>Generate Soft-Body Tetrahedron Mesh</strong> </dt><dd> (?)
</dd></dl>
<p /> <dl>
<dt> <strong>Toggle Soft-Body Preview Simulation</strong> </dt><dd> (?)
</dd></dl>
<p /> <dl>
<dt> <strong>Show Uncompressed Animation</strong> </dt><dd> When animation compression is applied, and Show Skeleton is toggled on, this will overlay another skeleton playing uncompressed version of the selected animation.  So you can visually compare the difference between the two skeletons.
</dd></dl>
<p /> <dl>
<dt> <strong>Animation Compression...</strong> </dt><dd> This opens the Animation Compression window
</dd></dl>
<p /> <dl>
<dt> <strong>LOD</strong> </dt><dd> This set of buttons will change the Level of Detail viewed in the 3D window.  AUTO will show the LOD's as they would be displayed in game, and will change the LOD mesh depending on the viewers distance from the mesh.  The current LOD level number can be seen in the top left corner of the 3D window.  The B, 1, 2, 3 Buttons will force the 3D window to display that LOD level.  "B" refers to Base, or LOD-0.
</dd></dl>
<p /> <dl>
<dt> <strong>Playback Speed</strong> </dt><dd> This set of buttons will change the playback speed of an animation in the 3D window.  But will only change the preview rate, and will not affect its play rate in game.  The "RateScale" setting, which will affect the speed of the animation in-game, can be modified in the AnimSequence tab in the Properties section.
</dd></dl>
-->
See the <a href="AnimSetEditorUserGuide.html" class="twikiLink">AnimSet Editor User Guide</a> for more information.
<p />
<h3><a name="Animation Tree Editor"></a> Animation Tree Editor </h3>
<hr size="1" noshade="noshade">
<p />
See the <a href="AnimTreeEditorUserGuide.html" class="twikiLink">AnimTree Editor User Guide</a> for more information.
<p />
<h3><a name="PhAT"></a> PhAT </h3>
<hr size="1" noshade="noshade">
<p />
See the <a href="PhATUserGuide.html" class="twikiLink">Physics Editor User Guide</a> for more information.
<p />
<h2><a name="Motion Capture"></a> Motion Capture </h2>
<hr size="1" noshade="noshade">
<p />
This section will discuss Epic’s particular motion capture equipment and pipeline.  But keep in mind there are many types of motion capture systems on the market.  Each type has its advantages and disadvantages.  Use the system that will work best for you.  Whatever motion capture system or pipeline you use, the final animation must be exported from a 3D Package such as Max, Maya or Softimage, using the ActorX exporter, in order to be imported into the Unreal Editor.
<p />
We use a <a href="http://www.vicon.com/">Vicon MX</a> system.  This is a “Passive Optical” system which tracks reflective markers attached by velcro to the actor.  Our system has 36 cameras arranged fairly evenly throughout the room.  We also record synchronized reference video at the same time.
<p />
<strong><em>Our motion capture pipeline is as follows</em></strong>: <ol>
<li> Calibrate System
</li> <li> Capture the movement.
</li> <li> Clean marker data with Vicon IQ or Blade.
</li> <li> Target on to characters in Motionbuilder.
</li> <li> Polish animation in Max or Maya.
</li> <li> Import into the Unreal Editor using ActorX.
</li></ol>
<p />
We currently use Vicon Blade software to capture, clean, and label the marker data.  The marker placement on the actors can vary based on your needs, but we use 51 markers per actor in the following layout:
<p />
<img alt="Mocap_Marker_Placement.jpg" src="rsrc/Three/CreatingAnimations/Mocap_Marker_Placement.jpg" />
<p />
We also place markers on weapons and props – trying to put 4 or 5 markers on each weapon or object that needs to be tracked.  You really only need 3 markers, but it helps to add one or two more in case of occlusion.  It also makes it easier to determine the front of the object when you’re cleaning and labeling the data.
<p />
<img alt="Markered_Gun_Lancer.jpg" src="rsrc/Three/CreatingAnimations/Markered_Gun_Lancer.jpg" />
<p />
After cleaning and labeling the marker data in Vicon IQ, we then import that labeled marker data as well as a fully rigged character into a Motionbuilder scene, and then target the motion onto that character.  Once Motionbuilder’s “Character” and “Actor” options have been adjusted to create the desired movement and posture, we plot the animation (also known as “baking” the animation) either to the character skeleton or to a Motionbuilder character rig.  At that point we can further clean the animation, or adjust the timing, or setup loops, all within Motionbuilder.
<p />
We then import that animation from Motionbuilder onto a Max Biped or into Maya, to apply final polish to the animation.
<p />
Once the animation is exactly how we want it, we use ActorX to export that animation out of Max or Maya into the Unreal Editor.
<p />
<strong><em>Tip</em></strong>: We have a camcorder mounted at one corner of the room.  Our system is setup to capture video from that camcorder and synchronize it with the data.  Be sure the camcorder has a wide enough lens to cover all of the capture space!
<p />
<img alt="Mocap_RefCam_Comp.jpg" src="rsrc/Three/CreatingAnimations/Mocap_RefCam_Comp.jpg" />
<p />
<strong><em>Tip</em></strong>:  It is easier to clean the data if all characters always stay within the capture volume, and if they start and end each performance in a T-Pose.  The only time we let an actor exit the captures space is if he is sprinting.  Once an actor leaves the capture space, he should remain out and not return to a T-Pose at the end of the scene.
<p />
<strong><em>Tip</em></strong>:  We will attach colored Velcro straps to each actor so that we have an easy way to identify actors in the reference video.
<p />
<img alt="Mocap_Character_RefPose.jpg" src="rsrc/Three/CreatingAnimations/Mocap_Character_RefPose.jpg" />
<p />
<h3><a name="Mo-capping for in-game animations versus mo-capping for cinematics."></a> Mo-capping for in-game animations versus mo-capping for cinematics. </h3>
<p />
<strong><em>Mo-capping for in-game animations</em></strong>:  When capturing in-game animations you will probably only capture a single actor at a time.  Possibly two actors if there is any type of interaction.  Many times the animator himself will get suited up and be captured because he best knows what type of animation is required.  Keep in mind which animations this will eventually blend to or blend from, and try to come close to that pose at the beginning and end of the motion.  Also keep in mind whether the animation will be looped, such as idles or idle-breaks, and try to minimize any unique movements that will make the loop obvious.  In-game animations will probably not be acting to a specific camera, so they will need to look good from every angle.
<p />
<strong><em>Mo-capping for cinematic animations</em></strong>:  When capturing animations for Cinematics or Cut-Scenes, you will capture all actors that will be in the scene.  In our case, we usually capture up to five professional actors at once.  It is best to use pipelines similar to film production, including scripts, storyboards, animatics, and pre-recorded voiceover.  All of these will help set up the scene for the actors and animators involved when recording the mo-cap.  We will usually marker up a camcorder, and have a Cinematic Director walk around filming the scene from the intended view, at the same time the scene is mo-capped.  Your actors will perform to this camera, and in the end, you will end up with reference video that can be used to setup the camera work in Matinee.  And if a particular cinematic requires a handheld camera look, you will also have the camera movement captured in the mo-cap session.
<p />
<strong><em>Tip</em></strong>:  You can adjust the actor’s stance and walk by adding weight to parts of the body.  For the Boomer animations in Gears of War, we added ankle weights and a diving weight belt to the actor to achieve a “lumbering” walk cycle.
<p />
<h2><a name="Development Assets"></a> Development Assets </h2>
<hr size="1" noshade="noshade">
<p />
<!-- !---+++ Animation Data -->
<p />
<h3><a name="Motion Capture Data"></a> Motion Capture Data </h3>
<p />
Typically, human motion is best captured by motion capture.
<p />
At Epic we capture using Vicon IQ, then target the data using Motion Builder, and do any time shifting or looping in Motion Builder. We then export the targeted animation into 3D Studio Max using BVH's, or into Maya using the FBX importer and do the final cleanup in either of those two packages.
<p />
<!--
!---+++ Keyframed Data
<p />
!---++ Exporting
<hr size="1" noshade="noshade">
<p />
!---++ Importing
<hr size="1" noshade="noshade">
-->
</noautolink>
<p />
<p />
<p />
<p />
<p />
<p />


<!-- BEGIN UE4 NOTICE -->



<div id="version_message" style="display:none;">

    <div style="position:fixed;top:0px;left:0px;width:100%;height:100%;background:#000;opacity:0.5;">

    </div>

    <div style="position:fixed;top:50%;left:50%;margin:-70px 0px 0px -240px;background:#FFF;border-radius:6px;width:480px;box-shadow:0px 5px 30px -5px rgba(0,0,0,0.9);">

        <div style="font-size:16px;font-weight:bold;background: url(rsrc/Three/warning.png) no-repeat scroll 5px 5px;padding:4px 10px 5px 25px;height:21px;width:440px;">

            Important!

        </div>

        <div style="font-size:11px;padding:5px 10px 10px;width:460px;">

            <p>You are viewing documentation for the <strong>Unreal Development Kit (UDK)</strong>.</p>



            <p>If you are looking for the Unreal Engine 4 documentation, please visit the <a style="color:#000;" href="https://docs.unrealengine.com">Unreal Engine 4 Documentation</a> site.</p>

        </div>

        <div style="height:20px;padding:4px;margin:6px;border-top:1px solid #a0a0a0;">

            <form onsubmit="return closeVersionMessage();">

                <input type="checkbox" id="dismiss" value="dismiss" />

                <label for="dsimiss">Don't show me this again</label>

                <input type="submit" value="Close" style="cursor:pointer;float:right;width:60px;color:#f0f0f0;font-weight:bold;background:#882222;height:24px;padding:2px 3px 3px;text-align:center;border:1px outset #000;" />

            </form>

        </div>

    </div>

</div>



<script type="text/javascript">

    window.onload = function () {

        LoadVersionMessage();

    }



    function LoadVersionMessage()

    {

        var showMessage = "false";
        if(showMessage != "false")

        {

            showVersionMessage();

        }

    }



    function showVersionMessage()

    {

        var message = document.getElementById("version_message");

        if(message)

        {

            message.style.display = "block";

        }

    }



    function closeVersionMessage() {

        var dismiss = document.getElementById("dismiss");

        var message = document.getElementById("version_message");

        if (message) {

            message.style.display = "none";

        }

        if (dismiss.checked) {

            eraseCookie("doc_version_message");

            createCookie("doc_version_message", "false", 365);

            dismiss.checked = false;

        }

        return false;

    }



    function createCookie(name, value, days) {

        if (days) {

            var date = new Date();

            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));

            var expires = "; expires=" + date.toGMTString();

        }

        else var expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";

    }



    function readCookie(name) {

        var nameEQ = name + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i];

            while (c.charAt(0) == ' ') c = c.substring(1, c.length);

            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);

        }

        return null;

    }



    function eraseCookie(name) {

        createCookie(name, "", -1);

    }

</script>



<!-- END UE4 NOTICE -->



</div></div><div id="footer"><div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;"><div>&nbsp;</div><div style="float: left; text-align: left; vertical-align: bottom; width: 50%;"><a href="http://www.videogamevoters.org"><img src="rsrc/vgvn.jpg" border="0" width="234" height="60" alt="Video Game Voters Network" /></a></div><div style="float: right; text-align: right; vertical-align: bottom; width: 50%;">Copyright &copy; 2001-2012 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a><br /><a href="../Main/TermsAndConditions.html" class="twikiLink">Terms and Conditions</a><br /><a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a></div></div></div></div>
<p />
</html></body>
